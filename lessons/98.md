# Lesson 98: System Calls and Precompiles

*"The devil is in the details, but so is salvation." - Hyman Rickover*

## Overview
System calls and precompiles provide optimized implementations of common cryptographic and mathematical operations in Ethereum. This lesson covers precompiled contracts, EVM extensions, and system-level operations.

## Key Concepts
- **Precompiled Contracts**: Built-in contracts at fixed addresses
- **EVM Extensions**: Custom opcodes and operations
- **System Operations**: Privileged operations and state access
- **Gas Optimization**: Efficient implementations of expensive operations

## Why Precompiles Matter (Like Calculator vs Abacus)

Think of precompiles like having a scientific calculator when everyone else is using an abacus. Both can do math, but one is vastly more efficient for complex operations:

- **Speed**: Like calculator vs manual calculation, precompiles are orders of magnitude faster
- **Accuracy**: Like built-in math functions, precompiles eliminate implementation errors
- **Gas Efficiency**: Like using shortcuts, precompiles cost less gas than EVM equivalent
- **Standardization**: Like everyone using the same calculator model, precompiles ensure consistency

From Reth's EVM implementation, we see how precompiles integrate with the virtual machine:

```rust
// How Reth's EVM handles precompiles efficiently
impl<T: Transport + Clone, P: Provider<T>, DB: Database + Clone> Evm<T, P, DB> {
    /// Execute a call that might hit a precompile
    pub fn execute_call(&mut self, call: CallInputs) -> Result<CallResult, EVMError> {
        let to_address = call.target_address;
        
        // WHY: Check for precompiles first - they're much more efficient
        // Like checking if you have a calculator before doing long division by hand
        if let Some(precompile) = self.precompiles.get(&to_address) {
            return self.execute_precompile(precompile, &call);
        }
        
        // WHY: Fall back to regular contract execution if not a precompile
        // Like using manual calculation when no calculator is available
        self.execute_contract_call(call)
    }
    
    fn execute_precompile(&mut self, precompile: &Precompile, call: &CallInputs) -> Result<CallResult, EVMError> {
        // WHY: Validate input before expensive operations
        // Like checking if numbers make sense before calculating
        if call.input.len() > MAX_PRECOMPILE_INPUT_SIZE {
            return Err(EVMError::InputTooLarge);
        }
        
        // WHY: Calculate gas cost first to avoid DoS attacks
        // Like checking if you have enough money before ordering expensive food
        let gas_cost = precompile.gas_cost(&call.input)
            .map_err(|e| EVMError::PrecompileError(e))?;
        
        if call.gas_limit < gas_cost {
            return Ok(CallResult {
                result: ExecutionResult::Revert { 
                    gas_used: call.gas_limit,
                    output: Bytes::new(),
                },
                address: call.target_address,
            });
        }
        
        // WHY: Execute the optimized precompile implementation
        // Like using the calculator's built-in square root function
        let output = precompile.execute(&call.input, &self.context)
            .map_err(|e| EVMError::PrecompileError(e))?;
        
        Ok(CallResult {
            result: ExecutionResult::Success {
                reason: SuccessReason::Return,
                gas_used: gas_cost,
                gas_refunded: 0,
                logs: Vec::new(),
                output,
            },
            address: call.target_address,
        })
    }
}
```

## Real-World Precompile Patterns

### 1. Cryptographic Precompiles (Like Hardware Security Modules)

Just as banks use specialized hardware security modules for cryptographic operations, Ethereum uses precompiles for crypto:

```rust
// Cryptographic precompiles like specialized hardware
pub struct CryptographicPrecompileManager {
    // Like having a dedicated encryption chip
    signature_processor: SignatureProcessor,
    // Like having a dedicated hashing unit
    hash_processor: HashProcessor,
    // Like having elliptic curve acceleration
    curve_processor: EllipticCurveProcessor,
}

impl CryptographicPrecompileManager {
    pub fn verify_signature(&self, hash: &[u8], signature: &[u8], recovery_id: u8) -> Result<Address, CryptoError> {
        // WHY: Signature verification is computationally expensive
        // Like using a dedicated chip instead of software crypto
        
        // Validate input parameters
        if hash.len() != 32 {
            return Err(CryptoError::InvalidHashLength);
        }
        
        if signature.len() != 64 {
            return Err(CryptoError::InvalidSignatureLength);
        }
        
        if recovery_id > 3 {
            return Err(CryptoError::InvalidRecoveryId);
        }
        
        // WHY: Use optimized native implementation
        // Like hardware acceleration for crypto operations
        let public_key = self.signature_processor.recover_public_key(hash, signature, recovery_id)?;
        
        // WHY: Convert public key to Ethereum address format
        // Like converting raw output to standard format
        let address = self.public_key_to_address(&public_key)?;
        
        Ok(address)
    }
    
    pub fn hash_data(&self, algorithm: HashAlgorithm, data: &[u8]) -> Result<Vec<u8>, CryptoError> {
        // WHY: Different algorithms have different characteristics
        // Like choosing the right tool for the job
        
        match algorithm {
            HashAlgorithm::Sha256 => {
                // WHY: SHA-256 is widely used and well-tested
                // Like using a standard calculator everyone trusts
                self.hash_processor.sha256(data)
            }
            HashAlgorithm::Ripemd160 => {
                // WHY: RIPEMD-160 is used for specific Bitcoin compatibility
                // Like using a specialized calculator for specific formulas
                self.hash_processor.ripemd160(data)
            }
            HashAlgorithm::Blake2f => {
                // WHY: Blake2f is optimized for performance
                // Like using a high-speed calculator for bulk operations
                self.hash_processor.blake2f(data)
            }
        }
    }
    
    pub fn elliptic_curve_operation(&self, operation: CurveOperation, inputs: &[u8]) -> Result<Vec<u8>, CryptoError> {
        // WHY: Elliptic curve operations are fundamental to blockchain cryptography
        // Like having specialized geometric instruments for complex calculations
        
        match operation {
            CurveOperation::Addition => {
                // WHY: Point addition is used in signature aggregation
                // Like adding vectors using specialized tools
                self.curve_processor.point_addition(inputs)
            }
            CurveOperation::ScalarMultiplication => {
                // WHY: Scalar multiplication is used in key derivation
                // Like multiplying matrices with dedicated hardware
                self.curve_processor.scalar_multiplication(inputs)
            }
            CurveOperation::Pairing => {
                // WHY: Pairing operations enable advanced cryptographic protocols
                // Like using specialized equipment for complex chemistry
                self.curve_processor.pairing_check(inputs)
            }
        }
    }
}
```

### 2. Gas-Optimized Implementations (Like Assembly vs High-Level Language)

Sometimes you need to drop down to assembly for performance. Precompiles are like having assembly implementations for critical functions:

```rust
// Gas-optimized precompile implementations
pub struct GasOptimizedPrecompiles {
    // Like having hand-optimized assembly routines
    native_implementations: NativeImplementations,
    // Like having lookup tables for common operations
    precomputed_tables: PrecomputedTables,
    // Like having hardware acceleration
    specialized_hardware: Option<HardwareAccelerator>,
}

impl GasOptimizedPrecompiles {
    pub fn modular_exponentiation(&self, base: &[u8], exponent: &[u8], modulus: &[u8]) -> Result<Vec<u8>, PrecompileError> {
        // WHY: Modular exponentiation is extremely expensive in EVM
        // Like doing complex multiplication - much faster with a calculator
        
        // Early return for trivial cases
        if modulus.len() == 1 && modulus[0] == 0 {
            return Ok(vec![0]);
        }
        
        if exponent.len() == 1 && exponent[0] == 0 {
            return Ok(vec![1]);
        }
        
        // WHY: Use Montgomery ladder for efficiency
        // Like using an optimized algorithm instead of naive approach
        if let Some(hw_accel) = &self.specialized_hardware {
            // Use hardware acceleration if available
            hw_accel.modular_exponentiation(base, exponent, modulus)
        } else {
            // Fall back to optimized software implementation
            self.native_implementations.modular_exponentiation(base, exponent, modulus)
        }
    }
    
    pub fn identity_function(&self, input: &[u8]) -> Result<Vec<u8>, PrecompileError> {
        // WHY: Even simple operations need gas accounting
        // Like even using a calculator costs batteries
        
        // Identity function just returns input, but still costs gas
        // This demonstrates the gas model - even "free" operations have overhead
        Ok(input.to_vec())
    }
    
    pub fn calculate_gas_cost(&self, operation: PrecompileOperation, input_size: usize) -> u64 {
        // WHY: Gas costs must be predictable and fair
        // Like having a clear price list for calculator rentals
        
        match operation {
            PrecompileOperation::EcRecover => {
                // WHY: Fixed cost for signature recovery
                // Like flat fee for using signature verification service
                3000
            }
            PrecompileOperation::Sha256 => {
                // WHY: Cost scales with input size
                // Like paying more for longer documents to hash
                60 + 12 * ((input_size + 31) / 32)
            }
            PrecompileOperation::Ripemd160 => {
                // WHY: Different algorithms have different costs
                // Like different calculators having different rental prices
                600 + 120 * ((input_size + 31) / 32)
            }
            PrecompileOperation::Identity => {
                // WHY: Even simple operations have base cost
                // Like minimum charge for using any service
                15 + 3 * ((input_size + 31) / 32)
            }
            PrecompileOperation::ModExp => {
                // WHY: Complex operations need dynamic pricing
                // Like sophisticated calculations costing more
                self.calculate_modexp_gas_cost(input_size)
            }
            PrecompileOperation::BnAdd => {
                // WHY: Elliptic curve operations have fixed cost
                150
            }
            PrecompileOperation::BnMul => {
                // WHY: Scalar multiplication is more expensive than addition
                6000
            }
            PrecompileOperation::BnPairing => {
                // WHY: Pairing operations are the most expensive
                // Like using the most advanced mathematical instruments
                let pair_count = input_size / 192;
                45000 + 34000 * pair_count as u64
            }
        }
    }
}
```

### 3. System Call Interface (Like Operating System APIs)

Just as operating systems provide system calls for privileged operations, blockchain systems need access to blockchain state:

```rust
// System calls for blockchain state access
pub struct BlockchainSystemCalls {
    // Like having privileged access to system information
    block_provider: BlockProvider,
    // Like having access to system time
    timestamp_provider: TimestampProvider,
    // Like having access to system configuration
    chain_config: ChainConfig,
}

impl BlockchainSystemCalls {
    pub fn get_block_hash(&self, block_number: u64) -> Result<B256, SystemCallError> {
        // WHY: Block hashes are fundamental to blockchain operation
        // Like asking the operating system for file information
        
        let current_block = self.block_provider.get_current_block_number();
        
        // WHY: Only recent block hashes are available
        // Like OS only keeping recent file access logs
        if block_number >= current_block {
            // Can't get hash of future blocks
            return Ok(B256::ZERO);
        }
        
        if current_block - block_number > 256 {
            // Can only access last 256 block hashes
            return Ok(B256::ZERO);
        }
        
        // WHY: Retrieve from the canonical chain
        // Like getting official records from the government database
        self.block_provider.get_block_hash(block_number)
            .map_err(|e| SystemCallError::BlockHashNotFound(e))
    }
    
    pub fn get_chain_id(&self) -> u64 {
        // WHY: Chain ID prevents replay attacks across networks
        // Like having a unique identifier for each legal jurisdiction
        self.chain_config.chain_id
    }
    
    pub fn get_block_timestamp(&self) -> u64 {
        // WHY: Provides consensus time for the blockchain
        // Like getting official time from atomic clock
        self.timestamp_provider.get_consensus_timestamp()
    }
    
    pub fn get_block_difficulty(&self) -> U256 {
        // WHY: Mining difficulty adjusts to maintain block time
        // Like getting current interest rates from central bank
        self.block_provider.get_current_difficulty()
    }
    
    pub fn get_gas_limit(&self) -> u64 {
        // WHY: Gas limit controls block size and network capacity
        // Like checking the speed limit on current road
        self.block_provider.get_current_gas_limit()
    }
}
```

### 4. Common Precompile Pitfalls and Solutions

#### The "Unbounded Input" Problem

**Wrong:**
```rust
// Dangerous - no input validation
pub fn dangerous_hash_function(input: &[u8]) -> Vec<u8> {
    // No validation - could crash with huge inputs
    let mut hasher = Sha256::new();
    hasher.update(input);
    hasher.finalize().to_vec()
}
```

**Right:**
```rust
// Safe - proper input validation
pub fn safe_hash_function(input: &[u8]) -> Result<Vec<u8>, PrecompileError> {
    // WHY: Prevent DoS attacks with huge inputs
    // Like checking if document is reasonable size before processing
    
    if input.len() > MAX_PRECOMPILE_INPUT_SIZE {
        return Err(PrecompileError::InputTooLarge);
    }
    
    // WHY: Calculate gas cost first
    let gas_cost = 60 + 12 * ((input.len() + 31) / 32);
    if gas_cost > MAX_GAS_PER_PRECOMPILE {
        return Err(PrecompileError::GasCostTooHigh);
    }
    
    let mut hasher = Sha256::new();
    hasher.update(input);
    Ok(hasher.finalize().to_vec())
}
```

#### The "No Error Handling" Problem

**Wrong:**
```rust
// Dangerous - panics on invalid input
pub fn dangerous_signature_recovery(data: &[u8]) -> [u8; 20] {
    // Assumes input is always valid - will panic otherwise
    let hash = &data[0..32];
    let signature = &data[32..96];
    let recovery_id = data[96];
    
    recover_signature(hash, signature, recovery_id).unwrap() // Panic!
}
```

**Right:**
```rust
// Safe - graceful error handling
pub fn safe_signature_recovery(data: &[u8]) -> Result<[u8; 20], PrecompileError> {
    // WHY: Validate input format first
    // Like checking if form is filled out correctly before processing
    
    if data.len() != 128 {
        return Err(PrecompileError::InvalidInputLength);
    }
    
    let hash = &data[0..32];
    let v = &data[32..64];
    let r = &data[64..96];
    let s = &data[96..128];
    
    // WHY: Extract recovery ID safely
    let recovery_id = match v[31] {
        27 => 0,
        28 => 1,
        _ => return Ok([0u8; 20]), // Return zero address for invalid recovery ID
    };
    
    // WHY: Handle signature recovery errors gracefully
    match recover_signature(hash, r, s, recovery_id) {
        Ok(address) => Ok(address),
        Err(_) => Ok([0u8; 20]), // Return zero address on failure
    }
}
```

## Precompile Management System

```rust
use std::collections::HashMap;
use std::sync::Arc;
use revm_primitives::{Address, Bytes, B256, U256};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone)]
pub struct PrecompileManager {
    precompiles: HashMap<Address, Arc<dyn Precompile>>,
    system_contracts: HashMap<Address, Arc<dyn SystemContract>>,
    gas_calculator: Arc<GasCalculator>,
    execution_context: Arc<ExecutionContext>,
}

impl PrecompileManager {
    pub fn new() -> Self {
        let mut precompiles = HashMap::new();
        
        // Standard Ethereum precompiles
        precompiles.insert(Address::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]), Arc::new(EcRecoverPrecompile::new()));
        precompiles.insert(Address::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2]), Arc::new(Sha256Precompile::new()));
        precompiles.insert(Address::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3]), Arc::new(Ripemd160Precompile::new()));
        precompiles.insert(Address::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]), Arc::new(IdentityPrecompile::new()));
        precompiles.insert(Address::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5]), Arc::new(ModExpPrecompile::new()));
        precompiles.insert(Address::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6]), Arc::new(BnAdd256Precompile::new()));
        precompiles.insert(Address::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7]), Arc::new(BnMul256Precompile::new()));
        precompiles.insert(Address::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8]), Arc::new(BnPairing256Precompile::new()));
        precompiles.insert(Address::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9]), Arc::new(Blake2fPrecompile::new()));
        
        // EIP-4844 precompiles
        precompiles.insert(Address::from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10]), Arc::new(KzgPointEvaluationPrecompile::new()));
        
        Self {
            precompiles,
            system_contracts: HashMap::new(),
            gas_calculator: Arc::new(GasCalculator::new()),
            execution_context: Arc::new(ExecutionContext::new()),
        }
    }
    
    pub fn execute_precompile(&self, address: &Address, input: &Bytes, gas_limit: u64) -> Result<PrecompileResult, PrecompileError> {
        if let Some(precompile) = self.precompiles.get(address) {
            // Calculate gas cost
            let gas_cost = precompile.gas_cost(input)?;
            
            // Check gas limit
            if gas_cost > gas_limit {
                return Err(PrecompileError::OutOfGas);
            }
            
            // Execute precompile
            let output = precompile.execute(input, &self.execution_context)?;
            
            Ok(PrecompileResult {
                gas_used: gas_cost,
                output,
                logs: Vec::new(),
                state_changes: Vec::new(),
            })
        } else {
            Err(PrecompileError::PrecompileNotFound)
        }
    }
    
    pub fn is_precompile(&self, address: &Address) -> bool {
        self.precompiles.contains_key(address)
    }
    
    pub fn get_precompile_info(&self, address: &Address) -> Option<PrecompileInfo> {
        self.precompiles.get(address).map(|precompile| {
            PrecompileInfo {
                address: *address,
                name: precompile.name().to_string(),
                description: precompile.description().to_string(),
                gas_formula: precompile.gas_formula().to_string(),
            }
        })
    }
    
    pub fn register_custom_precompile(&mut self, address: Address, precompile: Arc<dyn Precompile>) -> Result<(), PrecompileError> {
        if self.precompiles.contains_key(&address) {
            return Err(PrecompileError::AddressAlreadyExists);
        }
        
        self.precompiles.insert(address, precompile);
        Ok(())
    }
    
    pub fn execute_system_call(&self, call: SystemCall) -> Result<SystemCallResult, SystemCallError> {
        match call {
            SystemCall::GetBlockHash { block_number } => {
                self.get_block_hash(block_number)
            }
            SystemCall::GetBlockNumber => {
                self.get_block_number()
            }
            SystemCall::GetTimestamp => {
                self.get_timestamp()
            }
            SystemCall::GetDifficulty => {
                self.get_difficulty()
            }
            SystemCall::GetGasLimit => {
                self.get_gas_limit()
            }
            SystemCall::GetCoinbase => {
                self.get_coinbase()
            }
            SystemCall::GetBaseFee => {
                self.get_base_fee()
            }
            SystemCall::GetChainId => {
                self.get_chain_id()
            }
        }
    }
    
    fn get_block_hash(&self, block_number: u64) -> Result<SystemCallResult, SystemCallError> {
        let current_block = self.execution_context.get_current_block_number();
        
        // Can only access recent block hashes (last 256 blocks)
        if block_number >= current_block || current_block - block_number > 256 {
            return Ok(SystemCallResult::Hash(B256::ZERO));
        }
        
        let block_hash = self.execution_context.get_block_hash(block_number)?;
        Ok(SystemCallResult::Hash(block_hash))
    }
    
    fn get_block_number(&self) -> Result<SystemCallResult, SystemCallError> {
        let block_number = self.execution_context.get_current_block_number();
        Ok(SystemCallResult::Number(block_number))
    }
    
    fn get_timestamp(&self) -> Result<SystemCallResult, SystemCallError> {
        let timestamp = self.execution_context.get_timestamp();
        Ok(SystemCallResult::Number(timestamp))
    }
    
    fn get_difficulty(&self) -> Result<SystemCallResult, SystemCallError> {
        let difficulty = self.execution_context.get_difficulty();
        Ok(SystemCallResult::U256(difficulty))
    }
    
    fn get_gas_limit(&self) -> Result<SystemCallResult, SystemCallError> {
        let gas_limit = self.execution_context.get_gas_limit();
        Ok(SystemCallResult::Number(gas_limit))
    }
    
    fn get_coinbase(&self) -> Result<SystemCallResult, SystemCallError> {
        let coinbase = self.execution_context.get_coinbase();
        Ok(SystemCallResult::Address(coinbase))
    }
    
    fn get_base_fee(&self) -> Result<SystemCallResult, SystemCallError> {
        let base_fee = self.execution_context.get_base_fee();
        Ok(SystemCallResult::U256(base_fee))
    }
    
    fn get_chain_id(&self) -> Result<SystemCallResult, SystemCallError> {
        let chain_id = self.execution_context.get_chain_id();
        Ok(SystemCallResult::Number(chain_id))
    }
}

pub trait Precompile: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn gas_cost(&self, input: &Bytes) -> Result<u64, PrecompileError>;
    fn gas_formula(&self) -> &str;
    fn execute(&self, input: &Bytes, context: &ExecutionContext) -> Result<Bytes, PrecompileError>;
}

// EcRecover precompile (address 0x01)
pub struct EcRecoverPrecompile;

impl EcRecoverPrecompile {
    pub fn new() -> Self {
        Self
    }
}

impl Precompile for EcRecoverPrecompile {
    fn name(&self) -> &str {
        "ecrecover"
    }
    
    fn description(&self) -> &str {
        "Recovers the public key from a signature"
    }
    
    fn gas_cost(&self, _input: &Bytes) -> Result<u64, PrecompileError> {
        Ok(3000) // Fixed gas cost
    }
    
    fn gas_formula(&self) -> &str {
        "3000"
    }
    
    fn execute(&self, input: &Bytes, _context: &ExecutionContext) -> Result<Bytes, PrecompileError> {
        // Input format: hash(32) + v(32) + r(32) + s(32) = 128 bytes
        if input.len() != 128 {
            return Ok(Bytes::new()); // Return empty on invalid input
        }
        
        let hash = &input[0..32];
        let v = &input[32..64];
        let r = &input[64..96];
        let s = &input[96..128];
        
        // Convert v to recovery ID
        let recovery_id = match v[31] {
            27 => 0,
            28 => 1,
            _ => return Ok(Bytes::new()),
        };
        
        // Perform signature recovery
        match self.recover_signature(hash, r, s, recovery_id) {
            Ok(public_key) => {
                // Return Ethereum address (last 20 bytes of Keccak256 hash of public key)
                let address = self.public_key_to_address(&public_key);
                let mut result = vec![0u8; 32];
                result[12..32].copy_from_slice(&address);
                Ok(Bytes::from(result))
            }
            Err(_) => Ok(Bytes::new()),
        }
    }
    
    fn recover_signature(&self, hash: &[u8], r: &[u8], s: &[u8], recovery_id: u8) -> Result<[u8; 64], PrecompileError> {
        // Simplified signature recovery implementation
        // Real implementation would use secp256k1 library
        Ok([0u8; 64]) // Placeholder
    }
    
    fn public_key_to_address(&self, public_key: &[u8; 64]) -> [u8; 20] {
        // Calculate Keccak256 hash of public key and take last 20 bytes
        use sha3::{Keccak256, Digest};
        let mut hasher = Keccak256::new();
        hasher.update(public_key);
        let hash = hasher.finalize();
        
        let mut address = [0u8; 20];
        address.copy_from_slice(&hash[12..32]);
        address
    }
}

// SHA256 precompile (address 0x02)
pub struct Sha256Precompile;

impl Sha256Precompile {
    pub fn new() -> Self {
        Self
    }
}

impl Precompile for Sha256Precompile {
    fn name(&self) -> &str {
        "sha256"
    }
    
    fn description(&self) -> &str {
        "Computes SHA256 hash"
    }
    
    fn gas_cost(&self, input: &Bytes) -> Result<u64, PrecompileError> {
        // Gas cost: 60 + 12 * (number of 32-byte words)
        let words = (input.len() + 31) / 32;
        Ok(60 + 12 * words as u64)
    }
    
    fn gas_formula(&self) -> &str {
        "60 + 12 * ceil(input_length / 32)"
    }
    
    fn execute(&self, input: &Bytes, _context: &ExecutionContext) -> Result<Bytes, PrecompileError> {
        use sha2::{Sha256, Digest};
        
        let mut hasher = Sha256::new();
        hasher.update(input);
        let result = hasher.finalize();
        
        Ok(Bytes::from(result.as_slice()))
    }
}

// RIPEMD160 precompile (address 0x03)
pub struct Ripemd160Precompile;

impl Ripemd160Precompile {
    pub fn new() -> Self {
        Self
    }
}

impl Precompile for Ripemd160Precompile {
    fn name(&self) -> &str {
        "ripemd160"
    }
    
    fn description(&self) -> &str {
        "Computes RIPEMD160 hash"
    }
    
    fn gas_cost(&self, input: &Bytes) -> Result<u64, PrecompileError> {
        // Gas cost: 600 + 120 * (number of 32-byte words)
        let words = (input.len() + 31) / 32;
        Ok(600 + 120 * words as u64)
    }
    
    fn gas_formula(&self) -> &str {
        "600 + 120 * ceil(input_length / 32)"
    }
    
    fn execute(&self, input: &Bytes, _context: &ExecutionContext) -> Result<Bytes, PrecompileError> {
        use ripemd::{Ripemd160, Digest};
        
        let mut hasher = Ripemd160::new();
        hasher.update(input);
        let result = hasher.finalize();
        
        // RIPEMD160 returns 20 bytes, but we need to pad to 32 bytes
        let mut padded_result = vec![0u8; 32];
        padded_result[12..32].copy_from_slice(&result);
        
        Ok(Bytes::from(padded_result))
    }
}

// Identity precompile (address 0x04)
pub struct IdentityPrecompile;

impl IdentityPrecompile {
    pub fn new() -> Self {
        Self
    }
}

impl Precompile for IdentityPrecompile {
    fn name(&self) -> &str {
        "identity"
    }
    
    fn description(&self) -> &str {
        "Returns the input unchanged"
    }
    
    fn gas_cost(&self, input: &Bytes) -> Result<u64, PrecompileError> {
        // Gas cost: 15 + 3 * (number of 32-byte words)
        let words = (input.len() + 31) / 32;
        Ok(15 + 3 * words as u64)
    }
    
    fn gas_formula(&self) -> &str {
        "15 + 3 * ceil(input_length / 32)"
    }
    
    fn execute(&self, input: &Bytes, _context: &ExecutionContext) -> Result<Bytes, PrecompileError> {
        Ok(input.clone())
    }
}

// ModExp precompile (address 0x05)
pub struct ModExpPrecompile;

impl ModExpPrecompile {
    pub fn new() -> Self {
        Self
    }
}

impl Precompile for ModExpPrecompile {
    fn name(&self) -> &str {
        "modexp"
    }
    
    fn description(&self) -> &str {
        "Computes modular exponentiation"
    }
    
    fn gas_cost(&self, input: &Bytes) -> Result<u64, PrecompileError> {
        if input.len() < 96 {
            return Ok(0);
        }
        
        let base_len = U256::from_big_endian(&input[0..32]).as_u64() as usize;
        let exp_len = U256::from_big_endian(&input[32..64]).as_u64() as usize;
        let mod_len = U256::from_big_endian(&input[64..96]).as_u64() as usize;
        
        // Simplified gas calculation
        let complexity = std::cmp::max(base_len, mod_len);
        Ok((complexity * complexity / 20) as u64)
    }
    
    fn gas_formula(&self) -> &str {
        "complexity^2 / 20, where complexity = max(base_length, mod_length)"
    }
    
    fn execute(&self, input: &Bytes, _context: &ExecutionContext) -> Result<Bytes, PrecompileError> {
        if input.len() < 96 {
            return Ok(Bytes::new());
        }
        
        let base_len = U256::from_big_endian(&input[0..32]).as_u64() as usize;
        let exp_len = U256::from_big_endian(&input[32..64]).as_u64() as usize;
        let mod_len = U256::from_big_endian(&input[64..96]).as_u64() as usize;
        
        if input.len() < 96 + base_len + exp_len + mod_len {
            return Ok(Bytes::new());
        }
        
        let base = &input[96..96 + base_len];
        let exp = &input[96 + base_len..96 + base_len + exp_len];
        let modulus = &input[96 + base_len + exp_len..96 + base_len + exp_len + mod_len];
        
        // Perform modular exponentiation
        let result = self.mod_exp(base, exp, modulus)?;
        
        Ok(Bytes::from(result))
    }
    
    fn mod_exp(&self, base: &[u8], exp: &[u8], modulus: &[u8]) -> Result<Vec<u8>, PrecompileError> {
        // Simplified modular exponentiation
        // Real implementation would use optimized big integer arithmetic
        Ok(vec![0u8; modulus.len()])
    }
}

// BN256 Add precompile (address 0x06)
pub struct BnAdd256Precompile;

impl BnAdd256Precompile {
    pub fn new() -> Self {
        Self
    }
}

impl Precompile for BnAdd256Precompile {
    fn name(&self) -> &str {
        "bn256Add"
    }
    
    fn description(&self) -> &str {
        "Adds two points on the BN256 elliptic curve"
    }
    
    fn gas_cost(&self, _input: &Bytes) -> Result<u64, PrecompileError> {
        Ok(150) // Fixed gas cost
    }
    
    fn gas_formula(&self) -> &str {
        "150"
    }
    
    fn execute(&self, input: &Bytes, _context: &ExecutionContext) -> Result<Bytes, PrecompileError> {
        if input.len() != 128 {
            return Ok(Bytes::new());
        }
        
        // Extract points
        let x1 = &input[0..32];
        let y1 = &input[32..64];
        let x2 = &input[64..96];
        let y2 = &input[96..128];
        
        // Perform elliptic curve addition
        let (x3, y3) = self.bn256_add(x1, y1, x2, y2)?;
        
        let mut result = Vec::new();
        result.extend_from_slice(&x3);
        result.extend_from_slice(&y3);
        
        Ok(Bytes::from(result))
    }
    
    fn bn256_add(&self, x1: &[u8], y1: &[u8], x2: &[u8], y2: &[u8]) -> Result<([u8; 32], [u8; 32]), PrecompileError> {
        // Simplified elliptic curve addition
        // Real implementation would use optimized elliptic curve library
        Ok(([0u8; 32], [0u8; 32]))
    }
}

// BN256 Scalar Multiplication precompile (address 0x07)
pub struct BnMul256Precompile;

impl BnMul256Precompile {
    pub fn new() -> Self {
        Self
    }
}

impl Precompile for BnMul256Precompile {
    fn name(&self) -> &str {
        "bn256ScalarMul"
    }
    
    fn description(&self) -> &str {
        "Multiplies a point by a scalar on the BN256 elliptic curve"
    }
    
    fn gas_cost(&self, _input: &Bytes) -> Result<u64, PrecompileError> {
        Ok(6000) // Fixed gas cost
    }
    
    fn gas_formula(&self) -> &str {
        "6000"
    }
    
    fn execute(&self, input: &Bytes, _context: &ExecutionContext) -> Result<Bytes, PrecompileError> {
        if input.len() != 96 {
            return Ok(Bytes::new());
        }
        
        let x = &input[0..32];
        let y = &input[32..64];
        let scalar = &input[64..96];
        
        // Perform scalar multiplication
        let (x_result, y_result) = self.bn256_scalar_mul(x, y, scalar)?;
        
        let mut result = Vec::new();
        result.extend_from_slice(&x_result);
        result.extend_from_slice(&y_result);
        
        Ok(Bytes::from(result))
    }
    
    fn bn256_scalar_mul(&self, x: &[u8], y: &[u8], scalar: &[u8]) -> Result<([u8; 32], [u8; 32]), PrecompileError> {
        // Simplified scalar multiplication
        // Real implementation would use optimized elliptic curve library
        Ok(([0u8; 32], [0u8; 32]))
    }
}

// BN256 Pairing precompile (address 0x08)
pub struct BnPairing256Precompile;

impl BnPairing256Precompile {
    pub fn new() -> Self {
        Self
    }
}

impl Precompile for BnPairing256Precompile {
    fn name(&self) -> &str {
        "bn256Pairing"
    }
    
    fn description(&self) -> &str {
        "Performs pairing check on BN256 elliptic curve"
    }
    
    fn gas_cost(&self, input: &Bytes) -> Result<u64, PrecompileError> {
        // Gas cost: 45000 + 34000 * (number of pairs)
        let pairs = input.len() / 192;
        Ok(45000 + 34000 * pairs as u64)
    }
    
    fn gas_formula(&self) -> &str {
        "45000 + 34000 * (input_length / 192)"
    }
    
    fn execute(&self, input: &Bytes, _context: &ExecutionContext) -> Result<Bytes, PrecompileError> {
        if input.len() % 192 != 0 {
            return Ok(Bytes::new());
        }
        
        let pairs = input.len() / 192;
        
        // Perform pairing check
        let pairing_result = self.bn256_pairing(input, pairs)?;
        
        // Return 1 if pairing is valid, 0 otherwise
        let result = if pairing_result { 1u8 } else { 0u8 };
        let mut output = vec![0u8; 32];
        output[31] = result;
        
        Ok(Bytes::from(output))
    }
    
    fn bn256_pairing(&self, input: &Bytes, pairs: usize) -> Result<bool, PrecompileError> {
        // Simplified pairing check
        // Real implementation would use optimized pairing library
        Ok(true)
    }
}

// Blake2f precompile (address 0x09)
pub struct Blake2fPrecompile;

impl Blake2fPrecompile {
    pub fn new() -> Self {
        Self
    }
}

impl Precompile for Blake2fPrecompile {
    fn name(&self) -> &str {
        "blake2f"
    }
    
    fn description(&self) -> &str {
        "Computes Blake2b F function"
    }
    
    fn gas_cost(&self, input: &Bytes) -> Result<u64, PrecompileError> {
        if input.len() != 213 {
            return Err(PrecompileError::InvalidInputLength);
        }
        
        // Extract rounds from input
        let rounds = u32::from_be_bytes([input[0], input[1], input[2], input[3]]);
        Ok(rounds as u64)
    }
    
    fn gas_formula(&self) -> &str {
        "rounds (first 4 bytes of input)"
    }
    
    fn execute(&self, input: &Bytes, _context: &ExecutionContext) -> Result<Bytes, PrecompileError> {
        if input.len() != 213 {
            return Err(PrecompileError::InvalidInputLength);
        }
        
        // Extract parameters
        let rounds = u32::from_be_bytes([input[0], input[1], input[2], input[3]]);
        let h = &input[4..68];     // 64 bytes
        let m = &input[68..196];   // 128 bytes
        let t = &input[196..212];  // 16 bytes
        let f = input[212];        // 1 byte
        
        // Perform Blake2f compression
        let result = self.blake2f_compress(rounds, h, m, t, f)?;
        
        Ok(Bytes::from(result))
    }
    
    fn blake2f_compress(&self, rounds: u32, h: &[u8], m: &[u8], t: &[u8], f: u8) -> Result<Vec<u8>, PrecompileError> {
        // Simplified Blake2f compression
        // Real implementation would use optimized Blake2b library
        Ok(vec![0u8; 64])
    }
}

// KZG Point Evaluation precompile (address 0x0A) - EIP-4844
pub struct KzgPointEvaluationPrecompile;

impl KzgPointEvaluationPrecompile {
    pub fn new() -> Self {
        Self
    }
}

impl Precompile for KzgPointEvaluationPrecompile {
    fn name(&self) -> &str {
        "kzgPointEvaluation"
    }
    
    fn description(&self) -> &str {
        "Verifies KZG proof for point evaluation"
    }
    
    fn gas_cost(&self, _input: &Bytes) -> Result<u64, PrecompileError> {
        Ok(50000) // Fixed gas cost
    }
    
    fn gas_formula(&self) -> &str {
        "50000"
    }
    
    fn execute(&self, input: &Bytes, _context: &ExecutionContext) -> Result<Bytes, PrecompileError> {
        if input.len() != 192 {
            return Err(PrecompileError::InvalidInputLength);
        }
        
        let versioned_hash = &input[0..32];
        let z = &input[32..64];
        let y = &input[64..96];
        let commitment = &input[96..144];
        let proof = &input[144..192];
        
        // Verify KZG proof
        let verification_result = self.verify_kzg_proof(versioned_hash, z, y, commitment, proof)?;
        
        // Return success indicator
        let result = if verification_result { 1u8 } else { 0u8 };
        let mut output = vec![0u8; 32];
        output[31] = result;
        
        Ok(Bytes::from(output))
    }
    
    fn verify_kzg_proof(&self, versioned_hash: &[u8], z: &[u8], y: &[u8], commitment: &[u8], proof: &[u8]) -> Result<bool, PrecompileError> {
        // Simplified KZG verification
        // Real implementation would use c-kzg library
        Ok(true)
    }
}

// System call types
#[derive(Debug, Clone)]
pub enum SystemCall {
    GetBlockHash { block_number: u64 },
    GetBlockNumber,
    GetTimestamp,
    GetDifficulty,
    GetGasLimit,
    GetCoinbase,
    GetBaseFee,
    GetChainId,
}

#[derive(Debug, Clone)]
pub enum SystemCallResult {
    Hash(B256),
    Address(Address),
    Number(u64),
    U256(U256),
}

// Gas calculator
pub struct GasCalculator;

impl GasCalculator {
    pub fn new() -> Self {
        Self
    }
    
    pub fn calculate_precompile_gas(&self, address: &Address, input: &Bytes) -> Result<u64, PrecompileError> {
        // Gas calculation logic for precompiles
        match address.as_bytes()[19] {
            1 => Ok(3000),           // ecrecover
            2 => {                   // sha256
                let words = (input.len() + 31) / 32;
                Ok(60 + 12 * words as u64)
            }
            3 => {                   // ripemd160
                let words = (input.len() + 31) / 32;
                Ok(600 + 120 * words as u64)
            }
            4 => {                   // identity
                let words = (input.len() + 31) / 32;
                Ok(15 + 3 * words as u64)
            }
            5 => {                   // modexp
                if input.len() < 96 {
                    return Ok(0);
                }
                let base_len = U256::from_big_endian(&input[0..32]).as_u64() as usize;
                let mod_len = U256::from_big_endian(&input[64..96]).as_u64() as usize;
                let complexity = std::cmp::max(base_len, mod_len);
                Ok((complexity * complexity / 20) as u64)
            }
            6 => Ok(150),            // bn256Add
            7 => Ok(6000),           // bn256ScalarMul
            8 => {                   // bn256Pairing
                let pairs = input.len() / 192;
                Ok(45000 + 34000 * pairs as u64)
            }
            9 => {                   // blake2f
                if input.len() != 213 {
                    return Err(PrecompileError::InvalidInputLength);
                }
                let rounds = u32::from_be_bytes([input[0], input[1], input[2], input[3]]);
                Ok(rounds as u64)
            }
            10 => Ok(50000),         // kzgPointEvaluation
            _ => Err(PrecompileError::PrecompileNotFound),
        }
    }
}

// Execution context
pub struct ExecutionContext {
    block_number: u64,
    timestamp: u64,
    difficulty: U256,
    gas_limit: u64,
    coinbase: Address,
    base_fee: U256,
    chain_id: u64,
}

impl ExecutionContext {
    pub fn new() -> Self {
        Self {
            block_number: 0,
            timestamp: 0,
            difficulty: U256::ZERO,
            gas_limit: 0,
            coinbase: Address::ZERO,
            base_fee: U256::ZERO,
            chain_id: 1,
        }
    }
    
    pub fn get_current_block_number(&self) -> u64 {
        self.block_number
    }
    
    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    
    pub fn get_difficulty(&self) -> U256 {
        self.difficulty
    }
    
    pub fn get_gas_limit(&self) -> u64 {
        self.gas_limit
    }
    
    pub fn get_coinbase(&self) -> Address {
        self.coinbase
    }
    
    pub fn get_base_fee(&self) -> U256 {
        self.base_fee
    }
    
    pub fn get_chain_id(&self) -> u64 {
        self.chain_id
    }
    
    pub fn get_block_hash(&self, block_number: u64) -> Result<B256, SystemCallError> {
        // Implementation would retrieve block hash from storage
        Ok(B256::ZERO)
    }
}

// Result types
#[derive(Debug, Clone)]
pub struct PrecompileResult {
    pub gas_used: u64,
    pub output: Bytes,
    pub logs: Vec<Log>,
    pub state_changes: Vec<StateChange>,
}

#[derive(Debug, Clone)]
pub struct PrecompileInfo {
    pub address: Address,
    pub name: String,
    pub description: String,
    pub gas_formula: String,
}

#[derive(Debug, Clone)]
pub struct Log {
    pub address: Address,
    pub topics: Vec<B256>,
    pub data: Bytes,
}

#[derive(Debug, Clone)]
pub struct StateChange {
    pub address: Address,
    pub key: B256,
    pub value: U256,
}

pub trait SystemContract: Send + Sync {
    fn name(&self) -> &str;
    fn address(&self) -> Address;
    fn execute(&self, input: &Bytes, context: &ExecutionContext) -> Result<Bytes, SystemCallError>;
}

// Error types
#[derive(Debug)]
pub enum PrecompileError {
    PrecompileNotFound,
    InvalidInputLength,
    InvalidInput,
    OutOfGas,
    AddressAlreadyExists,
    ExecutionFailed(String),
}

impl std::fmt::Display for PrecompileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PrecompileError::PrecompileNotFound => write!(f, "Precompile not found"),
            PrecompileError::InvalidInputLength => write!(f, "Invalid input length"),
            PrecompileError::InvalidInput => write!(f, "Invalid input"),
            PrecompileError::OutOfGas => write!(f, "Out of gas"),
            PrecompileError::AddressAlreadyExists => write!(f, "Address already exists"),
            PrecompileError::ExecutionFailed(msg) => write!(f, "Execution failed: {}", msg),
        }
    }
}

impl std::error::Error for PrecompileError {}

#[derive(Debug)]
pub enum SystemCallError {
    InvalidBlockNumber,
    StateAccessFailed,
    ContextNotAvailable,
}

impl std::fmt::Display for SystemCallError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SystemCallError::InvalidBlockNumber => write!(f, "Invalid block number"),
            SystemCallError::StateAccessFailed => write!(f, "State access failed"),
            SystemCallError::ContextNotAvailable => write!(f, "Context not available"),
        }
    }
}

impl std::error::Error for SystemCallError {}
```

## Summary
System calls and precompiles provide efficient implementations of common cryptographic operations and system access. Understanding these components is crucial for optimizing smart contract execution and implementing custom blockchain features.

## Assignments
1. **Precompile System**: Build comprehensive precompile management with gas calculation
2. **Custom Precompiles**: Implement domain-specific precompiled contracts
3. **System Calls**: Create system call interface for blockchain state access

## Questions to Ponder
1. How do you ensure precompile implementations are secure and efficient?
2. What trade-offs exist between precompiles and EVM opcodes?
3. How do you handle gas calculation for complex precompiles?
4. What precompiles would be most beneficial for specific use cases?
5. How do you maintain backward compatibility when updating precompiles?