# Lesson 38: Engine API and Consensus Layer

*"If you want to learn about nature, to appreciate nature, it is necessary to understand the language that she speaks in." - Richard Feynman*

## Files with Inline Comments for This Lesson
- `crates/rpc/rpc-engine-api/src/engine_api.rs` - Engine API RPC implementation
- `crates/engine/tree/src/engine.rs` - Engine handler orchestration
- `crates/engine/primitives/src/forkchoice.rs` - Fork choice state tracking
- `crates/rpc/rpc-engine-api/src/capabilities.rs` - Engine API capabilities
- `crates/engine/tree/src/tree/mod.rs` - Tree integration with engine API

## The Engine API Bridge

The Engine API is the critical interface between Ethereum's consensus layer (beacon chain) and execution layer (Reth). After The Merge, these two layers work together: consensus decides what to build, execution builds it.

```
Engine API Architecture:
┌─────────────────────────────────────────────────┐
│            Consensus Layer (Beacon)             │
│  - Validators                                   │
│  - Fork choice                                  │
│  - Finalization                                 │
└─────────────────┬───────────────────────────────┘
                  │ Engine API (JSON-RPC)
                  │
         ┌────────┴────────┬──────────────┐
         ▼                 ▼              ▼
   newPayload     forkchoiceUpdated    getPayload
         │                 │              │
┌────────┴─────────────────┴──────────────┴───────┐
│           Execution Layer (Reth)                │
│  - Block execution                              │
│  - State management                             │
│  - Transaction pool                             │
└─────────────────────────────────────────────────┘
```

## Core Engine API Methods

### 1. newPayload - Execute a Block

```rust
/// Engine API implementation
/// Located in: crates/rpc/rpc-engine-api/src/engine_api.rs

use alloy_rpc_types_engine::{
    ExecutionPayloadV3, ForkchoiceState, PayloadStatus, PayloadStatusEnum,
};
use reth_payload_primitives::{ExecutionPayload, PayloadBuilderAttributes};

impl<Provider, PayloadT, Pool, Validator, ChainSpec> EngineApi<...> {
    /// Process new payload from consensus layer
    /// LESSON 38: newPayload - Block Execution Request
    /// The CL sends us a complete block to execute. We must:
    /// 1. Validate the block structure
    /// 2. Execute all transactions
    /// 3. Verify the state root
    /// 4. Return status (VALID/INVALID/SYNCING)
    pub async fn new_payload_v3(
        &self,
        payload: ExecutionPayloadV3,
        expected_blob_versioned_hashes: Vec<B256>,
        parent_beacon_block_root: B256,
    ) -> EngineApiResult<PayloadStatus> {
        // Start timing for metrics
        let start = Instant::now();
        
        // Validate payload fields
        // LESSON 38: Payload Validation
        // Check timestamp, extra data size, base fee, etc.
        if let Err(err) = validate_payload_timestamp(&payload) {
            return Ok(PayloadStatus::invalid_with_err(err));
        }
        
        // Check blob versioned hashes for 4844 transactions
        if let Err(err) = validate_blob_versioned_hashes(
            &payload,
            &expected_blob_versioned_hashes,
        ) {
            return Ok(PayloadStatus::invalid_with_err(err));
        }
        
        // Convert to internal payload type
        let payload = match ExecutionPayload::try_from(payload) {
            Ok(p) => p,
            Err(e) => return Ok(PayloadStatus::invalid_with_err(e)),
        };
        
        // Send to engine for processing
        let (tx, rx) = oneshot::channel();
        let msg = BeaconEngineMessage::NewPayload {
            payload: payload.clone(),
            cancun_fields: Some(CancunPayloadFields {
                parent_beacon_block_root,
                versioned_hashes: expected_blob_versioned_hashes,
            }),
            tx,
        };
        
        self.inner.beacon_consensus.send(msg)?;
        
        // Wait for execution result
        let result = rx.await??;
        
        // Record metrics
        self.inner.metrics.new_payload_execution_time.record(start.elapsed());
        
        match result {
            PayloadStatus::Valid => {
                info!(
                    target: "engine::api",
                    block_hash = ?payload.block_hash(),
                    block_number = payload.block_number(),
                    "Executed valid payload"
                );
            }
            PayloadStatus::Invalid { .. } => {
                warn!(
                    target: "engine::api",
                    block_hash = ?payload.block_hash(),
                    "Payload validation failed"
                );
            }
            _ => {}
        }
        
        Ok(result)
    }
}

/// Payload validation logic
fn validate_payload_timestamp(payload: &ExecutionPayload) -> Result<(), PayloadError> {
    // Timestamp must be greater than parent
    if payload.timestamp() <= payload.parent_timestamp() {
        return Err(PayloadError::InvalidTimestamp);
    }
    
    // Check timestamp is not too far in future (allows some clock drift)
    let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
    if payload.timestamp() > now + ALLOWED_FUTURE_BLOCK_TIME {
        return Err(PayloadError::TimestampTooFarInFuture);
    }
    
    Ok(())
}
```

### 2. forkchoiceUpdated - Update Chain Head

```rust
/// Fork choice update handling
impl<Provider, PayloadT, Pool, Validator, ChainSpec> EngineApi<...> {
    /// Update fork choice state
    /// LESSON 38: forkchoiceUpdated - Consensus Instructions
    /// The CL tells us:
    /// - Which block is the new head
    /// - Which block is safe (unlikely to reorg)
    /// - Which block is finalized (will never reorg)
    /// - Optional: attributes to build a new block
    pub async fn fork_choice_updated_v3(
        &self,
        state: ForkchoiceState,
        payload_attributes: Option<PayloadAttributesV3>,
    ) -> EngineApiResult<ForkchoiceUpdated> {
        // Validate fork choice state
        if !is_valid_fork_choice_state(&state) {
            return Ok(ForkchoiceUpdated::invalid_state());
        }
        
        // Convert attributes if building new block
        let attributes = if let Some(attrs) = payload_attributes {
            // LESSON 38: Payload Building Trigger
            // If attributes are provided, CL wants us to build a block
            Some(PayloadBuilderAttributes {
                timestamp: attrs.timestamp,
                prev_randao: attrs.prev_randao,
                suggested_fee_recipient: attrs.suggested_fee_recipient,
                withdrawals: attrs.withdrawals.clone(),
                parent_beacon_block_root: Some(attrs.parent_beacon_block_root),
            })
        } else {
            None
        };
        
        // Send fork choice update to engine
        let (tx, rx) = oneshot::channel();
        let msg = BeaconEngineMessage::ForkchoiceUpdated {
            state,
            payload_attrs: attributes.map(|attrs| PayloadT::BuilderAttributes::from(attrs)),
            tx,
        };
        
        self.inner.beacon_consensus.send(msg)?;
        
        // Wait for response
        let response = rx.await??;
        
        // Log state transition
        debug!(
            target: "engine::api",
            head = ?state.head_block_hash,
            safe = ?state.safe_block_hash,
            finalized = ?state.finalized_block_hash,
            building = attributes.is_some(),
            "Fork choice updated"
        );
        
        Ok(response)
    }
}

/// Fork choice validation
fn is_valid_fork_choice_state(state: &ForkchoiceState) -> bool {
    // Check hash relationships
    // finalized <= safe <= head (in terms of block numbers)
    
    // Zero hashes have special meaning
    if state.head_block_hash.is_zero() {
        return false; // Head must always be set
    }
    
    // Safe can be zero (not set) or must be ancestor of head
    if !state.safe_block_hash.is_zero() && 
       !is_ancestor(state.safe_block_hash, state.head_block_hash) {
        return false;
    }
    
    // Finalized can be zero or must be ancestor of safe (or head if safe is zero)
    if !state.finalized_block_hash.is_zero() {
        let reference = if state.safe_block_hash.is_zero() {
            state.head_block_hash
        } else {
            state.safe_block_hash
        };
        if !is_ancestor(state.finalized_block_hash, reference) {
            return false;
        }
    }
    
    true
}
```

### 3. getPayload - Retrieve Built Block

```rust
/// Get payload for block production
impl<Provider, PayloadT, Pool, Validator, ChainSpec> EngineApi<...> {
    /// Get execution payload by ID
    /// LESSON 38: getPayload - Block Retrieval
    /// After we build a block (triggered by forkchoiceUpdated with attrs),
    /// the CL retrieves it to propose to the network
    pub async fn get_payload_v3(
        &self,
        payload_id: PayloadId,
    ) -> EngineApiResult<ExecutionPayloadEnvelope> {
        // Look up payload in store
        let payload = self.inner.payload_store.get(payload_id).await?;
        
        // Ensure payload is ready
        let best_payload = match payload.best_payload() {
            Some(p) => p,
            None => {
                warn!(
                    target: "engine::api",
                    ?payload_id,
                    "Payload not ready yet"
                );
                return Err(EngineApiError::UnknownPayload);
            }
        };
        
        // Calculate value (fees that would go to validator)
        let block_value = calculate_block_value(&best_payload);
        
        // Prepare blob bundle for 4844
        let blob_bundle = if self.inner.chain_spec.is_cancun_active_at(best_payload.timestamp()) {
            prepare_blob_bundle(&best_payload)?
        } else {
            None
        };
        
        // Return complete payload envelope
        Ok(ExecutionPayloadEnvelope {
            execution_payload: best_payload.into(),
            block_value,
            blobs_bundle: blob_bundle,
            should_override_builder: false,
        })
    }
}

/// Calculate total value of a block
fn calculate_block_value(payload: &ExecutionPayload) -> U256 {
    // Priority fees (tips) that go to validator
    let mut value = U256::ZERO;
    
    for tx in &payload.transactions {
        let tip = tx.effective_gas_tip(payload.base_fee_per_gas());
        value += U256::from(tip) * U256::from(tx.gas_used());
    }
    
    value
}
```

## Fork Choice State Tracking

```rust
/// Fork choice state tracking
/// Located in: crates/engine/primitives/src/forkchoice.rs

use alloy_primitives::B256;
use alloy_rpc_types_engine::{ForkchoiceState, PayloadStatusEnum};

/// Tracks fork choice states from consensus layer
/// LESSON 38: Forkchoice State Management
/// We track multiple states:
/// - Latest: Most recent FCU (might be invalid)
/// - Valid: Last FCU we successfully processed
/// - Syncing: FCU we're trying to sync to
#[derive(Debug, Clone, Default)]
pub struct ForkchoiceStateTracker {
    /// The latest forkchoice state received
    latest: Option<ReceivedForkchoiceState>,
    /// FCU we're syncing toward
    last_syncing: Option<ForkchoiceState>,
    /// Last valid FCU we processed
    last_valid: Option<ForkchoiceState>,
}

impl ForkchoiceStateTracker {
    /// Update with new fork choice state
    pub fn set_latest(&mut self, state: ForkchoiceState, status: ForkchoiceStatus) {
        if status.is_valid() {
            // We successfully processed this FCU
            self.set_valid(state);
        } else if status.is_syncing() {
            // We need to sync to reach this state
            self.last_syncing = Some(state);
        }
        
        self.latest = Some(ReceivedForkchoiceState { state, status });
    }
    
    /// Check if we need to download blocks
    pub fn sync_target_state(&self) -> Option<ForkchoiceState> {
        // If we're syncing, return the target
        if let Some(syncing) = &self.last_syncing {
            return Some(*syncing);
        }
        
        // If latest is ahead of valid, we might need to sync
        if let (Some(latest), Some(valid)) = (&self.latest, &self.last_valid) {
            if latest.state.head_block_hash != valid.head_block_hash {
                return Some(latest.state);
            }
        }
        
        None
    }
    
    /// Get the finalized block info
    pub fn last_valid_finalized(&self) -> Option<B256> {
        self.last_valid
            .filter(|state| !state.finalized_block_hash.is_zero())
            .map(|state| state.finalized_block_hash)
    }
}

#[derive(Debug, Clone, Copy)]
pub struct ReceivedForkchoiceState {
    pub state: ForkchoiceState,
    pub status: ForkchoiceStatus,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ForkchoiceStatus {
    Valid,
    Invalid,
    Syncing,
}
```

## Engine Capabilities

```rust
/// Engine capabilities negotiation
/// Located in: crates/rpc/rpc-engine-api/src/capabilities.rs

/// Advertise what this execution client supports
#[derive(Debug, Clone)]
pub struct EngineCapabilities {
    /// Supported engine API methods
    pub capabilities: Vec<String>,
}

impl EngineCapabilities {
    /// Create capabilities for current fork
    pub fn new(chain_spec: &ChainSpec) -> Self {
        let mut capabilities = vec![
            "engine_newPayloadV1",
            "engine_newPayloadV2", 
            "engine_forkchoiceUpdatedV1",
            "engine_forkchoiceUpdatedV2",
            "engine_getPayloadV1",
            "engine_getPayloadV2",
            "engine_exchangeTransitionConfigurationV1",
        ];
        
        // Add Cancun capabilities
        if chain_spec.is_cancun_active_at_head() {
            capabilities.extend_from_slice(&[
                "engine_newPayloadV3",
                "engine_forkchoiceUpdatedV3",
                "engine_getPayloadV3",
                "engine_getBlobsV1",
            ]);
        }
        
        // Add Prague capabilities
        if chain_spec.is_prague_active_at_head() {
            capabilities.extend_from_slice(&[
                "engine_newPayloadV4",
                "engine_getPayloadV4",
            ]);
        }
        
        Self {
            capabilities: capabilities.into_iter().map(String::from).collect(),
        }
    }
}
```

## Assignment 1: Engine Message Router

Create a message router that handles engine API requests with priority queuing.

```rust
/// Route and prioritize engine API messages
pub struct EngineMessageRouter {
    high_priority: VecDeque<EngineMessage>,
    normal_priority: VecDeque<EngineMessage>,
    message_handlers: HashMap<MessageType, Box<dyn MessageHandler>>,
}

#[derive(Debug, Clone)]
pub enum EngineMessage {
    NewPayload { id: u64, payload: ExecutionPayload },
    ForkchoiceUpdate { id: u64, state: ForkchoiceState },
    GetPayload { id: u64, payload_id: PayloadId },
}

#[derive(Debug, PartialEq, Eq, Hash)]
pub enum MessageType {
    NewPayload,
    ForkchoiceUpdate,
    GetPayload,
}

pub trait MessageHandler: Send + Sync {
    fn handle(&self, msg: EngineMessage) -> Result<EngineResponse, EngineError>;
    fn priority(&self, msg: &EngineMessage) -> Priority;
}

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Priority {
    High,
    Normal,
    Low,
}

impl EngineMessageRouter {
    pub fn new() -> Self {
        // Your implementation here
        todo!()
    }
    
    /// Register a handler for a message type
    pub fn register_handler(&mut self, msg_type: MessageType, handler: Box<dyn MessageHandler>) {
        // Your implementation here
        todo!()
    }
    
    /// Queue a message for processing
    pub fn queue_message(&mut self, msg: EngineMessage) -> Result<(), RouterError> {
        // Your implementation here
        todo!()
    }
    
    /// Process next message based on priority
    pub fn process_next(&mut self) -> Option<Result<EngineResponse, EngineError>> {
        // Your implementation here
        todo!()
    }
}
```

## Assignment 2: Fork Choice Conflict Detector

Implement a system to detect and analyze conflicting fork choice updates.

```rust
/// Detect conflicts and anomalies in fork choice updates
pub struct ForkChoiceConflictDetector {
    history: VecDeque<TimestampedFCU>,
    max_history: usize,
    known_blocks: HashMap<B256, BlockInfo>,
}

#[derive(Debug, Clone)]
pub struct TimestampedFCU {
    pub timestamp: Instant,
    pub state: ForkchoiceState,
    pub attributes: Option<PayloadAttributes>,
}

#[derive(Debug, Clone)]
pub struct BlockInfo {
    pub number: u64,
    pub parent: B256,
    pub received_at: Instant,
}

#[derive(Debug)]
pub enum ForkChoiceConflict {
    /// Head moved backward
    HeadRegression { from: B256, to: B256, depth: u64 },
    /// Safe block moved backward  
    SafeRegression { from: B256, to: B256 },
    /// Finalized block changed (should never happen)
    FinalizedChanged { from: B256, to: B256 },
    /// Rapid fork choice changes
    UnstableForkChoice { changes: usize, duration: Duration },
}

impl ForkChoiceConflictDetector {
    pub fn new(max_history: usize) -> Self {
        // Your implementation here
        todo!()
    }
    
    /// Record a new fork choice update
    pub fn record_fcu(&mut self, state: ForkchoiceState, attrs: Option<PayloadAttributes>) {
        // Your implementation here
        todo!()
    }
    
    /// Detect conflicts in recent FCUs
    pub fn detect_conflicts(&self) -> Vec<ForkChoiceConflict> {
        // Your implementation here
        todo!()
    }
    
    /// Analyze fork choice stability
    pub fn analyze_stability(&self, window: Duration) -> StabilityReport {
        // Your implementation here
        todo!()
    }
}

#[derive(Debug)]
pub struct StabilityReport {
    pub total_updates: usize,
    pub head_changes: usize,
    pub average_block_time: Duration,
    pub reorg_count: usize,
    pub max_reorg_depth: u64,
}
```

## Assignment 3: Payload Validation Pipeline

Design a comprehensive payload validation pipeline with caching.

```rust
/// Validate payloads with multiple validation stages
pub struct PayloadValidationPipeline {
    validators: Vec<Box<dyn PayloadValidator>>,
    cache: PayloadValidationCache,
    metrics: ValidationMetrics,
}

pub trait PayloadValidator: Send + Sync {
    fn name(&self) -> &str;
    fn validate(&self, payload: &ExecutionPayload) -> Result<(), ValidationError>;
    fn can_validate(&self, payload: &ExecutionPayload) -> bool;
}

pub struct PayloadValidationCache {
    valid_hashes: LruCache<B256, CachedValidation>,
    invalid_hashes: LruCache<B256, ValidationError>,
}

#[derive(Clone)]
pub struct CachedValidation {
    pub block_hash: B256,
    pub timestamp: Instant,
    pub validators_passed: Vec<String>,
}

impl PayloadValidationPipeline {
    pub fn new() -> Self {
        // Your implementation here
        todo!()
    }
    
    /// Add a validator to the pipeline
    pub fn add_validator(&mut self, validator: Box<dyn PayloadValidator>) {
        // Your implementation here
        todo!()
    }
    
    /// Validate a payload through all stages
    pub async fn validate(&mut self, payload: ExecutionPayload) -> ValidationResult {
        // Your implementation here
        todo!()
    }
    
    /// Get validation metrics
    pub fn metrics(&self) -> &ValidationMetrics {
        // Your implementation here
        todo!()
    }
}

#[derive(Debug)]
pub struct ValidationResult {
    pub status: PayloadStatus,
    pub stages_completed: Vec<String>,
    pub cached: bool,
    pub duration: Duration,
}

#[derive(Debug, Default)]
pub struct ValidationMetrics {
    pub total_validations: u64,
    pub cache_hits: u64,
    pub validation_errors: HashMap<String, u64>,
    pub average_duration: Duration,
}
```

## Assignment Answers

### Assignment 1: Engine Message Router

```rust
use std::collections::{HashMap, VecDeque};

/// Route and prioritize engine API messages
pub struct EngineMessageRouter {
    high_priority: VecDeque<EngineMessage>,
    normal_priority: VecDeque<EngineMessage>,
    message_handlers: HashMap<MessageType, Box<dyn MessageHandler>>,
    message_count: HashMap<MessageType, usize>,
}

#[derive(Debug, Clone)]
pub enum EngineMessage {
    NewPayload { id: u64, payload: ExecutionPayload },
    ForkchoiceUpdate { id: u64, state: ForkchoiceState },
    GetPayload { id: u64, payload_id: PayloadId },
}

impl EngineMessage {
    fn message_type(&self) -> MessageType {
        match self {
            Self::NewPayload { .. } => MessageType::NewPayload,
            Self::ForkchoiceUpdate { .. } => MessageType::ForkchoiceUpdate,
            Self::GetPayload { .. } => MessageType::GetPayload,
        }
    }
    
    fn id(&self) -> u64 {
        match self {
            Self::NewPayload { id, .. } |
            Self::ForkchoiceUpdate { id, .. } |
            Self::GetPayload { id, .. } => *id,
        }
    }
}

#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum MessageType {
    NewPayload,
    ForkchoiceUpdate,
    GetPayload,
}

pub trait MessageHandler: Send + Sync {
    fn handle(&self, msg: EngineMessage) -> Result<EngineResponse, EngineError>;
    fn priority(&self, msg: &EngineMessage) -> Priority;
}

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
pub enum Priority {
    High,
    Normal,
    Low,
}

#[derive(Debug)]
pub enum EngineResponse {
    PayloadStatus(PayloadStatus),
    ForkchoiceUpdated(ForkchoiceUpdated),
    ExecutionPayload(ExecutionPayload),
}

#[derive(Debug)]
pub enum EngineError {
    HandlerNotFound(MessageType),
    ProcessingError(String),
}

#[derive(Debug)]
pub enum RouterError {
    HandlerNotRegistered(MessageType),
    QueueFull,
}

impl EngineMessageRouter {
    pub fn new() -> Self {
        Self {
            high_priority: VecDeque::new(),
            normal_priority: VecDeque::new(),
            message_handlers: HashMap::new(),
            message_count: HashMap::new(),
        }
    }
    
    /// Register a handler for a message type
    pub fn register_handler(&mut self, msg_type: MessageType, handler: Box<dyn MessageHandler>) {
        self.message_handlers.insert(msg_type, handler);
    }
    
    /// Queue a message for processing
    pub fn queue_message(&mut self, msg: EngineMessage) -> Result<(), RouterError> {
        let msg_type = msg.message_type();
        
        // Check handler exists
        let handler = self.message_handlers
            .get(&msg_type)
            .ok_or(RouterError::HandlerNotRegistered(msg_type))?;
        
        // Determine priority
        let priority = handler.priority(&msg);
        
        // Queue based on priority
        match priority {
            Priority::High => {
                self.high_priority.push_back(msg);
            }
            Priority::Normal => {
                self.normal_priority.push_back(msg);
            }
            Priority::Low => {
                // Low priority goes to back of normal queue
                self.normal_priority.push_back(msg);
            }
        }
        
        // Track message count
        *self.message_count.entry(msg_type).or_insert(0) += 1;
        
        Ok(())
    }
    
    /// Process next message based on priority
    pub fn process_next(&mut self) -> Option<Result<EngineResponse, EngineError>> {
        // Process high priority first
        if let Some(msg) = self.high_priority.pop_front() {
            return Some(self.process_message(msg));
        }
        
        // Then normal priority
        if let Some(msg) = self.normal_priority.pop_front() {
            return Some(self.process_message(msg));
        }
        
        None
    }
    
    fn process_message(&self, msg: EngineMessage) -> Result<EngineResponse, EngineError> {
        let msg_type = msg.message_type();
        
        let handler = self.message_handlers
            .get(&msg_type)
            .ok_or(EngineError::HandlerNotFound(msg_type))?;
        
        handler.handle(msg)
    }
    
    /// Get queue statistics
    pub fn stats(&self) -> RouterStats {
        RouterStats {
            high_priority_queued: self.high_priority.len(),
            normal_priority_queued: self.normal_priority.len(),
            message_counts: self.message_count.clone(),
        }
    }
}

#[derive(Debug)]
pub struct RouterStats {
    pub high_priority_queued: usize,
    pub normal_priority_queued: usize,
    pub message_counts: HashMap<MessageType, usize>,
}

/// Example handler implementation
pub struct ForkchoiceUpdateHandler;

impl MessageHandler for ForkchoiceUpdateHandler {
    fn handle(&self, msg: EngineMessage) -> Result<EngineResponse, EngineError> {
        match msg {
            EngineMessage::ForkchoiceUpdate { state, .. } => {
                // Process forkchoice update
                Ok(EngineResponse::ForkchoiceUpdated(ForkchoiceUpdated {
                    payload_status: PayloadStatus::valid(),
                    payload_id: None,
                }))
            }
            _ => Err(EngineError::ProcessingError("Wrong message type".into())),
        }
    }
    
    fn priority(&self, msg: &EngineMessage) -> Priority {
        match msg {
            EngineMessage::ForkchoiceUpdate { state, .. } => {
                // Finalized updates are high priority
                if !state.finalized_block_hash.is_zero() {
                    Priority::High
                } else {
                    Priority::Normal
                }
            }
            _ => Priority::Normal,
        }
    }
}
```

### Assignment 2: Fork Choice Conflict Detector

```rust
use alloy_primitives::B256;
use std::collections::{HashMap, VecDeque};
use std::time::{Duration, Instant};

/// Detect conflicts and anomalies in fork choice updates
pub struct ForkChoiceConflictDetector {
    history: VecDeque<TimestampedFCU>,
    max_history: usize,
    known_blocks: HashMap<B256, BlockInfo>,
}

#[derive(Debug, Clone)]
pub struct TimestampedFCU {
    pub timestamp: Instant,
    pub state: ForkchoiceState,
    pub attributes: Option<PayloadAttributes>,
}

#[derive(Debug, Clone)]
pub struct BlockInfo {
    pub number: u64,
    pub parent: B256,
    pub received_at: Instant,
}

#[derive(Debug)]
pub enum ForkChoiceConflict {
    /// Head moved backward
    HeadRegression { from: B256, to: B256, depth: u64 },
    /// Safe block moved backward  
    SafeRegression { from: B256, to: B256 },
    /// Finalized block changed (should never happen)
    FinalizedChanged { from: B256, to: B256 },
    /// Rapid fork choice changes
    UnstableForkChoice { changes: usize, duration: Duration },
}

impl ForkChoiceConflictDetector {
    pub fn new(max_history: usize) -> Self {
        Self {
            history: VecDeque::with_capacity(max_history),
            max_history,
            known_blocks: HashMap::new(),
        }
    }
    
    /// Record a new fork choice update
    pub fn record_fcu(&mut self, state: ForkchoiceState, attrs: Option<PayloadAttributes>) {
        let timestamped = TimestampedFCU {
            timestamp: Instant::now(),
            state,
            attributes: attrs,
        };
        
        self.history.push_back(timestamped);
        
        // Maintain history size
        while self.history.len() > self.max_history {
            self.history.pop_front();
        }
    }
    
    /// Record block info for conflict detection
    pub fn record_block(&mut self, hash: B256, number: u64, parent: B256) {
        self.known_blocks.insert(hash, BlockInfo {
            number,
            parent,
            received_at: Instant::now(),
        });
    }
    
    /// Detect conflicts in recent FCUs
    pub fn detect_conflicts(&self) -> Vec<ForkChoiceConflict> {
        let mut conflicts = Vec::new();
        
        if self.history.len() < 2 {
            return conflicts;
        }
        
        // Check for regressions
        for i in 1..self.history.len() {
            let prev = &self.history[i - 1];
            let curr = &self.history[i];
            
            // Check head regression
            if let Some(depth) = self.calculate_regression_depth(
                prev.state.head_block_hash,
                curr.state.head_block_hash,
            ) {
                if depth > 0 {
                    conflicts.push(ForkChoiceConflict::HeadRegression {
                        from: prev.state.head_block_hash,
                        to: curr.state.head_block_hash,
                        depth,
                    });
                }
            }
            
            // Check safe regression
            if !prev.state.safe_block_hash.is_zero() && 
               !curr.state.safe_block_hash.is_zero() &&
               prev.state.safe_block_hash != curr.state.safe_block_hash {
                if let Some(prev_safe) = self.known_blocks.get(&prev.state.safe_block_hash) {
                    if let Some(curr_safe) = self.known_blocks.get(&curr.state.safe_block_hash) {
                        if curr_safe.number < prev_safe.number {
                            conflicts.push(ForkChoiceConflict::SafeRegression {
                                from: prev.state.safe_block_hash,
                                to: curr.state.safe_block_hash,
                            });
                        }
                    }
                }
            }
            
            // Check finalized change (critical!)
            if !prev.state.finalized_block_hash.is_zero() &&
               !curr.state.finalized_block_hash.is_zero() &&
               prev.state.finalized_block_hash != curr.state.finalized_block_hash {
                conflicts.push(ForkChoiceConflict::FinalizedChanged {
                    from: prev.state.finalized_block_hash,
                    to: curr.state.finalized_block_hash,
                });
            }
        }
        
        // Check for unstable fork choice
        let stability_conflicts = self.check_stability();
        conflicts.extend(stability_conflicts);
        
        conflicts
    }
    
    fn calculate_regression_depth(&self, from: B256, to: B256) -> Option<u64> {
        let from_info = self.known_blocks.get(&from)?;
        let to_info = self.known_blocks.get(&to)?;
        
        if to_info.number < from_info.number {
            Some(from_info.number - to_info.number)
        } else {
            None
        }
    }
    
    fn check_stability(&self) -> Vec<ForkChoiceConflict> {
        let mut conflicts = Vec::new();
        let now = Instant::now();
        
        // Check rapid changes in 1 minute window
        let one_minute_ago = now - Duration::from_secs(60);
        let recent_changes: Vec<_> = self.history.iter()
            .filter(|fcu| fcu.timestamp > one_minute_ago)
            .collect();
        
        if recent_changes.len() > 10 {
            let mut head_changes = 0;
            for i in 1..recent_changes.len() {
                if recent_changes[i - 1].state.head_block_hash != 
                   recent_changes[i].state.head_block_hash {
                    head_changes += 1;
                }
            }
            
            if head_changes > 5 {
                conflicts.push(ForkChoiceConflict::UnstableForkChoice {
                    changes: head_changes,
                    duration: Duration::from_secs(60),
                });
            }
        }
        
        conflicts
    }
    
    /// Analyze fork choice stability
    pub fn analyze_stability(&self, window: Duration) -> StabilityReport {
        let now = Instant::now();
        let start_time = now - window;
        
        let window_fcus: Vec<_> = self.history.iter()
            .filter(|fcu| fcu.timestamp > start_time)
            .collect();
        
        if window_fcus.is_empty() {
            return StabilityReport::default();
        }
        
        let mut head_changes = 0;
        let mut reorg_count = 0;
        let mut max_reorg_depth = 0;
        
        for i in 1..window_fcus.len() {
            let prev = window_fcus[i - 1];
            let curr = window_fcus[i];
            
            if prev.state.head_block_hash != curr.state.head_block_hash {
                head_changes += 1;
                
                if let Some(depth) = self.calculate_regression_depth(
                    prev.state.head_block_hash,
                    curr.state.head_block_hash,
                ) {
                    if depth > 0 {
                        reorg_count += 1;
                        max_reorg_depth = max_reorg_depth.max(depth);
                    }
                }
            }
        }
        
        // Calculate average block time
        let duration = window_fcus.last().unwrap().timestamp - window_fcus[0].timestamp;
        let average_block_time = if head_changes > 0 {
            duration / head_changes as u32
        } else {
            Duration::from_secs(12) // Default
        };
        
        StabilityReport {
            total_updates: window_fcus.len(),
            head_changes,
            average_block_time,
            reorg_count,
            max_reorg_depth,
        }
    }
}

#[derive(Debug, Default)]
pub struct StabilityReport {
    pub total_updates: usize,
    pub head_changes: usize,
    pub average_block_time: Duration,
    pub reorg_count: usize,
    pub max_reorg_depth: u64,
}
```

### Assignment 3: Payload Validation Pipeline

```rust
use alloy_primitives::B256;
use lru::LruCache;
use std::collections::HashMap;
use std::num::NonZeroUsize;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::Mutex;

/// Validate payloads with multiple validation stages
pub struct PayloadValidationPipeline {
    validators: Vec<Box<dyn PayloadValidator>>,
    cache: Arc<Mutex<PayloadValidationCache>>,
    metrics: Arc<Mutex<ValidationMetrics>>,
}

pub trait PayloadValidator: Send + Sync {
    fn name(&self) -> &str;
    fn validate(&self, payload: &ExecutionPayload) -> Result<(), ValidationError>;
    fn can_validate(&self, payload: &ExecutionPayload) -> bool;
}

#[derive(Debug, Clone)]
pub enum ValidationError {
    InvalidTimestamp(String),
    InvalidBlockHash(String),
    InvalidParentHash(String),
    InvalidStateRoot(String),
    InvalidTransactions(String),
    InvalidWithdrawals(String),
    Custom(String),
}

pub struct PayloadValidationCache {
    valid_hashes: LruCache<B256, CachedValidation>,
    invalid_hashes: LruCache<B256, ValidationError>,
}

#[derive(Clone)]
pub struct CachedValidation {
    pub block_hash: B256,
    pub timestamp: Instant,
    pub validators_passed: Vec<String>,
}

impl PayloadValidationPipeline {
    pub fn new() -> Self {
        Self {
            validators: Vec::new(),
            cache: Arc::new(Mutex::new(PayloadValidationCache::new(1000))),
            metrics: Arc::new(Mutex::new(ValidationMetrics::default())),
        }
    }
    
    /// Add a validator to the pipeline
    pub fn add_validator(&mut self, validator: Box<dyn PayloadValidator>) {
        self.validators.push(validator);
    }
    
    /// Validate a payload through all stages
    pub async fn validate(&mut self, payload: ExecutionPayload) -> ValidationResult {
        let start = Instant::now();
        let block_hash = payload.block_hash();
        
        // Check cache first
        {
            let cache = self.cache.lock().await;
            
            // Check if already validated
            if let Some(cached) = cache.valid_hashes.peek(&block_hash) {
                let mut metrics = self.metrics.lock().await;
                metrics.cache_hits += 1;
                
                return ValidationResult {
                    status: PayloadStatus::valid(),
                    stages_completed: cached.validators_passed.clone(),
                    cached: true,
                    duration: start.elapsed(),
                };
            }
            
            // Check if known invalid
            if let Some(error) = cache.invalid_hashes.peek(&block_hash) {
                let mut metrics = self.metrics.lock().await;
                metrics.cache_hits += 1;
                
                return ValidationResult {
                    status: PayloadStatus::invalid_with_err(error.clone()),
                    stages_completed: vec![],
                    cached: true,
                    duration: start.elapsed(),
                };
            }
        }
        
        // Run validation pipeline
        let mut stages_completed = Vec::new();
        let mut validation_error = None;
        
        for validator in &self.validators {
            if !validator.can_validate(&payload) {
                continue;
            }
            
            match validator.validate(&payload) {
                Ok(()) => {
                    stages_completed.push(validator.name().to_string());
                }
                Err(err) => {
                    validation_error = Some(err);
                    
                    // Update metrics
                    let mut metrics = self.metrics.lock().await;
                    *metrics.validation_errors
                        .entry(validator.name().to_string())
                        .or_insert(0) += 1;
                    
                    break;
                }
            }
        }
        
        // Update cache
        {
            let mut cache = self.cache.lock().await;
            
            if let Some(error) = validation_error {
                cache.invalid_hashes.put(block_hash, error.clone());
                
                return ValidationResult {
                    status: PayloadStatus::invalid_with_err(error),
                    stages_completed,
                    cached: false,
                    duration: start.elapsed(),
                };
            } else {
                cache.valid_hashes.put(block_hash, CachedValidation {
                    block_hash,
                    timestamp: Instant::now(),
                    validators_passed: stages_completed.clone(),
                });
            }
        }
        
        // Update metrics
        {
            let mut metrics = self.metrics.lock().await;
            metrics.total_validations += 1;
            
            let duration = start.elapsed();
            let avg_ms = metrics.average_duration.as_millis() as u64;
            let new_ms = duration.as_millis() as u64;
            metrics.average_duration = Duration::from_millis(
                (avg_ms * (metrics.total_validations - 1) + new_ms) / metrics.total_validations
            );
        }
        
        ValidationResult {
            status: PayloadStatus::valid(),
            stages_completed,
            cached: false,
            duration: start.elapsed(),
        }
    }
    
    /// Get validation metrics
    pub async fn metrics(&self) -> ValidationMetrics {
        self.metrics.lock().await.clone()
    }
}

impl PayloadValidationCache {
    fn new(capacity: usize) -> Self {
        Self {
            valid_hashes: LruCache::new(NonZeroUsize::new(capacity).unwrap()),
            invalid_hashes: LruCache::new(NonZeroUsize::new(capacity / 4).unwrap()),
        }
    }
}

#[derive(Debug)]
pub struct ValidationResult {
    pub status: PayloadStatus,
    pub stages_completed: Vec<String>,
    pub cached: bool,
    pub duration: Duration,
}

#[derive(Debug, Default, Clone)]
pub struct ValidationMetrics {
    pub total_validations: u64,
    pub cache_hits: u64,
    pub validation_errors: HashMap<String, u64>,
    pub average_duration: Duration,
}

/// Example validators
pub struct TimestampValidator;

impl PayloadValidator for TimestampValidator {
    fn name(&self) -> &str {
        "timestamp"
    }
    
    fn validate(&self, payload: &ExecutionPayload) -> Result<(), ValidationError> {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        if payload.timestamp() > now + 60 {
            return Err(ValidationError::InvalidTimestamp(
                "Timestamp too far in future".into()
            ));
        }
        
        Ok(())
    }
    
    fn can_validate(&self, _payload: &ExecutionPayload) -> bool {
        true
    }
}

pub struct WithdrawalsValidator {
    hardfork_timestamps: HashMap<String, u64>,
}

impl PayloadValidator for WithdrawalsValidator {
    fn name(&self) -> &str {
        "withdrawals"
    }
    
    fn validate(&self, payload: &ExecutionPayload) -> Result<(), ValidationError> {
        if let Some(shanghai_time) = self.hardfork_timestamps.get("shanghai") {
            if payload.timestamp() >= *shanghai_time && payload.withdrawals().is_none() {
                return Err(ValidationError::InvalidWithdrawals(
                    "Missing required withdrawals".into()
                ));
            }
        }
        
        Ok(())
    }
    
    fn can_validate(&self, payload: &ExecutionPayload) -> bool {
        // Only validate if Shanghai is active
        self.hardfork_timestamps.get("shanghai")
            .map(|&time| payload.timestamp() >= time)
            .unwrap_or(false)
    }
}
```

## Questions to Ponder

1. **Consensus Split**: What happens if consensus and execution layers disagree about a block's validity?

2. **Message Ordering**: Why is the order of engine API messages critical? What could go wrong?

3. **Fork Choice Timing**: How quickly must execution respond to fork choice updates? What's the deadline?

4. **Payload Building**: How does MEV affect the relationship between consensus and execution layers?

5. **Network Partitions**: How does the engine API handle network splits between CL and EL?

Understanding the Engine API is essential for grasping how post-merge Ethereum maintains consensus across its dual-layer architecture.