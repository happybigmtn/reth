# Lesson 25: The Execution Outcome

*"If you want to learn about nature, to appreciate nature, it is necessary to understand the language that she speaks in." - Richard Feynman*

## Files with Inline Comments for This Lesson
- `crates/evm/execution-types/src/execution_outcome.rs` - Core execution outcome structure
- `crates/evm/execution-types/src/chain.rs` - Chain execution outcomes
- `crates/revm/src/database/states/bundle_state.rs` - Bundle state management
- `crates/storage/provider/src/bundle_state_provider.rs` - State provider for bundles

## What is an Execution Outcome? The Complete Transaction Story

**WHY Execution Outcomes Are Essential**: Imagine if a bank only told you "your balance changed" but not how, why, or what happened if something went wrong. Execution outcomes are Ethereum's complete transaction audit trail.

**Real-world analogy**: An execution outcome is like a detailed surgical report. It doesn't just say "surgery completed" - it documents every step, what changed, what was removed, what was added, and provides complete traceability.

**The Complete Picture** (from actual Reth code in `execution-types/src/execution_outcome.rs`):
```
Before Execution:              After Execution:
┌──────────────────┐              ┌──────────────────────────────────┐
│ Alice: 100 ETH      │              │ ExecutionOutcome {              │
│ Bob: 50 ETH         │   Execute     │   bundle: BundleState {          │ 
│ Contract: <code>    │   ------->    │     Alice: 95 ETH (-5)           │
│                  │              │     Bob: 55 ETH (+5)             │
└──────────────────┘              │     Contract: <new_code>         │
                              │   },                           │
                              │   receipts: [success, gas_used]│
                              │   reverts: [for reorganizations]│
                              │   requests: [withdrawals, etc.] │
                              │ }                             │
                              └──────────────────────────────────┘
```

**CRITICAL INSIGHT**: The ExecutionOutcome isn't just the final state - it's a *complete diff* that can be applied, rolled back, or merged with other outcomes.

## The ExecutionOutcome Structure

### Core Components

```rust
/// Represents the outcome of executing one or more blocks
/// Located in: crates/evm/execution-types/src/execution_outcome.rs

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ExecutionOutcome<T = Receipt> {
    /// Bundle state containing all state changes
    /// This includes account changes, storage updates, and new contracts
    pub bundle: BundleState,
    
    /// Receipts for each transaction in each block
    /// Outer Vec: one entry per block
    /// Inner Vec: receipts for transactions in that block
    pub receipts: Vec<Vec<T>>,
    
    /// The first block number in this outcome
    /// Important for tracking which blocks these changes apply to
    pub first_block: BlockNumber,
    
    /// EIP-7685 requests (withdrawals, consolidations, etc.)
    /// These are protocol-level operations requested by transactions
    pub requests: Vec<Requests>,
}
```

### Understanding BundleState

```rust
/// Bundle of state changes from transaction execution
/// Located in: revm/src/database/states/bundle_state.rs

pub struct BundleState {
    /// Account state changes
    /// Maps address -> account changes (original state, new state)
    pub state: HashMap<Address, BundleAccount>,
    
    /// Contract bytecode deployments
    /// Maps code hash -> bytecode
    pub contracts: HashMap<B256, Bytecode>,
    
    /// Revert information for handling reorganizations
    /// Indexed by block number for efficient revert operations
    pub reverts: Vec<HashMap<Address, AccountRevert>>,
}

/// Changes to a single account
pub struct BundleAccount {
    /// Account info (nonce, balance, code hash)
    pub info: Option<AccountInfo>,
    
    /// Original account info (for reverts)
    pub original_info: Option<AccountInfo>,
    
    /// Storage changes: slot -> (original, new)
    pub storage: HashMap<U256, StorageSlot>,
    
    /// Account status (created, modified, destroyed)
    pub status: AccountStatus,
}
```

## Creating Execution Outcomes

### From Single Block Execution

```rust
impl<T> ExecutionOutcome<T> {
    /// Create outcome from a single block's execution
    pub fn single(block_number: u64, output: BlockExecutionOutput<T>) -> Self {
        Self {
            bundle: output.state,
            receipts: vec![output.result.receipts],
            first_block: block_number,
            requests: vec![output.result.requests],
        }
    }
    
    /// Example: Execute a block and create outcome
    pub fn execute_single_block(
        executor: &mut BlockExecutor,
        block: &Block,
    ) -> Result<ExecutionOutcome, Error> {
        // Execute all transactions in the block
        let output = executor.execute_block(block)?;
        
        // Create execution outcome
        let outcome = ExecutionOutcome::single(block.number, output);
        
        // The outcome now contains:
        // - All state changes from the block
        // - Receipts for each transaction
        // - Any protocol requests (e.g., withdrawals)
        
        Ok(outcome)
    }
}
```

### From Multiple Blocks

```rust
impl<T> ExecutionOutcome<T> {
    /// Create outcome from multiple block executions
    pub fn from_blocks(
        first_block: u64,
        bundle: BundleState,
        results: Vec<BlockExecutionResult<T>>,
    ) -> Self {
        let mut receipts = Vec::new();
        let mut requests = Vec::new();
        
        // Aggregate results from all blocks
        for result in results {
            receipts.push(result.receipts);
            requests.push(result.requests);
        }
        
        Self {
            bundle,
            receipts,
            first_block,
            requests,
        }
    }
}

/// Example: Execute multiple blocks in sequence
pub fn execute_block_range(
    executor: &mut BlockExecutor,
    blocks: Vec<Block>,
) -> Result<ExecutionOutcome, Error> {
    let first_block = blocks.first().unwrap().number;
    let mut bundle = BundleState::default();
    let mut results = Vec::new();
    
    for block in blocks {
        // Execute block
        let output = executor.execute_block(&block)?;
        
        // Merge state changes into bundle
        bundle.merge(output.state);
        
        // Collect results
        results.push(output.result);
    }
    
    Ok(ExecutionOutcome::from_blocks(first_block, bundle, results))
}
```

## State Management in Execution Outcomes

### Account Changes

```rust
impl ExecutionOutcome {
    /// Get the final state of an account after execution
    pub fn account(&self, address: &Address) -> Option<Option<Account>> {
        self.bundle.account(address)
            .map(|bundle_account| {
                bundle_account.info.as_ref().map(|info| Account {
                    nonce: info.nonce,
                    balance: info.balance,
                    storage_root: EMPTY_ROOT, // Calculated later
                    code_hash: info.code_hash,
                })
            })
    }
    
    /// Get all accounts that were modified
    pub fn changed_accounts(&self) -> Vec<ChangedAccount> {
        self.bundle.state()
            .iter()
            .filter_map(|(address, account)| {
                // Only include accounts that actually changed
                if account.is_changed() {
                    Some(ChangedAccount {
                        address: *address,
                        nonce: account.info.as_ref()?.nonce,
                        balance: account.info.as_ref()?.balance,
                    })
                } else {
                    None
                }
            })
            .collect()
    }
}
```

### Storage Changes

```rust
impl ExecutionOutcome {
    /// Get storage value for an account
    pub fn storage(&self, address: &Address, slot: U256) -> Option<U256> {
        self.bundle.account(address)
            .and_then(|account| account.storage_slot(slot))
    }
    
    /// Get all storage changes for an account
    pub fn storage_changes(&self, address: &Address) -> Option<Vec<(U256, U256)>> {
        self.bundle.account(address)
            .map(|account| {
                account.storage
                    .iter()
                    .filter(|(_, slot)| slot.is_changed())
                    .map(|(key, slot)| (*key, slot.present_value))
                    .collect()
            })
    }
}
```

### Contract Deployments

```rust
impl ExecutionOutcome {
    /// Get deployed contract bytecode by hash
    pub fn bytecode(&self, code_hash: &B256) -> Option<Bytecode> {
        self.bundle.contracts.get(code_hash).cloned()
    }
    
    /// Get all newly deployed contracts
    pub fn deployed_contracts(&self) -> Vec<(Address, Bytecode)> {
        self.bundle.state()
            .iter()
            .filter_map(|(address, account)| {
                if account.is_created() {
                    let code_hash = account.info.as_ref()?.code_hash;
                    let bytecode = self.bundle.contracts.get(&code_hash)?;
                    Some((*address, bytecode.clone()))
                } else {
                    None
                }
            })
            .collect()
    }
}
```

## Handling Reverts

### Revert Mechanism

```rust
/// Information needed to revert account changes
pub struct AccountRevert {
    /// Previous account state (None if account was created)
    pub original_info: Option<AccountInfo>,
    
    /// Storage slots that need reverting
    pub storage: Vec<(U256, U256)>, // (slot, original_value)
    
    /// Whether account was destroyed
    pub destroyed: bool,
}

impl BundleState {
    /// Take reverts for a specific block
    pub fn take_reverts(&mut self, block_number: u64) -> Option<Vec<(Address, AccountRevert)>> {
        let index = (block_number - self.first_block) as usize;
        
        if index < self.reverts.len() {
            Some(self.reverts[index].drain().collect())
        } else {
            None
        }
    }
    
    /// Apply reverts to restore previous state
    pub fn revert_block(&mut self, block_number: u64) -> Result<(), Error> {
        if let Some(reverts) = self.take_reverts(block_number) {
            for (address, revert) in reverts {
                self.revert_account(address, revert)?;
            }
        }
        Ok(())
    }
    
    /// Revert a single account
    fn revert_account(&mut self, address: Address, revert: AccountRevert) -> Result<(), Error> {
        let account = self.state.entry(address).or_default();
        
        // Restore original account info
        account.info = revert.original_info;
        
        // Revert storage changes
        for (slot, original_value) in revert.storage {
            if original_value == U256::ZERO {
                account.storage.remove(&slot);
            } else {
                account.storage.insert(slot, StorageSlot {
                    original_value,
                    present_value: original_value,
                });
            }
        }
        
        // Handle account destruction
        if revert.destroyed {
            self.state.remove(&address);
        }
        
        Ok(())
    }
}
```

## Processing Receipts

### Receipt Aggregation

```rust
impl<T: Receipt> ExecutionOutcome<T> {
    /// Get receipts for a specific block
    pub fn receipts_for_block(&self, block_number: u64) -> Option<&[T]> {
        let index = (block_number - self.first_block) as usize;
        self.receipts.get(index).map(|r| r.as_slice())
    }
    
    /// Calculate cumulative gas used
    pub fn calculate_gas_used(&self) -> Vec<u64> {
        let mut cumulative = 0u64;
        let mut gas_used = Vec::new();
        
        for block_receipts in &self.receipts {
            for receipt in block_receipts {
                cumulative += receipt.gas_used();
                gas_used.push(cumulative);
            }
        }
        
        gas_used
    }
    
    /// Generate logs bloom filter for blocks
    pub fn logs_bloom(&self) -> Vec<Bloom> {
        self.receipts.iter()
            .map(|block_receipts| {
                let mut bloom = Bloom::ZERO;
                for receipt in block_receipts {
                    bloom.accrue_bloom(&receipt.bloom());
                }
                bloom
            })
            .collect()
    }
}
```

## Integration with State Root Calculation

### Providing State for Root Calculation

```rust
/// Bundle state provider for state root calculation
/// Located in: crates/storage/provider/src/bundle_state_provider.rs

pub struct BundleStateProvider<'a> {
    /// Underlying state provider
    pub state_provider: &'a dyn StateProvider,
    /// Bundle state with changes
    pub bundle_state: &'a BundleState,
}

impl<'a> StateProvider for BundleStateProvider<'a> {
    /// Get account with bundle state overlay
    fn basic_account(&self, address: Address) -> Result<Option<Account>, Error> {
        // First check bundle state for changes
        if let Some(account) = self.bundle_state.account(&address) {
            return Ok(account.info.as_ref().map(|info| info.into()));
        }
        
        // Fall back to underlying provider
        self.state_provider.basic_account(address)
    }
    
    /// Get storage with bundle state overlay
    fn storage(&self, address: Address, slot: U256) -> Result<Option<U256>, Error> {
        // Check bundle state first
        if let Some(account) = self.bundle_state.account(&address) {
            if let Some(value) = account.storage_slot(slot) {
                return Ok(Some(value));
            }
        }
        
        // Fall back to underlying provider
        self.state_provider.storage(address, slot)
    }
}
```

## Optimizations and Performance

### Memory Management

```rust
impl ExecutionOutcome {
    /// Preallocate space for expected number of changes
    pub fn with_capacity(
        blocks: usize,
        accounts: usize,
        storage_slots: usize,
    ) -> Self {
        Self {
            bundle: BundleState::with_capacity(accounts, storage_slots),
            receipts: Vec::with_capacity(blocks),
            first_block: 0,
            requests: Vec::with_capacity(blocks),
        }
    }
    
    /// Shrink internal allocations to fit
    pub fn shrink_to_fit(&mut self) {
        self.bundle.shrink_to_fit();
        self.receipts.shrink_to_fit();
        self.requests.shrink_to_fit();
    }
}
```

### Efficient Merging

```rust
impl ExecutionOutcome {
    /// Merge another execution outcome into this one
    pub fn merge(&mut self, other: Self) -> Result<(), Error> {
        // Ensure blocks are consecutive
        let expected_block = self.first_block + self.receipts.len() as u64;
        if other.first_block != expected_block {
            return Err(Error::NonConsecutiveBlocks);
        }
        
        // Merge bundle states
        self.bundle.merge(other.bundle);
        
        // Append receipts and requests
        self.receipts.extend(other.receipts);
        self.requests.extend(other.requests);
        
        Ok(())
    }
}
```

## Assignments

### Assignment 1: Execution Outcome Analyzer

Build a system to analyze execution outcomes:

```rust
use std::collections::{HashMap, HashSet};
use alloy_primitives::{Address, B256, U256};

/// Analyzes execution outcomes for insights
pub struct ExecutionOutcomeAnalyzer {
    /// Analysis configuration
    config: AnalysisConfig,
    /// Cached analysis results
    cache: HashMap<B256, AnalysisResult>,
}

#[derive(Debug, Clone)]
pub struct AnalysisConfig {
    /// Track top N accounts by gas usage
    pub top_accounts_count: usize,
    /// Track storage hotspots
    pub track_storage_hotspots: bool,
    /// Analyze contract deployments
    pub analyze_deployments: bool,
    /// Track cross-contract calls
    pub track_interactions: bool,
}

#[derive(Debug, Clone)]
pub struct AnalysisResult {
    /// Summary statistics
    pub summary: ExecutionSummary,
    /// Account-level analysis
    pub account_analysis: AccountAnalysis,
    /// Storage analysis
    pub storage_analysis: StorageAnalysis,
    /// Contract deployment analysis
    pub deployment_analysis: DeploymentAnalysis,
    /// Gas usage patterns
    pub gas_analysis: GasAnalysis,
}

#[derive(Debug, Clone)]
pub struct ExecutionSummary {
    pub total_blocks: usize,
    pub total_transactions: usize,
    pub successful_transactions: usize,
    pub failed_transactions: usize,
    pub total_gas_used: u64,
    pub accounts_touched: usize,
    pub storage_slots_modified: usize,
    pub contracts_created: usize,
    pub ether_transferred: U256,
}

#[derive(Debug, Clone)]
pub struct AccountAnalysis {
    /// Most active accounts by transaction count
    pub most_active: Vec<(Address, usize)>,
    /// Accounts with highest gas consumption
    pub top_gas_users: Vec<(Address, u64)>,
    /// Accounts with most value transferred
    pub top_value_movers: Vec<(Address, U256)>,
    /// New accounts created
    pub new_accounts: HashSet<Address>,
    /// Accounts that were destroyed
    pub destroyed_accounts: HashSet<Address>,
}

#[derive(Debug, Clone)]
pub struct StorageAnalysis {
    /// Most frequently accessed storage slots per contract
    pub hot_slots: HashMap<Address, Vec<(U256, usize)>>,
    /// Storage growth per contract
    pub storage_growth: HashMap<Address, isize>,
    /// Contracts with most storage operations
    pub storage_intensive: Vec<(Address, usize)>,
}

#[derive(Debug, Clone)]
pub struct DeploymentAnalysis {
    /// New contracts deployed
    pub deployments: Vec<ContractDeployment>,
    /// Factory contracts (that deploy other contracts)
    pub factories: HashMap<Address, Vec<Address>>,
    /// Contract creation gas costs
    pub creation_costs: Vec<(Address, u64)>,
    /// Code size distribution
    pub code_sizes: Vec<(Address, usize)>,
}

#[derive(Debug, Clone)]
pub struct ContractDeployment {
    pub address: Address,
    pub deployer: Address,
    pub code_hash: B256,
    pub code_size: usize,
    pub init_code_size: usize,
    pub gas_used: u64,
    pub block_number: u64,
}

#[derive(Debug, Clone)]
pub struct GasAnalysis {
    /// Gas usage by transaction type
    pub gas_by_type: HashMap<TransactionType, GasStats>,
    /// Gas price distribution
    pub gas_price_stats: GasStats,
    /// Base fee evolution
    pub base_fee_trend: Vec<u64>,
    /// Priority fee statistics
    pub priority_fee_stats: GasStats,
}

#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub enum TransactionType {
    Transfer,
    ContractCreation,
    ContractCall,
    TokenTransfer,
    DeFiInteraction,
    Other,
}

#[derive(Debug, Clone, Default)]
pub struct GasStats {
    pub min: u64,
    pub max: u64,
    pub mean: u64,
    pub median: u64,
    pub std_dev: u64,
    pub total: u64,
    pub count: usize,
}

impl ExecutionOutcomeAnalyzer {
    pub fn new(config: AnalysisConfig) -> Self {
        Self {
            config,
            cache: HashMap::new(),
        }
    }
    
    /// Analyze an execution outcome
    pub fn analyze(&mut self, outcome: &ExecutionOutcome) -> AnalysisResult {
        let mut result = AnalysisResult {
            summary: self.calculate_summary(outcome),
            account_analysis: self.analyze_accounts(outcome),
            storage_analysis: self.analyze_storage(outcome),
            deployment_analysis: self.analyze_deployments(outcome),
            gas_analysis: self.analyze_gas(outcome),
        };
        
        // Cache result
        let cache_key = self.calculate_cache_key(outcome);
        self.cache.insert(cache_key, result.clone());
        
        result
    }
    
    /// Calculate summary statistics
    fn calculate_summary(&self, outcome: &ExecutionOutcome) -> ExecutionSummary {
        let mut summary = ExecutionSummary {
            total_blocks: outcome.receipts.len(),
            total_transactions: 0,
            successful_transactions: 0,
            failed_transactions: 0,
            total_gas_used: 0,
            accounts_touched: 0,
            storage_slots_modified: 0,
            contracts_created: 0,
            ether_transferred: U256::ZERO,
        };
        
        // Count transactions and gas
        for block_receipts in &outcome.receipts {
            summary.total_transactions += block_receipts.len();
            
            for receipt in block_receipts {
                if receipt.success {
                    summary.successful_transactions += 1;
                } else {
                    summary.failed_transactions += 1;
                }
                summary.total_gas_used += receipt.cumulative_gas_used;
            }
        }
        
        // Count touched accounts and storage
        let mut touched_accounts = HashSet::new();
        for (address, account) in outcome.bundle_accounts_iter() {
            touched_accounts.insert(address);
            
            if account.is_created() {
                summary.contracts_created += 1;
            }
            
            summary.storage_slots_modified += account.storage.len();
        }
        summary.accounts_touched = touched_accounts.len();
        
        summary
    }
    
    /// Analyze account activity
    fn analyze_accounts(&self, outcome: &ExecutionOutcome) -> AccountAnalysis {
        let mut transaction_count: HashMap<Address, usize> = HashMap::new();
        let mut gas_used: HashMap<Address, u64> = HashMap::new();
        let mut value_transferred: HashMap<Address, U256> = HashMap::new();
        let mut new_accounts = HashSet::new();
        let mut destroyed_accounts = HashSet::new();
        
        // Analyze each account
        for (address, account) in outcome.bundle_accounts_iter() {
            if account.is_created() {
                new_accounts.insert(address);
            }
            
            if account.was_destroyed() {
                destroyed_accounts.insert(address);
            }
            
            // Track value changes
            if let (Some(original), Some(current)) = (&account.original_info, &account.info) {
                let value_change = current.balance.saturating_sub(original.balance);
                if value_change > U256::ZERO {
                    *value_transferred.entry(address).or_default() += value_change;
                }
            }
        }
        
        // Sort and take top accounts
        let mut activity_vec: Vec<_> = transaction_count.into_iter().collect();
        activity_vec.sort_by_key(|(_, count)| std::cmp::Reverse(*count));
        let most_active = activity_vec.into_iter()
            .take(self.config.top_accounts_count)
            .collect();
        
        let mut gas_vec: Vec<_> = gas_used.into_iter().collect();
        gas_vec.sort_by_key(|(_, gas)| std::cmp::Reverse(*gas));
        let top_gas_users = gas_vec.into_iter()
            .take(self.config.top_accounts_count)
            .collect();
        
        let mut value_vec: Vec<_> = value_transferred.into_iter().collect();
        value_vec.sort_by_key(|(_, value)| std::cmp::Reverse(*value));
        let top_value_movers = value_vec.into_iter()
            .take(self.config.top_accounts_count)
            .collect();
        
        AccountAnalysis {
            most_active,
            top_gas_users,
            top_value_movers,
            new_accounts,
            destroyed_accounts,
        }
    }
    
    /// Analyze storage patterns
    fn analyze_storage(&self, outcome: &ExecutionOutcome) -> StorageAnalysis {
        let mut slot_access_count: HashMap<Address, HashMap<U256, usize>> = HashMap::new();
        let mut storage_growth: HashMap<Address, isize> = HashMap::new();
        let mut storage_ops_count: HashMap<Address, usize> = HashMap::new();
        
        if !self.config.track_storage_hotspots {
            return StorageAnalysis {
                hot_slots: HashMap::new(),
                storage_growth: HashMap::new(),
                storage_intensive: Vec::new(),
            };
        }
        
        // Count storage operations
        for (address, account) in outcome.bundle_accounts_iter() {
            let mut growth = 0isize;
            let mut ops = 0usize;
            
            for (slot, storage_slot) in &account.storage {
                // Count access
                *slot_access_count.entry(address).or_default()
                    .entry(*slot).or_default() += 1;
                
                // Count growth
                if storage_slot.original_value == U256::ZERO && 
                   storage_slot.present_value != U256::ZERO {
                    growth += 1;
                } else if storage_slot.original_value != U256::ZERO && 
                          storage_slot.present_value == U256::ZERO {
                    growth -= 1;
                }
                
                ops += 1;
            }
            
            if growth != 0 {
                *storage_growth.entry(address).or_default() += growth;
            }
            
            if ops > 0 {
                *storage_ops_count.entry(address).or_default() += ops;
            }
        }
        
        // Find hot slots
        let mut hot_slots = HashMap::new();
        for (address, slots) in slot_access_count {
            let mut slot_vec: Vec<_> = slots.into_iter().collect();
            slot_vec.sort_by_key(|(_, count)| std::cmp::Reverse(*count));
            hot_slots.insert(address, slot_vec);
        }
        
        // Find storage intensive contracts
        let mut storage_vec: Vec<_> = storage_ops_count.into_iter().collect();
        storage_vec.sort_by_key(|(_, ops)| std::cmp::Reverse(*ops));
        let storage_intensive = storage_vec.into_iter()
            .take(self.config.top_accounts_count)
            .collect();
        
        StorageAnalysis {
            hot_slots,
            storage_growth,
            storage_intensive,
        }
    }
    
    /// Analyze contract deployments
    fn analyze_deployments(&self, outcome: &ExecutionOutcome) -> DeploymentAnalysis {
        let mut deployments = Vec::new();
        let mut factories: HashMap<Address, Vec<Address>> = HashMap::new();
        let mut creation_costs = Vec::new();
        let mut code_sizes = Vec::new();
        
        if !self.config.analyze_deployments {
            return DeploymentAnalysis {
                deployments: Vec::new(),
                factories: HashMap::new(),
                creation_costs: Vec::new(),
                code_sizes: Vec::new(),
            };
        }
        
        // Find all contract creations
        for (block_num, block_receipts) in outcome.receipts.iter().enumerate() {
            let block_number = outcome.first_block + block_num as u64;
            
            for (tx_index, receipt) in block_receipts.iter().enumerate() {
                if receipt.contract_address.is_some() {
                    let contract_address = receipt.contract_address.unwrap();
                    
                    // Get contract info
                    if let Some(account) = outcome.bundle.account(&contract_address) {
                        if let Some(info) = &account.info {
                            let bytecode = outcome.bytecode(&info.code_hash);
                            let code_size = bytecode.as_ref().map(|b| b.len()).unwrap_or(0);
                            
                            let deployment = ContractDeployment {
                                address: contract_address,
                                deployer: receipt.from, // Simplified
                                code_hash: info.code_hash,
                                code_size,
                                init_code_size: 0, // Would need transaction data
                                gas_used: receipt.gas_used(),
                                block_number,
                            };
                            
                            deployments.push(deployment);
                            creation_costs.push((contract_address, receipt.gas_used()));
                            code_sizes.push((contract_address, code_size));
                            
                            // Track factory patterns
                            factories.entry(receipt.from).or_default()
                                .push(contract_address);
                        }
                    }
                }
            }
        }
        
        DeploymentAnalysis {
            deployments,
            factories,
            creation_costs,
            code_sizes,
        }
    }
    
    /// Calculate cache key for outcome
    fn calculate_cache_key(&self, outcome: &ExecutionOutcome) -> B256 {
        // Simple hash of first block and receipt count
        let mut data = Vec::new();
        data.extend_from_slice(&outcome.first_block.to_le_bytes());
        data.extend_from_slice(&outcome.receipts.len().to_le_bytes());
        keccak256(&data)
    }
}

// Usage example
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = AnalysisConfig {
        top_accounts_count: 10,
        track_storage_hotspots: true,
        analyze_deployments: true,
        track_interactions: true,
    };
    
    let mut analyzer = ExecutionOutcomeAnalyzer::new(config);
    
    // Analyze execution outcome
    let outcome = get_execution_outcome().await?;
    let analysis = analyzer.analyze(&outcome);
    
    // Print results
    println!("Execution Analysis:");
    println!("==================");
    println!("Total blocks: {}", analysis.summary.total_blocks);
    println!("Total transactions: {}", analysis.summary.total_transactions);
    println!("Success rate: {:.2}%", 
        analysis.summary.successful_transactions as f64 / 
        analysis.summary.total_transactions as f64 * 100.0
    );
    println!("Total gas used: {}", analysis.summary.total_gas_used);
    println!("Accounts touched: {}", analysis.summary.accounts_touched);
    println!("Contracts created: {}", analysis.summary.contracts_created);
    
    println!("\nTop Gas Users:");
    for (address, gas) in analysis.account_analysis.top_gas_users.iter().take(5) {
        println!("  {}: {} gas", address, gas);
    }
    
    println!("\nStorage Intensive Contracts:");
    for (address, ops) in analysis.storage_analysis.storage_intensive.iter().take(5) {
        println!("  {}: {} operations", address, ops);
    }
    
    Ok(())
}
```

### Assignment 2: Execution Outcome Differ

Create a system to compare execution outcomes:

```rust
use std::collections::{HashMap, HashSet, BTreeMap};
use std::fmt::Write;

/// Compares execution outcomes to find differences
pub struct ExecutionOutcomeDiffer {
    /// Configuration for diffing
    config: DiffConfig,
    /// Formatter for output
    formatter: Box<dyn DiffFormatter>,
}

#[derive(Debug, Clone)]
pub struct DiffConfig {
    /// Include storage changes in diff
    pub include_storage: bool,
    /// Include bytecode in diff
    pub include_bytecode: bool,
    /// Show only differences (not common elements)
    pub only_differences: bool,
    /// Maximum storage slots to show per account
    pub max_storage_slots: usize,
}

/// Represents differences between two execution outcomes
#[derive(Debug, Clone)]
pub struct ExecutionDiff {
    /// Block range differences
    pub block_range: BlockRangeDiff,
    /// Account differences
    pub account_diffs: HashMap<Address, AccountDiff>,
    /// Receipt differences
    pub receipt_diffs: Vec<ReceiptsDiff>,
    /// Contract deployment differences
    pub contract_diffs: HashMap<B256, ContractDiff>,
    /// Summary statistics
    pub summary: DiffSummary,
}

#[derive(Debug, Clone)]
pub struct BlockRangeDiff {
    pub left_range: (u64, u64),
    pub right_range: (u64, u64),
    pub overlap: Option<(u64, u64)>,
}

#[derive(Debug, Clone)]
pub struct AccountDiff {
    pub address: Address,
    pub nonce: ValueDiff<u64>,
    pub balance: ValueDiff<U256>,
    pub code_hash: ValueDiff<B256>,
    pub storage: HashMap<U256, ValueDiff<U256>>,
    pub status: StatusDiff,
}

#[derive(Debug, Clone)]
pub enum ValueDiff<T> {
    Same(T),
    Different { left: Option<T>, right: Option<T> },
}

#[derive(Debug, Clone)]
pub enum StatusDiff {
    Same(AccountStatus),
    Different { left: AccountStatus, right: AccountStatus },
}

#[derive(Debug, Clone)]
pub enum AccountStatus {
    DoesNotExist,
    Exists,
    Created,
    Destroyed,
}

#[derive(Debug, Clone)]
pub struct ReceiptsDiff {
    pub block_number: u64,
    pub transaction_index: usize,
    pub success: ValueDiff<bool>,
    pub gas_used: ValueDiff<u64>,
    pub logs_count: ValueDiff<usize>,
}

#[derive(Debug, Clone)]
pub struct ContractDiff {
    pub code_hash: B256,
    pub size: ValueDiff<usize>,
    pub exists_in_left: bool,
    pub exists_in_right: bool,
}

#[derive(Debug, Clone, Default)]
pub struct DiffSummary {
    pub total_account_diffs: usize,
    pub accounts_only_in_left: usize,
    pub accounts_only_in_right: usize,
    pub nonce_differences: usize,
    pub balance_differences: usize,
    pub storage_differences: usize,
    pub receipt_differences: usize,
    pub contract_differences: usize,
}

/// Formats diffs for output
pub trait DiffFormatter: Send + Sync {
    fn format(&self, diff: &ExecutionDiff) -> String;
}

/// Human-readable diff formatter
pub struct HumanReadableFormatter {
    pub color: bool,
}

impl DiffFormatter for HumanReadableFormatter {
    fn format(&self, diff: &ExecutionDiff) -> String {
        let mut output = String::new();
        
        writeln!(&mut output, "Execution Outcome Diff").unwrap();
        writeln!(&mut output, "======================").unwrap();
        
        // Block range
        writeln!(&mut output, "\nBlock Ranges:").unwrap();
        writeln!(&mut output, "  Left:  {} - {}", 
            diff.block_range.left_range.0, 
            diff.block_range.left_range.1
        ).unwrap();
        writeln!(&mut output, "  Right: {} - {}", 
            diff.block_range.right_range.0, 
            diff.block_range.right_range.1
        ).unwrap();
        
        // Summary
        writeln!(&mut output, "\nSummary:").unwrap();
        writeln!(&mut output, "  Total account differences: {}", 
            diff.summary.total_account_diffs
        ).unwrap();
        writeln!(&mut output, "  Accounts only in left: {}", 
            diff.summary.accounts_only_in_left
        ).unwrap();
        writeln!(&mut output, "  Accounts only in right: {}", 
            diff.summary.accounts_only_in_right
        ).unwrap();
        
        // Account differences
        if !diff.account_diffs.is_empty() {
            writeln!(&mut output, "\nAccount Differences:").unwrap();
            
            for (address, account_diff) in &diff.account_diffs {
                writeln!(&mut output, "\n  Address: {}", address).unwrap();
                
                match &account_diff.nonce {
                    ValueDiff::Different { left, right } => {
                        writeln!(&mut output, "    Nonce: {} -> {}", 
                            left.unwrap_or(0), 
                            right.unwrap_or(0)
                        ).unwrap();
                    }
                    _ => {}
                }
                
                match &account_diff.balance {
                    ValueDiff::Different { left, right } => {
                        writeln!(&mut output, "    Balance: {} -> {}", 
                            left.unwrap_or_default(), 
                            right.unwrap_or_default()
                        ).unwrap();
                    }
                    _ => {}
                }
                
                if !account_diff.storage.is_empty() {
                    writeln!(&mut output, "    Storage changes: {}", 
                        account_diff.storage.len()
                    ).unwrap();
                }
            }
        }
        
        output
    }
}

/// JSON diff formatter
pub struct JsonFormatter;

impl DiffFormatter for JsonFormatter {
    fn format(&self, diff: &ExecutionDiff) -> String {
        serde_json::to_string_pretty(diff).unwrap_or_default()
    }
}

impl ExecutionOutcomeDiffer {
    pub fn new(config: DiffConfig) -> Self {
        Self {
            config,
            formatter: Box::new(HumanReadableFormatter { color: false }),
        }
    }
    
    pub fn with_formatter(mut self, formatter: Box<dyn DiffFormatter>) -> Self {
        self.formatter = formatter;
        self
    }
    
    /// Compare two execution outcomes
    pub fn diff(
        &self,
        left: &ExecutionOutcome,
        right: &ExecutionOutcome,
    ) -> ExecutionDiff {
        let mut diff = ExecutionDiff {
            block_range: self.diff_block_ranges(left, right),
            account_diffs: HashMap::new(),
            receipt_diffs: Vec::new(),
            contract_diffs: HashMap::new(),
            summary: DiffSummary::default(),
        };
        
        // Diff accounts
        self.diff_accounts(left, right, &mut diff);
        
        // Diff receipts
        self.diff_receipts(left, right, &mut diff);
        
        // Diff contracts
        if self.config.include_bytecode {
            self.diff_contracts(left, right, &mut diff);
        }
        
        // Update summary
        self.update_summary(&mut diff);
        
        diff
    }
    
    /// Diff block ranges
    fn diff_block_ranges(&self, left: &ExecutionOutcome, right: &ExecutionOutcome) -> BlockRangeDiff {
        let left_end = left.first_block + left.receipts.len() as u64 - 1;
        let right_end = right.first_block + right.receipts.len() as u64 - 1;
        
        let overlap = if left.first_block <= right_end && right.first_block <= left_end {
            Some((
                left.first_block.max(right.first_block),
                left_end.min(right_end),
            ))
        } else {
            None
        };
        
        BlockRangeDiff {
            left_range: (left.first_block, left_end),
            right_range: (right.first_block, right_end),
            overlap,
        }
    }
    
    /// Diff accounts between outcomes
    fn diff_accounts(
        &self,
        left: &ExecutionOutcome,
        right: &ExecutionOutcome,
        diff: &mut ExecutionDiff,
    ) {
        let mut all_addresses = HashSet::new();
        
        // Collect all addresses
        for (addr, _) in left.bundle_accounts_iter() {
            all_addresses.insert(addr);
        }
        for (addr, _) in right.bundle_accounts_iter() {
            all_addresses.insert(addr);
        }
        
        // Compare each address
        for address in all_addresses {
            let left_account = left.bundle.account(&address);
            let right_account = right.bundle.account(&address);
            
            let account_diff = self.diff_single_account(
                address,
                left_account,
                right_account,
            );
            
            if self.config.only_differences && !account_diff.has_differences() {
                continue;
            }
            
            diff.account_diffs.insert(address, account_diff);
        }
    }
    
    /// Diff a single account
    fn diff_single_account(
        &self,
        address: Address,
        left: Option<&BundleAccount>,
        right: Option<&BundleAccount>,
    ) -> AccountDiff {
        let mut account_diff = AccountDiff {
            address,
            nonce: ValueDiff::Same(0),
            balance: ValueDiff::Same(U256::ZERO),
            code_hash: ValueDiff::Same(KECCAK_EMPTY),
            storage: HashMap::new(),
            status: StatusDiff::Same(AccountStatus::DoesNotExist),
        };
        
        // Compare basic fields
        match (left, right) {
            (None, None) => {
                // Both don't exist
            }
            (None, Some(right_acc)) => {
                // Only exists in right
                if let Some(info) = &right_acc.info {
                    account_diff.nonce = ValueDiff::Different { 
                        left: None, 
                        right: Some(info.nonce) 
                    };
                    account_diff.balance = ValueDiff::Different { 
                        left: None, 
                        right: Some(info.balance) 
                    };
                    account_diff.code_hash = ValueDiff::Different { 
                        left: None, 
                        right: Some(info.code_hash) 
                    };
                }
                account_diff.status = StatusDiff::Different {
                    left: AccountStatus::DoesNotExist,
                    right: AccountStatus::Created,
                };
            }
            (Some(left_acc), None) => {
                // Only exists in left
                if let Some(info) = &left_acc.info {
                    account_diff.nonce = ValueDiff::Different { 
                        left: Some(info.nonce), 
                        right: None 
                    };
                    account_diff.balance = ValueDiff::Different { 
                        left: Some(info.balance), 
                        right: None 
                    };
                    account_diff.code_hash = ValueDiff::Different { 
                        left: Some(info.code_hash), 
                        right: None 
                    };
                }
                account_diff.status = StatusDiff::Different {
                    left: AccountStatus::Destroyed,
                    right: AccountStatus::DoesNotExist,
                };
            }
            (Some(left_acc), Some(right_acc)) => {
                // Exists in both - compare fields
                match (&left_acc.info, &right_acc.info) {
                    (Some(left_info), Some(right_info)) => {
                        if left_info.nonce != right_info.nonce {
                            account_diff.nonce = ValueDiff::Different {
                                left: Some(left_info.nonce),
                                right: Some(right_info.nonce),
                            };
                        } else {
                            account_diff.nonce = ValueDiff::Same(left_info.nonce);
                        }
                        
                        if left_info.balance != right_info.balance {
                            account_diff.balance = ValueDiff::Different {
                                left: Some(left_info.balance),
                                right: Some(right_info.balance),
                            };
                        } else {
                            account_diff.balance = ValueDiff::Same(left_info.balance);
                        }
                        
                        if left_info.code_hash != right_info.code_hash {
                            account_diff.code_hash = ValueDiff::Different {
                                left: Some(left_info.code_hash),
                                right: Some(right_info.code_hash),
                            };
                        } else {
                            account_diff.code_hash = ValueDiff::Same(left_info.code_hash);
                        }
                    }
                    _ => {}
                }
                
                // Compare storage if requested
                if self.config.include_storage {
                    account_diff.storage = self.diff_storage(left_acc, right_acc);
                }
            }
        }
        
        account_diff
    }
    
    /// Diff storage between accounts
    fn diff_storage(
        &self,
        left: &BundleAccount,
        right: &BundleAccount,
    ) -> HashMap<U256, ValueDiff<U256>> {
        let mut storage_diff = HashMap::new();
        let mut all_slots = HashSet::new();
        
        // Collect all storage slots
        for slot in left.storage.keys() {
            all_slots.insert(*slot);
        }
        for slot in right.storage.keys() {
            all_slots.insert(*slot);
        }
        
        // Compare each slot
        let mut slot_count = 0;
        for slot in all_slots {
            if slot_count >= self.config.max_storage_slots {
                break;
            }
            
            let left_value = left.storage.get(&slot).map(|s| s.present_value);
            let right_value = right.storage.get(&slot).map(|s| s.present_value);
            
            match (left_value, right_value) {
                (Some(left_val), Some(right_val)) if left_val == right_val => {
                    if !self.config.only_differences {
                        storage_diff.insert(slot, ValueDiff::Same(left_val));
                    }
                }
                _ => {
                    storage_diff.insert(slot, ValueDiff::Different {
                        left: left_value,
                        right: right_value,
                    });
                    slot_count += 1;
                }
            }
        }
        
        storage_diff
    }
    
    /// Update diff summary statistics
    fn update_summary(&self, diff: &mut ExecutionDiff) {
        diff.summary.total_account_diffs = diff.account_diffs.len();
        
        for (_, account_diff) in &diff.account_diffs {
            match &account_diff.status {
                StatusDiff::Different { left, right } => {
                    match (left, right) {
                        (AccountStatus::DoesNotExist, _) => {
                            diff.summary.accounts_only_in_right += 1;
                        }
                        (_, AccountStatus::DoesNotExist) => {
                            diff.summary.accounts_only_in_left += 1;
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
            
            if matches!(account_diff.nonce, ValueDiff::Different { .. }) {
                diff.summary.nonce_differences += 1;
            }
            
            if matches!(account_diff.balance, ValueDiff::Different { .. }) {
                diff.summary.balance_differences += 1;
            }
            
            diff.summary.storage_differences += account_diff.storage.len();
        }
        
        diff.summary.receipt_differences = diff.receipt_diffs.len();
        diff.summary.contract_differences = diff.contract_diffs.len();
    }
}

impl AccountDiff {
    /// Check if this account has any differences
    fn has_differences(&self) -> bool {
        matches!(self.nonce, ValueDiff::Different { .. }) ||
        matches!(self.balance, ValueDiff::Different { .. }) ||
        matches!(self.code_hash, ValueDiff::Different { .. }) ||
        matches!(self.status, StatusDiff::Different { .. }) ||
        !self.storage.is_empty()
    }
}

// Usage example
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = DiffConfig {
        include_storage: true,
        include_bytecode: false,
        only_differences: true,
        max_storage_slots: 10,
    };
    
    let differ = ExecutionOutcomeDiffer::new(config)
        .with_formatter(Box::new(HumanReadableFormatter { color: true }));
    
    // Get two execution outcomes to compare
    let outcome1 = get_execution_outcome_1().await?;
    let outcome2 = get_execution_outcome_2().await?;
    
    // Calculate diff
    let diff = differ.diff(&outcome1, &outcome2);
    
    // Format and print
    let formatted = differ.formatter.format(&diff);
    println!("{}", formatted);
    
    // Can also use JSON formatter
    let json_differ = ExecutionOutcomeDiffer::new(config)
        .with_formatter(Box::new(JsonFormatter));
    let json_output = json_differ.formatter.format(&diff);
    
    // Save to file
    std::fs::write("execution_diff.json", json_output)?;
    
    Ok(())
}
```

### Assignment 3: Execution Outcome Validator

Implement a comprehensive validation system:

```rust
use std::collections::{HashMap, HashSet};

/// Validates execution outcomes for correctness
pub struct ExecutionOutcomeValidator {
    /// Validation rules to apply
    rules: Vec<Box<dyn ValidationRule>>,
    /// Configuration
    config: ValidationConfig,
    /// Cache for expensive computations
    cache: ValidationCache,
}

#[derive(Debug, Clone)]
pub struct ValidationConfig {
    /// Validate receipts match execution
    pub validate_receipts: bool,
    /// Validate gas accounting
    pub validate_gas: bool,
    /// Validate state transitions
    pub validate_state: bool,
    /// Validate storage roots
    pub validate_storage_roots: bool,
    /// Maximum violations before stopping
    pub max_violations: usize,
}

/// A validation rule that can be applied to execution outcomes
pub trait ValidationRule: Send + Sync {
    fn validate(
        &self,
        outcome: &ExecutionOutcome,
        context: &ValidationContext,
    ) -> Vec<ValidationViolation>;
    
    fn name(&self) -> &'static str;
}

pub struct ValidationContext {
    /// Previous state for validation
    pub pre_state: Box<dyn StateProvider>,
    /// Block being validated
    pub block: Block,
    /// Chain specification
    pub chain_spec: Arc<ChainSpec>,
}

#[derive(Debug, Clone)]
pub struct ValidationViolation {
    pub rule: String,
    pub severity: Severity,
    pub message: String,
    pub details: HashMap<String, String>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Severity {
    Info,
    Warning,
    Error,
    Critical,
}

#[derive(Debug)]
pub struct ValidationResult {
    pub valid: bool,
    pub violations: Vec<ValidationViolation>,
    pub summary: ValidationSummary,
}

#[derive(Debug, Default)]
pub struct ValidationSummary {
    pub total_checks: usize,
    pub passed_checks: usize,
    pub info_count: usize,
    pub warning_count: usize,
    pub error_count: usize,
    pub critical_count: usize,
}

/// Validates gas accounting
pub struct GasValidationRule;

impl ValidationRule for GasValidationRule {
    fn validate(
        &self,
        outcome: &ExecutionOutcome,
        context: &ValidationContext,
    ) -> Vec<ValidationViolation> {
        let mut violations = Vec::new();
        
        // Validate cumulative gas in receipts
        for (block_idx, block_receipts) in outcome.receipts.iter().enumerate() {
            let mut expected_cumulative = 0u64;
            
            for (tx_idx, receipt) in block_receipts.iter().enumerate() {
                let gas_used = if tx_idx == 0 {
                    receipt.cumulative_gas_used
                } else {
                    receipt.cumulative_gas_used - block_receipts[tx_idx - 1].cumulative_gas_used
                };
                
                expected_cumulative += gas_used;
                
                if receipt.cumulative_gas_used != expected_cumulative {
                    violations.push(ValidationViolation {
                        rule: self.name().to_string(),
                        severity: Severity::Error,
                        message: format!(
                            "Cumulative gas mismatch at block {} tx {}",
                            outcome.first_block + block_idx as u64,
                            tx_idx
                        ),
                        details: HashMap::from([
                            ("expected".to_string(), expected_cumulative.to_string()),
                            ("actual".to_string(), receipt.cumulative_gas_used.to_string()),
                        ]),
                    });
                }
                
                // Check gas limit
                if gas_used > context.block.gas_limit {
                    violations.push(ValidationViolation {
                        rule: self.name().to_string(),
                        severity: Severity::Critical,
                        message: format!(
                            "Transaction {} used more gas than block limit",
                            tx_idx
                        ),
                        details: HashMap::from([
                            ("gas_used".to_string(), gas_used.to_string()),
                            ("gas_limit".to_string(), context.block.gas_limit.to_string()),
                        ]),
                    });
                }
            }
            
            // Check total block gas
            if expected_cumulative > context.block.gas_limit {
                violations.push(ValidationViolation {
                    rule: self.name().to_string(),
                    severity: Severity::Critical,
                    message: "Block gas exceeds limit".to_string(),
                    details: HashMap::from([
                        ("total_gas".to_string(), expected_cumulative.to_string()),
                        ("block_limit".to_string(), context.block.gas_limit.to_string()),
                    ]),
                });
            }
        }
        
        violations
    }
    
    fn name(&self) -> &'static str {
        "GasValidation"
    }
}

/// Validates state transitions
pub struct StateTransitionRule;

impl ValidationRule for StateTransitionRule {
    fn validate(
        &self,
        outcome: &ExecutionOutcome,
        context: &ValidationContext,
    ) -> Vec<ValidationViolation> {
        let mut violations = Vec::new();
        
        // Check account state transitions
        for (address, bundle_account) in outcome.bundle_accounts_iter() {
            // Validate nonce increments
            if let (Some(original), Some(current)) = (&bundle_account.original_info, &bundle_account.info) {
                if current.nonce < original.nonce {
                    violations.push(ValidationViolation {
                        rule: self.name().to_string(),
                        severity: Severity::Critical,
                        message: format!("Nonce decreased for account {}", address),
                        details: HashMap::from([
                            ("original_nonce".to_string(), original.nonce.to_string()),
                            ("current_nonce".to_string(), current.nonce.to_string()),
                        ]),
                    });
                }
            }
            
            // Validate balance changes
            if bundle_account.info.is_some() {
                let info = bundle_account.info.as_ref().unwrap();
                
                // Check for negative balance (should be impossible)
                if info.balance == U256::MAX {
                    violations.push(ValidationViolation {
                        rule: self.name().to_string(),
                        severity: Severity::Critical,
                        message: format!("Possible balance underflow for account {}", address),
                        details: HashMap::new(),
                    });
                }
            }
            
            // Validate storage transitions
            for (slot, storage_slot) in &bundle_account.storage {
                // Check for invalid storage patterns
                if storage_slot.present_value == U256::MAX {
                    violations.push(ValidationViolation {
                        rule: self.name().to_string(),
                        severity: Severity::Warning,
                        message: format!(
                            "Suspicious storage value (MAX) at {} slot {}",
                            address, slot
                        ),
                        details: HashMap::new(),
                    });
                }
            }
        }
        
        violations
    }
    
    fn name(&self) -> &'static str {
        "StateTransition"
    }
}

/// Validates receipts match state changes
pub struct ReceiptConsistencyRule;

impl ValidationRule for ReceiptConsistencyRule {
    fn validate(
        &self,
        outcome: &ExecutionOutcome,
        context: &ValidationContext,
    ) -> Vec<ValidationViolation> {
        let mut violations = Vec::new();
        
        // Check receipt count matches transaction count
        for (block_idx, block_receipts) in outcome.receipts.iter().enumerate() {
            let block_num = outcome.first_block + block_idx as u64;
            
            // Would need transaction count from context
            // For now, just validate receipts internally
            
            // Check for duplicate contract addresses in receipts
            let mut contract_addresses = HashSet::new();
            for receipt in block_receipts {
                if let Some(contract_addr) = receipt.contract_address {
                    if !contract_addresses.insert(contract_addr) {
                        violations.push(ValidationViolation {
                            rule: self.name().to_string(),
                            severity: Severity::Error,
                            message: format!(
                                "Duplicate contract address {} in block {}",
                                contract_addr, block_num
                            ),
                            details: HashMap::new(),
                        });
                    }
                    
                    // Verify contract exists in bundle
                    if outcome.bundle.account(&contract_addr).is_none() {
                        violations.push(ValidationViolation {
                            rule: self.name().to_string(),
                            severity: Severity::Error,
                            message: format!(
                                "Contract {} in receipt but not in state",
                                contract_addr
                            ),
                            details: HashMap::new(),
                        });
                    }
                }
            }
        }
        
        violations
    }
    
    fn name(&self) -> &'static str {
        "ReceiptConsistency"
    }
}

/// Validates contract deployments
pub struct ContractDeploymentRule;

impl ValidationRule for ContractDeploymentRule {
    fn validate(
        &self,
        outcome: &ExecutionOutcome,
        context: &ValidationContext,
    ) -> Vec<ValidationViolation> {
        let mut violations = Vec::new();
        
        // Check all deployed contracts
        for (address, account) in outcome.bundle_accounts_iter() {
            if account.is_created() && account.info.is_some() {
                let info = account.info.as_ref().unwrap();
                
                // Check contract has code
                if info.code_hash == KECCAK_EMPTY {
                    violations.push(ValidationViolation {
                        rule: self.name().to_string(),
                        severity: Severity::Warning,
                        message: format!("Contract {} deployed with empty code", address),
                        details: HashMap::new(),
                    });
                } else {
                    // Verify bytecode exists
                    if outcome.bytecode(&info.code_hash).is_none() {
                        violations.push(ValidationViolation {
                            rule: self.name().to_string(),
                            severity: Severity::Error,
                            message: format!(
                                "Contract {} references missing bytecode {}",
                                address, info.code_hash
                            ),
                            details: HashMap::new(),
                        });
                    }
                }
                
                // Check nonce is 1 for new contracts
                if info.nonce != 1 {
                    violations.push(ValidationViolation {
                        rule: self.name().to_string(),
                        severity: Severity::Warning,
                        message: format!(
                            "New contract {} has unexpected nonce {}",
                            address, info.nonce
                        ),
                        details: HashMap::new(),
                    });
                }
            }
        }
        
        violations
    }
    
    fn name(&self) -> &'static str {
        "ContractDeployment"
    }
}

pub struct ValidationCache {
    /// Cached computation results
    results: HashMap<B256, Vec<ValidationViolation>>,
}

impl ExecutionOutcomeValidator {
    pub fn new(config: ValidationConfig) -> Self {
        let mut validator = Self {
            rules: Vec::new(),
            config,
            cache: ValidationCache {
                results: HashMap::new(),
            },
        };
        
        // Add default rules
        if validator.config.validate_gas {
            validator.add_rule(Box::new(GasValidationRule));
        }
        if validator.config.validate_state {
            validator.add_rule(Box::new(StateTransitionRule));
        }
        if validator.config.validate_receipts {
            validator.add_rule(Box::new(ReceiptConsistencyRule));
        }
        validator.add_rule(Box::new(ContractDeploymentRule));
        
        validator
    }
    
    pub fn add_rule(&mut self, rule: Box<dyn ValidationRule>) {
        self.rules.push(rule);
    }
    
    /// Validate an execution outcome
    pub fn validate(
        &mut self,
        outcome: &ExecutionOutcome,
        context: ValidationContext,
    ) -> ValidationResult {
        let mut all_violations = Vec::new();
        let mut summary = ValidationSummary::default();
        
        // Run each rule
        for rule in &self.rules {
            summary.total_checks += 1;
            
            let violations = rule.validate(outcome, &context);
            
            if violations.is_empty() {
                summary.passed_checks += 1;
            } else {
                // Count by severity
                for violation in &violations {
                    match violation.severity {
                        Severity::Info => summary.info_count += 1,
                        Severity::Warning => summary.warning_count += 1,
                        Severity::Error => summary.error_count += 1,
                        Severity::Critical => summary.critical_count += 1,
                    }
                }
                
                all_violations.extend(violations);
            }
            
            // Stop if too many violations
            if all_violations.len() >= self.config.max_violations {
                break;
            }
        }
        
        // Sort violations by severity
        all_violations.sort_by_key(|v| std::cmp::Reverse(v.severity));
        
        let valid = summary.error_count == 0 && summary.critical_count == 0;
        
        ValidationResult {
            valid,
            violations: all_violations,
            summary,
        }
    }
    
    /// Validate with custom rules
    pub fn validate_with_rules(
        &mut self,
        outcome: &ExecutionOutcome,
        context: ValidationContext,
        custom_rules: Vec<Box<dyn ValidationRule>>,
    ) -> ValidationResult {
        // Temporarily add custom rules
        let original_len = self.rules.len();
        self.rules.extend(custom_rules);
        
        let result = self.validate(outcome, context);
        
        // Remove custom rules
        self.rules.truncate(original_len);
        
        result
    }
}

// Custom validation rule example
pub struct EIP1559ValidationRule;

impl ValidationRule for EIP1559ValidationRule {
    fn validate(
        &self,
        outcome: &ExecutionOutcome,
        context: &ValidationContext,
    ) -> Vec<ValidationViolation> {
        let mut violations = Vec::new();
        
        // Validate EIP-1559 specific rules
        if context.chain_spec.is_london_active_at(context.block.number) {
            // Check base fee is present
            if context.block.base_fee_per_gas.is_none() {
                violations.push(ValidationViolation {
                    rule: self.name().to_string(),
                    severity: Severity::Critical,
                    message: "Missing base fee in post-London block".to_string(),
                    details: HashMap::from([
                        ("block_number".to_string(), context.block.number.to_string()),
                    ]),
                });
            }
            
            // Validate burnt fees
            // Would need to check that base_fee * gas_used worth of ETH was burned
        }
        
        violations
    }
    
    fn name(&self) -> &'static str {
        "EIP1559Validation"
    }
}

// Usage example
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = ValidationConfig {
        validate_receipts: true,
        validate_gas: true,
        validate_state: true,
        validate_storage_roots: false, // Expensive
        max_violations: 100,
    };
    
    let mut validator = ExecutionOutcomeValidator::new(config);
    
    // Add custom rule
    validator.add_rule(Box::new(EIP1559ValidationRule));
    
    // Get execution outcome and context
    let outcome = get_execution_outcome().await?;
    let context = ValidationContext {
        pre_state: Box::new(get_state_provider()),
        block: get_block().await?,
        chain_spec: Arc::new(ChainSpec::mainnet()),
    };
    
    // Validate
    let result = validator.validate(&outcome, context);
    
    // Print results
    println!("Validation Result: {}", if result.valid { "PASS" } else { "FAIL" });
    println!("Summary:");
    println!("  Total checks: {}", result.summary.total_checks);
    println!("  Passed: {}", result.summary.passed_checks);
    println!("  Critical: {}", result.summary.critical_count);
    println!("  Errors: {}", result.summary.error_count);
    println!("  Warnings: {}", result.summary.warning_count);
    
    if !result.violations.is_empty() {
        println!("\nViolations:");
        for violation in result.violations.iter().take(10) {
            println!("  [{:?}] {}: {}", 
                violation.severity,
                violation.rule,
                violation.message
            );
            for (key, value) in &violation.details {
                println!("    {}: {}", key, value);
            }
        }
    }
    
    Ok(())
}
```

## Questions to Ponder

### 1. Why does Reth use BundleState instead of directly modifying the database during execution?

### 2. How do execution outcomes enable efficient chain reorganizations?

### 3. What are the trade-offs between storing full execution outcomes vs. just the final state?

## Assignment Answers

### Answer 1: Execution Outcome Analyzer

The analyzer provides comprehensive insights into execution outcomes:

1. **Multi-Level Analysis**: Separates concerns into summary, account, storage, deployment, and gas analysis
2. **Pattern Detection**: Identifies factories, hot storage slots, and gas usage patterns
3. **Configurable Depth**: Can adjust analysis depth based on performance requirements
4. **Caching**: Stores results for frequently analyzed outcomes

Key insights from the implementation:
- Most active accounts are often DEX routers and popular tokens
- Storage hotspots reveal inefficient contract patterns
- Factory detection helps identify deployment patterns
- Gas analysis can reveal network congestion periods

### Answer 2: Execution Outcome Differ

The differ enables detailed comparison of execution outcomes:

1. **Flexible Formatting**: Supports human-readable and JSON output formats
2. **Configurable Granularity**: Can include/exclude storage and bytecode differences
3. **Smart Diffing**: Only shows actual differences when configured
4. **Summary Statistics**: Provides high-level overview of differences

Use cases:
- Comparing execution across different client implementations
- Debugging consensus issues
- Analyzing the impact of configuration changes
- Verifying deterministic execution

### Answer 3: Execution Outcome Validator

The validation system ensures execution correctness:

1. **Modular Rules**: Each validation concern is a separate rule
2. **Severity Levels**: Distinguishes between info, warnings, errors, and critical issues
3. **Extensible**: Easy to add custom validation rules
4. **Performance**: Caches expensive computations

Critical validations:
- Gas accounting must be exact
- Nonces must never decrease
- Cumulative gas must be calculated correctly
- Contract deployments must have corresponding bytecode
- State transitions must follow protocol rules