# Lesson 92: Security Considerations

*"Security is not a product, but a process." - Bruce Schneier*

## Overview
Security considerations encompass the design and implementation of protective measures against threats and vulnerabilities. This lesson covers security architecture, threat modeling, and defensive programming practices.

## Key Concepts
- **Threat Modeling**: Identifying and analyzing potential security threats
- **Defense in Depth**: Multiple layers of security controls
- **Secure Coding**: Programming practices that prevent vulnerabilities
- **Cryptographic Security**: Proper use of cryptographic primitives

## Why Security Matters in Blockchain (Like Protecting a Bank)

Think of blockchain security like protecting a bank. Just as a bank has multiple layers of security, blockchain systems need comprehensive protection:

- **Physical Security**: Like bank vaults and guards, blockchain nodes need secure infrastructure
- **Network Security**: Like bank alarms and surveillance, blockchain networks need monitoring and intrusion detection
- **Cryptographic Security**: Like bank safes and encryption, blockchain data needs mathematical protection
- **Human Security**: Like bank employee training, blockchain developers need security awareness

From Reth's actual network security implementation, we see these principles in action:

```rust
// From crates/net/network/src/manager.rs - Real Reth security patterns
impl<N: NodeTypes> NetworkManager<N> {
    /// Security-first connection handling
    fn handle_peer_connection(&mut self, peer_id: PeerId, connection: Connection) -> Result<(), NetworkError> {
        // WHY: First line of defense - validate peer identity
        // Like checking ID at bank entrance
        if !self.is_peer_trusted(&peer_id) {
            warn!("Untrusted peer attempted connection: {}", peer_id);
            return Err(NetworkError::UntrustedPeer);
        }
        
        // WHY: Rate limiting prevents DoS attacks
        // Like limiting how many people can enter bank at once
        if self.connection_rate_limiter.is_exceeded(&peer_id) {
            warn!("Connection rate limit exceeded for peer: {}", peer_id);
            return Err(NetworkError::RateLimitExceeded);
        }
        
        // WHY: Connection validation ensures protocol compliance
        // Like verifying legitimate bank business
        self.validate_connection_parameters(&connection)?;
        
        // WHY: Peer reputation system prevents repeat offenders
        // Like bank's customer history system
        let reputation = self.peer_reputation.get_reputation(&peer_id);
        if reputation < MINIMUM_PEER_REPUTATION {
            warn!("Low reputation peer rejected: {} (score: {})", peer_id, reputation);
            return Err(NetworkError::LowReputationPeer);
        }
        
        // WHY: Successful connections are monitored
        // Like security cameras recording all activities
        self.security_monitor.log_connection_established(&peer_id);
        
        Ok(())
    }
}

## Real-World Security Patterns in Blockchain

### 1. Threat Modeling (Like Home Security Assessment)

When securing your home, you think about different threats: burglars, fire, flood. Similarly, blockchain threat modeling identifies potential attacks:

```rust
// Blockchain threat assessment - like a home security evaluation
pub struct BlockchainThreatModel {
    // Like worrying about burglars
    network_attacks: Vec<NetworkThreat>,
    // Like worrying about fire
    consensus_attacks: Vec<ConsensusAttack>,
    // Like worrying about data theft
    privacy_attacks: Vec<PrivacyAttack>,
}

impl BlockchainThreatModel {
    pub fn assess_node_security(&self, node_config: &NodeConfig) -> SecurityRisk {
        let mut risk_score = 0.0;
        
        // WHY: Different node configurations have different risk profiles
        // Like how a ground floor apartment has different risks than a penthouse
        
        // Network exposure risk
        if node_config.rpc_enabled {
            risk_score += 0.3; // Public RPC increases attack surface
        }
        
        // Consensus participation risk
        if node_config.is_validator {
            risk_score += 0.4; // Validators are high-value targets
        }
        
        // Data storage risk
        if node_config.stores_full_history {
            risk_score += 0.2; // More data = more attractive target
        }
        
        // Network connectivity risk
        match node_config.network_exposure {
            NetworkExposure::Public => risk_score += 0.5,
            NetworkExposure::Private => risk_score += 0.1,
            NetworkExposure::VPN => risk_score += 0.2,
        }
        
        SecurityRisk::from_score(risk_score)
    }
}
```

### 2. Defense in Depth (Like Castle Security)

Medieval castles had multiple layers of defense: moats, walls, towers, guards. Blockchain security works similarly:

```rust
// Multi-layered security like a medieval castle
pub struct DefenseInDepthManager {
    // First line of defense - like castle moat
    network_firewall: NetworkFirewall,
    // Second line - like castle walls
    protocol_validation: ProtocolValidator,
    // Third line - like castle towers
    intrusion_detection: IntrusionDetectionSystem,
    // Final line - like castle guards
    access_control: AccessControlSystem,
}

impl DefenseInDepthManager {
    pub async fn process_incoming_request(&self, request: &Request) -> Result<Response, SecurityError> {
        // Layer 1: Network-level filtering (the moat)
        // WHY: Block obviously malicious traffic before it reaches our system
        if !self.network_firewall.is_allowed(&request.source_ip) {
            return Err(SecurityError::NetworkBlocked);
        }
        
        // Layer 2: Protocol validation (the walls)
        // WHY: Ensure request follows proper protocol format
        if !self.protocol_validation.is_valid_format(&request.data) {
            return Err(SecurityError::InvalidProtocol);
        }
        
        // Layer 3: Behavioral analysis (the towers)
        // WHY: Detect suspicious patterns that might indicate attack
        if self.intrusion_detection.is_suspicious(&request) {
            return Err(SecurityError::SuspiciousBehavior);
        }
        
        // Layer 4: Access control (the guards)
        // WHY: Final check - is this request authorized?
        if !self.access_control.is_authorized(&request) {
            return Err(SecurityError::AccessDenied);
        }
        
        // If we get here, the request has passed all security layers
        Ok(self.process_safe_request(request).await?)
    }
}
```

### 3. Cryptographic Security (Like Bank Vault Technology)

Just as bank vaults use the latest locking technology, blockchain systems need strong cryptography:

```rust
// Cryptographic security like bank vault technology
pub struct CryptographicSecurity {
    // Like vault's combination lock
    signature_verifier: SignatureVerifier,
    // Like vault's time lock
    hash_verifier: HashVerifier,
    // Like vault's biometric scanner
    key_management: KeyManagement,
}

impl CryptographicSecurity {
    pub fn verify_transaction_security(&self, tx: &Transaction) -> Result<(), CryptoError> {
        // WHY: Like checking if someone has the right combination
        // We need to verify the transaction was signed by the account owner
        if !self.signature_verifier.verify_signature(&tx.signature, &tx.hash, &tx.from) {
            return Err(CryptoError::InvalidSignature);
        }
        
        // WHY: Like checking if the vault's time lock is properly set
        // We need to ensure the transaction hash is mathematically correct
        let computed_hash = self.hash_verifier.compute_hash(&tx.data);
        if computed_hash != tx.hash {
            return Err(CryptoError::InvalidHash);
        }
        
        // WHY: Like checking if the biometric scanner recognizes the user
        // We need to verify the cryptographic keys are valid and not compromised
        if !self.key_management.is_key_valid(&tx.from, &tx.signature) {
            return Err(CryptoError::KeyCompromised);
        }
        
        Ok(())
    }
}
```

### 4. Common Security Pitfalls and How to Avoid Them

#### The "Unlocked Door" Problem (Input Validation)

**Wrong:**
```rust
// Dangerous - no input validation
pub fn process_peer_message(message: &[u8]) -> Result<(), Error> {
    // Directly processing untrusted input
    let command = message[0];
    let data = &message[1..];
    execute_command(command, data)
}
```

**Right:**
```rust
// Safe - proper input validation
pub fn process_peer_message(message: &[u8]) -> Result<(), Error> {
    // WHY: Always validate input from untrusted sources
    // Like checking ID before letting someone into your house
    
    if message.is_empty() {
        return Err(Error::EmptyMessage);
    }
    
    if message.len() > MAX_MESSAGE_SIZE {
        return Err(Error::MessageTooLarge);
    }
    
    let command = message[0];
    if !is_valid_command(command) {
        return Err(Error::InvalidCommand);
    }
    
    let data = &message[1..];
    if !is_valid_data_format(data) {
        return Err(Error::InvalidData);
    }
    
    execute_command(command, data)
}
```

#### The "Trusting Everyone" Problem (Authentication)

**Wrong:**
```rust
// Dangerous - no authentication
pub fn execute_admin_command(command: &str) -> Result<(), Error> {
    // Anyone can execute admin commands!
    match command {
        "shutdown" => shutdown_system(),
        "reset" => reset_database(),
        _ => Err(Error::UnknownCommand),
    }
}
```

**Right:**
```rust
// Safe - proper authentication
pub fn execute_admin_command(command: &str, auth_token: &str) -> Result<(), Error> {
    // WHY: Like checking if someone is actually a bank employee
    // before letting them access the vault
    
    if !self.auth_manager.is_admin_token_valid(auth_token) {
        return Err(Error::AuthenticationFailed);
    }
    
    // WHY: Even authenticated users should have limited permissions
    if !self.auth_manager.has_permission(auth_token, command) {
        return Err(Error::InsufficientPermissions);
    }
    
    // WHY: Log all admin actions for accountability
    self.audit_logger.log_admin_action(auth_token, command);
    
    match command {
        "shutdown" => shutdown_system(),
        "reset" => reset_database(),
        _ => Err(Error::UnknownCommand),
    }
}
```

#### The "Single Point of Failure" Problem (Key Management)

**Wrong:**
```rust
// Dangerous - single key stored in memory
pub struct UnsafeKeyManager {
    master_key: [u8; 32], // One key to rule them all!
}

impl UnsafeKeyManager {
    pub fn decrypt_data(&self, encrypted_data: &[u8]) -> Vec<u8> {
        // If this key is compromised, everything is compromised
        decrypt_with_key(encrypted_data, &self.master_key)
    }
}
```

**Right:**
```rust
// Safe - hierarchical key management with rotation
pub struct SecureKeyManager {
    // WHY: Like having multiple keys for different parts of the bank
    key_hierarchy: KeyHierarchy,
    // WHY: Like changing locks periodically
    key_rotation_schedule: KeyRotationSchedule,
    // WHY: Like having backup keys in a safe deposit box
    key_backup_system: KeyBackupSystem,
}

impl SecureKeyManager {
    pub fn decrypt_data(&self, encrypted_data: &[u8], key_id: &str) -> Result<Vec<u8>, CryptoError> {
        // WHY: Use specific keys for specific purposes
        let key = self.key_hierarchy.get_key(key_id)?;
        
        // WHY: Check if key needs rotation
        if self.key_rotation_schedule.needs_rotation(key_id) {
            self.schedule_key_rotation(key_id)?;
        }
        
        // WHY: Use the appropriate key for decryption
        decrypt_with_key(encrypted_data, &key)
    }
}
```

## Integration with Reth's Security Architecture

Understanding how these security patterns work in Reth's actual implementation:

```rust
// How Reth's NetworkManager implements security in practice
impl<N: NodeTypes> NetworkManager<N> {
    fn poll_network_security(&mut self, cx: &mut Context<'_>) -> Poll<()> {
        // WHY: Security monitoring runs continuously
        // Like security guards doing regular patrols
        
        // 1. Monitor peer reputation
        if let Poll::Ready(reputation_update) = self.peer_reputation.poll_unpin(cx) {
            if let Some(low_reputation_peer) = reputation_update.get_low_reputation_peer() {
                // WHY: Proactively disconnect problematic peers
                // Like asking troublesome customers to leave
                warn!("Disconnecting low reputation peer: {}", low_reputation_peer);
                self.disconnect_peer(&low_reputation_peer);
            }
        }
        
        // 2. Check connection limits
        if self.active_connections.len() > MAX_CONNECTIONS {
            // WHY: Prevent resource exhaustion attacks
            // Like fire codes limiting building occupancy
            let oldest_connection = self.active_connections.get_oldest();
            warn!("Connection limit exceeded, dropping oldest connection: {}", oldest_connection);
            self.disconnect_peer(&oldest_connection);
        }
        
        // 3. Monitor for suspicious patterns
        if let Poll::Ready(security_alert) = self.security_monitor.poll_unpin(cx) {
            match security_alert.threat_level {
                ThreatLevel::Critical => {
                    // WHY: Immediate response to critical threats
                    // Like bank alarm triggering immediate police response
                    error!("Critical security threat detected: {}", security_alert.description);
                    self.enter_security_lockdown();
                }
                ThreatLevel::High => {
                    // WHY: Heightened security measures
                    // Like bank increasing security after suspicious activity
                    warn!("High security threat detected: {}", security_alert.description);
                    self.increase_security_monitoring();
                }
                _ => {
                    // WHY: Log and monitor lower-level threats
                    debug!("Security event: {}", security_alert.description);
                }
            }
        }
        
        Poll::Pending
    }
}
```

## Security Framework

```rust
use std::collections::HashMap;
use std::time::{Duration, SystemTime};
use serde::{Deserialize, Serialize};
use sha2::{Sha256, Digest};
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, NewAead};

#[derive(Debug, Clone)]
pub struct SecurityFramework {
    threat_model: ThreatModel,
    access_control: AccessControlSystem,
    encryption_manager: EncryptionManager,
    audit_logger: AuditLogger,
    vulnerability_scanner: VulnerabilityScanner,
    security_policies: SecurityPolicies,
}

impl SecurityFramework {
    pub fn new(config: SecurityConfig) -> Self {
        Self {
            threat_model: ThreatModel::new(config.threat_config),
            access_control: AccessControlSystem::new(config.access_config),
            encryption_manager: EncryptionManager::new(config.encryption_config),
            audit_logger: AuditLogger::new(config.audit_config),
            vulnerability_scanner: VulnerabilityScanner::new(),
            security_policies: SecurityPolicies::new(config.policy_config),
        }
    }
    
    pub async fn assess_security_posture(&self, system: &SystemComponents) -> Result<SecurityAssessment, SecurityError> {
        let mut assessment = SecurityAssessment::new();
        
        // Threat analysis
        let threat_analysis = self.threat_model.analyze_threats(system).await?;
        assessment.add_threat_analysis(threat_analysis);
        
        // Access control review
        let access_review = self.access_control.review_permissions(system).await?;
        assessment.add_access_review(access_review);
        
        // Encryption audit
        let encryption_audit = self.encryption_manager.audit_encryption_usage(system).await?;
        assessment.add_encryption_audit(encryption_audit);
        
        // Vulnerability scan
        let vulnerability_scan = self.vulnerability_scanner.scan_system(system).await?;
        assessment.add_vulnerability_scan(vulnerability_scan);
        
        // Policy compliance check
        let compliance_check = self.security_policies.check_compliance(system).await?;
        assessment.add_compliance_check(compliance_check);
        
        Ok(assessment)
    }
    
    pub async fn monitor_security_events(&self, event_stream: &mut EventStream) -> Result<(), SecurityError> {
        while let Some(event) = event_stream.next().await {
            // Analyze event for security implications
            let security_event = self.analyze_security_event(&event).await?;
            
            if let Some(security_event) = security_event {
                // Log security event
                self.audit_logger.log_security_event(&security_event).await?;
                
                // Check for threat patterns
                if self.threat_model.matches_threat_pattern(&security_event) {
                    self.handle_security_threat(&security_event).await?;
                }
                
                // Update security metrics
                self.update_security_metrics(&security_event).await?;
            }
        }
        
        Ok(())
    }
    
    async fn handle_security_threat(&self, event: &SecurityEvent) -> Result<(), SecurityError> {
        // Immediate response
        match event.threat_level {
            ThreatLevel::Critical => {
                // Immediate system isolation
                self.isolate_affected_components(&event.affected_components).await?;
                
                // Alert security team
                self.alert_security_team(event).await?;
                
                // Trigger incident response
                self.trigger_incident_response(event).await?;
            }
            ThreatLevel::High => {
                // Enhanced monitoring
                self.enable_enhanced_monitoring(&event.affected_components).await?;
                
                // Rate limiting
                self.apply_rate_limiting(&event.source).await?;
                
                // Alert administrators
                self.alert_administrators(event).await?;
            }
            ThreatLevel::Medium => {
                // Increased logging
                self.increase_logging_level(&event.affected_components).await?;
                
                // Monitor for escalation
                self.monitor_for_escalation(event).await?;
            }
            ThreatLevel::Low => {
                // Standard logging
                self.log_security_event(event).await?;
            }
        }
        
        Ok(())
    }
}

pub struct ThreatModel {
    threats: HashMap<String, ThreatDefinition>,
    attack_patterns: Vec<AttackPattern>,
    risk_matrix: RiskMatrix,
}

impl ThreatModel {
    pub fn new(config: ThreatConfig) -> Self {
        let mut threats = HashMap::new();
        
        // Define common blockchain threats
        threats.insert("51_attack".to_string(), ThreatDefinition {
            name: "51% Attack".to_string(),
            description: "Attacker controls majority of network hash power".to_string(),
            impact: ThreatImpact::Critical,
            likelihood: ThreatLikelihood::Low,
            attack_vectors: vec![
                "Mining pool collusion".to_string(),
                "ASIC farm concentration".to_string(),
                "Cloud mining manipulation".to_string(),
            ],
            mitigations: vec![
                "Decentralized mining".to_string(),
                "Proof of stake transition".to_string(),
                "Checkpoint system".to_string(),
            ],
        });
        
        threats.insert("double_spending".to_string(), ThreatDefinition {
            name: "Double Spending".to_string(),
            description: "Spending same funds multiple times".to_string(),
            impact: ThreatImpact::High,
            likelihood: ThreatLikelihood::Medium,
            attack_vectors: vec![
                "Transaction replacement".to_string(),
                "Chain reorganization".to_string(),
                "Mempool manipulation".to_string(),
            ],
            mitigations: vec![
                "Confirmation requirements".to_string(),
                "Transaction finality".to_string(),
                "Fraud proofs".to_string(),
            ],
        });
        
        threats.insert("ddos_attack".to_string(), ThreatDefinition {
            name: "DDoS Attack".to_string(),
            description: "Overwhelming system with requests".to_string(),
            impact: ThreatImpact::Medium,
            likelihood: ThreatLikelihood::High,
            attack_vectors: vec![
                "Network flooding".to_string(),
                "Resource exhaustion".to_string(),
                "Application layer attacks".to_string(),
            ],
            mitigations: vec![
                "Rate limiting".to_string(),
                "Traffic filtering".to_string(),
                "Load balancing".to_string(),
            ],
        });
        
        Self {
            threats,
            attack_patterns: Self::create_attack_patterns(),
            risk_matrix: RiskMatrix::new(),
        }
    }
    
    pub async fn analyze_threats(&self, system: &SystemComponents) -> Result<ThreatAnalysis, SecurityError> {
        let mut analysis = ThreatAnalysis::new();
        
        // Analyze each threat
        for (threat_id, threat_def) in &self.threats {
            let threat_assessment = self.assess_threat(threat_def, system).await?;
            analysis.add_threat_assessment(threat_id.clone(), threat_assessment);
        }
        
        // Calculate overall risk score
        let overall_risk = self.calculate_overall_risk(&analysis);
        analysis.set_overall_risk(overall_risk);
        
        Ok(analysis)
    }
    
    async fn assess_threat(&self, threat: &ThreatDefinition, system: &SystemComponents) -> Result<ThreatAssessment, SecurityError> {
        // Assess current vulnerability to this threat
        let vulnerability_score = self.assess_vulnerability(threat, system).await?;
        
        // Calculate risk level
        let risk_level = self.risk_matrix.calculate_risk(
            threat.impact,
            threat.likelihood,
            vulnerability_score
        );
        
        // Check existing mitigations
        let mitigation_effectiveness = self.assess_mitigation_effectiveness(threat, system).await?;
        
        // Calculate residual risk
        let residual_risk = self.calculate_residual_risk(risk_level, mitigation_effectiveness);
        
        Ok(ThreatAssessment {
            threat_name: threat.name.clone(),
            risk_level,
            residual_risk,
            vulnerability_score,
            mitigation_effectiveness,
            recommendations: self.generate_recommendations(threat, vulnerability_score),
        })
    }
    
    pub fn matches_threat_pattern(&self, event: &SecurityEvent) -> bool {
        for pattern in &self.attack_patterns {
            if pattern.matches(event) {
                return true;
            }
        }
        false
    }
    
    fn create_attack_patterns() -> Vec<AttackPattern> {
        vec![
            AttackPattern {
                name: "Brute Force Login".to_string(),
                indicators: vec![
                    "High frequency login attempts".to_string(),
                    "Multiple failed authentications".to_string(),
                    "Sequential account targeting".to_string(),
                ],
                threshold: 10,
                time_window: Duration::from_secs(300),
            },
            AttackPattern {
                name: "Transaction Spam".to_string(),
                indicators: vec![
                    "High transaction volume".to_string(),
                    "Low value transactions".to_string(),
                    "Single origin address".to_string(),
                ],
                threshold: 100,
                time_window: Duration::from_secs(60),
            },
            AttackPattern {
                name: "Eclipse Attack".to_string(),
                indicators: vec![
                    "Unusual peer connections".to_string(),
                    "Network partition signs".to_string(),
                    "Delayed block propagation".to_string(),
                ],
                threshold: 5,
                time_window: Duration::from_secs(600),
            },
        ]
    }
}

pub struct AccessControlSystem {
    permissions: HashMap<String, Vec<Permission>>,
    roles: HashMap<String, Role>,
    policies: Vec<AccessPolicy>,
    session_manager: SessionManager,
}

impl AccessControlSystem {
    pub fn new(config: AccessConfig) -> Self {
        Self {
            permissions: HashMap::new(),
            roles: HashMap::new(),
            policies: Vec::new(),
            session_manager: SessionManager::new(config.session_config),
        }
    }
    
    pub async fn authenticate_user(&self, credentials: &Credentials) -> Result<AuthenticationResult, SecurityError> {
        // Validate credentials
        let user_id = self.validate_credentials(credentials).await?;
        
        // Check account status
        self.check_account_status(&user_id).await?;
        
        // Create session
        let session = self.session_manager.create_session(&user_id).await?;
        
        // Get user permissions
        let permissions = self.get_user_permissions(&user_id).await?;
        
        Ok(AuthenticationResult {
            user_id,
            session_id: session.id,
            permissions,
            expires_at: session.expires_at,
        })
    }
    
    pub async fn authorize_action(&self, session_id: &str, action: &Action) -> Result<AuthorizationResult, SecurityError> {
        // Validate session
        let session = self.session_manager.get_session(session_id).await?;
        
        // Check if session is expired
        if session.is_expired() {
            return Ok(AuthorizationResult::Denied("Session expired".to_string()));
        }
        
        // Get user permissions
        let permissions = self.get_user_permissions(&session.user_id).await?;
        
        // Check if action is permitted
        if self.is_action_permitted(action, &permissions) {
            // Log successful authorization
            self.log_authorization_success(&session.user_id, action).await?;
            
            Ok(AuthorizationResult::Allowed)
        } else {
            // Log failed authorization
            self.log_authorization_failure(&session.user_id, action).await?;
            
            Ok(AuthorizationResult::Denied("Insufficient permissions".to_string()))
        }
    }
    
    async fn validate_credentials(&self, credentials: &Credentials) -> Result<String, SecurityError> {
        match credentials {
            Credentials::Password { username, password } => {
                self.validate_password_credentials(username, password).await
            }
            Credentials::Token { token } => {
                self.validate_token_credentials(token).await
            }
            Credentials::Certificate { certificate } => {
                self.validate_certificate_credentials(certificate).await
            }
        }
    }
    
    async fn validate_password_credentials(&self, username: &str, password: &str) -> Result<String, SecurityError> {
        // Implement secure password validation
        // - Hash verification
        // - Timing attack prevention
        // - Account lockout protection
        
        // Rate limiting
        self.check_login_rate_limit(username).await?;
        
        // Get stored password hash
        let stored_hash = self.get_stored_password_hash(username).await?;
        
        // Verify password
        let is_valid = self.verify_password(password, &stored_hash)?;
        
        if is_valid {
            // Reset failed attempts
            self.reset_failed_attempts(username).await?;
            Ok(username.to_string())
        } else {
            // Record failed attempt
            self.record_failed_attempt(username).await?;
            Err(SecurityError::AuthenticationFailed)
        }
    }
    
    pub async fn review_permissions(&self, system: &SystemComponents) -> Result<AccessReview, SecurityError> {
        let mut review = AccessReview::new();
        
        // Review user permissions
        for (user_id, permissions) in &self.permissions {
            let user_review = self.review_user_permissions(user_id, permissions).await?;
            review.add_user_review(user_review);
        }
        
        // Review role definitions
        for (role_name, role) in &self.roles {
            let role_review = self.review_role_definition(role_name, role).await?;
            review.add_role_review(role_review);
        }
        
        // Review access policies
        for policy in &self.policies {
            let policy_review = self.review_access_policy(policy).await?;
            review.add_policy_review(policy_review);
        }
        
        Ok(review)
    }
}

pub struct EncryptionManager {
    key_store: KeyStore,
    cipher_suites: Vec<CipherSuite>,
    key_rotation_policy: KeyRotationPolicy,
}

impl EncryptionManager {
    pub fn new(config: EncryptionConfig) -> Self {
        Self {
            key_store: KeyStore::new(config.key_store_config),
            cipher_suites: Self::create_cipher_suites(),
            key_rotation_policy: KeyRotationPolicy::new(config.rotation_config),
        }
    }
    
    pub async fn encrypt_data(&self, data: &[u8], key_id: &str) -> Result<EncryptedData, SecurityError> {
        // Get encryption key
        let key = self.key_store.get_key(key_id).await?;
        
        // Select appropriate cipher suite
        let cipher_suite = self.select_cipher_suite(&key.algorithm)?;
        
        // Generate nonce
        let nonce = cipher_suite.generate_nonce()?;
        
        // Encrypt data
        let ciphertext = cipher_suite.encrypt(data, &key.key_material, &nonce)?;
        
        // Create encrypted data structure
        Ok(EncryptedData {
            algorithm: key.algorithm.clone(),
            key_id: key_id.to_string(),
            nonce,
            ciphertext,
            created_at: SystemTime::now(),
        })
    }
    
    pub async fn decrypt_data(&self, encrypted_data: &EncryptedData) -> Result<Vec<u8>, SecurityError> {
        // Get decryption key
        let key = self.key_store.get_key(&encrypted_data.key_id).await?;
        
        // Verify key algorithm matches
        if key.algorithm != encrypted_data.algorithm {
            return Err(SecurityError::AlgorithmMismatch);
        }
        
        // Select cipher suite
        let cipher_suite = self.select_cipher_suite(&key.algorithm)?;
        
        // Decrypt data
        let plaintext = cipher_suite.decrypt(
            &encrypted_data.ciphertext,
            &key.key_material,
            &encrypted_data.nonce
        )?;
        
        Ok(plaintext)
    }
    
    pub async fn rotate_keys(&self) -> Result<KeyRotationResult, SecurityError> {
        let mut result = KeyRotationResult::new();
        
        // Get keys eligible for rotation
        let keys_to_rotate = self.key_store.get_keys_for_rotation().await?;
        
        for key_id in keys_to_rotate {
            match self.rotate_key(&key_id).await {
                Ok(new_key_id) => {
                    result.rotated_keys.push(KeyRotationEntry {
                        old_key_id: key_id,
                        new_key_id,
                        rotated_at: SystemTime::now(),
                    });
                }
                Err(e) => {
                    result.failed_rotations.push(KeyRotationFailure {
                        key_id,
                        error: e.to_string(),
                    });
                }
            }
        }
        
        Ok(result)
    }
    
    async fn rotate_key(&self, key_id: &str) -> Result<String, SecurityError> {
        // Get current key
        let current_key = self.key_store.get_key(key_id).await?;
        
        // Generate new key with same algorithm
        let new_key = self.generate_key(&current_key.algorithm)?;
        
        // Store new key
        let new_key_id = self.key_store.store_key(new_key).await?;
        
        // Mark old key for deprecation
        self.key_store.deprecate_key(key_id).await?;
        
        Ok(new_key_id)
    }
    
    pub async fn audit_encryption_usage(&self, system: &SystemComponents) -> Result<EncryptionAudit, SecurityError> {
        let mut audit = EncryptionAudit::new();
        
        // Audit key usage
        let key_usage = self.audit_key_usage().await?;
        audit.add_key_usage(key_usage);
        
        // Audit encryption algorithms
        let algorithm_usage = self.audit_algorithm_usage().await?;
        audit.add_algorithm_usage(algorithm_usage);
        
        // Check for weak encryption
        let weak_encryption = self.check_weak_encryption().await?;
        audit.add_weak_encryption_findings(weak_encryption);
        
        // Verify key rotation compliance
        let rotation_compliance = self.verify_rotation_compliance().await?;
        audit.add_rotation_compliance(rotation_compliance);
        
        Ok(audit)
    }
    
    fn create_cipher_suites() -> Vec<CipherSuite> {
        vec![
            CipherSuite::new(
                "AES-256-GCM".to_string(),
                EncryptionAlgorithm::Aes256Gcm,
                256,
                96, // Nonce size
            ),
            CipherSuite::new(
                "ChaCha20-Poly1305".to_string(),
                EncryptionAlgorithm::ChaCha20Poly1305,
                256,
                96,
            ),
        ]
    }
}

#[derive(Debug, Clone)]
pub struct ThreatDefinition {
    pub name: String,
    pub description: String,
    pub impact: ThreatImpact,
    pub likelihood: ThreatLikelihood,
    pub attack_vectors: Vec<String>,
    pub mitigations: Vec<String>,
}

#[derive(Debug, Clone)]
pub enum ThreatImpact {
    Critical,
    High,
    Medium,
    Low,
}

#[derive(Debug, Clone)]
pub enum ThreatLikelihood {
    High,
    Medium,
    Low,
}

#[derive(Debug, Clone)]
pub enum ThreatLevel {
    Critical,
    High,
    Medium,
    Low,
}

#[derive(Debug, Clone)]
pub struct SecurityEvent {
    pub id: String,
    pub timestamp: SystemTime,
    pub event_type: SecurityEventType,
    pub source: String,
    pub threat_level: ThreatLevel,
    pub affected_components: Vec<String>,
    pub details: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub enum SecurityEventType {
    AuthenticationFailure,
    AuthorizationViolation,
    SuspiciousActivity,
    IntrusionAttempt,
    DataBreach,
    SystemCompromise,
}

#[derive(Debug, Clone)]
pub struct SecurityAssessment {
    pub threat_analysis: Option<ThreatAnalysis>,
    pub access_review: Option<AccessReview>,
    pub encryption_audit: Option<EncryptionAudit>,
    pub vulnerability_scan: Option<VulnerabilityReport>,
    pub compliance_check: Option<ComplianceReport>,
    pub overall_score: f64,
    pub recommendations: Vec<String>,
}

impl SecurityAssessment {
    pub fn new() -> Self {
        Self {
            threat_analysis: None,
            access_review: None,
            encryption_audit: None,
            vulnerability_scan: None,
            compliance_check: None,
            overall_score: 0.0,
            recommendations: Vec::new(),
        }
    }
    
    pub fn add_threat_analysis(&mut self, analysis: ThreatAnalysis) {
        self.threat_analysis = Some(analysis);
    }
    
    pub fn add_access_review(&mut self, review: AccessReview) {
        self.access_review = Some(review);
    }
    
    pub fn add_encryption_audit(&mut self, audit: EncryptionAudit) {
        self.encryption_audit = Some(audit);
    }
    
    pub fn add_vulnerability_scan(&mut self, scan: VulnerabilityReport) {
        self.vulnerability_scan = Some(scan);
    }
    
    pub fn add_compliance_check(&mut self, check: ComplianceReport) {
        self.compliance_check = Some(check);
    }
}

#[derive(Debug)]
pub enum SecurityError {
    AuthenticationFailed,
    AuthorizationDenied,
    EncryptionFailed,
    DecryptionFailed,
    KeyNotFound,
    AlgorithmMismatch,
    ThreatDetected,
    VulnerabilityFound,
    ComplianceViolation,
    ConfigurationError(String),
    SystemError(String),
}

impl std::fmt::Display for SecurityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SecurityError::AuthenticationFailed => write!(f, "Authentication failed"),
            SecurityError::AuthorizationDenied => write!(f, "Authorization denied"),
            SecurityError::EncryptionFailed => write!(f, "Encryption failed"),
            SecurityError::DecryptionFailed => write!(f, "Decryption failed"),
            SecurityError::KeyNotFound => write!(f, "Key not found"),
            SecurityError::AlgorithmMismatch => write!(f, "Algorithm mismatch"),
            SecurityError::ThreatDetected => write!(f, "Threat detected"),
            SecurityError::VulnerabilityFound => write!(f, "Vulnerability found"),
            SecurityError::ComplianceViolation => write!(f, "Compliance violation"),
            SecurityError::ConfigurationError(msg) => write!(f, "Configuration error: {}", msg),
            SecurityError::SystemError(msg) => write!(f, "System error: {}", msg),
        }
    }
}

impl std::error::Error for SecurityError {}

// Supporting types and implementations
pub struct SecurityConfig;
pub struct SystemComponents;
pub struct ThreatConfig;
pub struct AccessConfig;
pub struct EncryptionConfig;
pub struct AuditConfig;
pub struct PolicyConfig;
pub struct EventStream;
pub struct ThreatAnalysis;
pub struct AccessReview;
pub struct EncryptionAudit;
pub struct VulnerabilityReport;
pub struct ComplianceReport;
pub struct VulnerabilityScanner;
pub struct SecurityPolicies;
pub struct AuditLogger;
pub struct AttackPattern;
pub struct RiskMatrix;
pub struct ThreatAssessment;
pub struct Credentials;
pub struct AuthenticationResult;
pub struct AuthorizationResult;
pub struct Action;
pub struct Permission;
pub struct Role;
pub struct AccessPolicy;
pub struct SessionManager;
pub struct KeyStore;
pub struct CipherSuite;
pub struct KeyRotationPolicy;
pub struct EncryptedData;
pub struct KeyRotationResult;
pub struct KeyRotationEntry;
pub struct KeyRotationFailure;
pub struct EncryptionAlgorithm;

// Stub implementations for supporting types
impl SecurityConfig {
    pub fn new() -> Self { Self }
}

impl ThreatAnalysis {
    pub fn new() -> Self { Self }
    pub fn add_threat_assessment(&mut self, _id: String, _assessment: ThreatAssessment) {}
    pub fn set_overall_risk(&mut self, _risk: f64) {}
}

impl AccessReview {
    pub fn new() -> Self { Self }
    pub fn add_user_review(&mut self, _review: String) {}
    pub fn add_role_review(&mut self, _review: String) {}
    pub fn add_policy_review(&mut self, _review: String) {}
}

impl EncryptionAudit {
    pub fn new() -> Self { Self }
    pub fn add_key_usage(&mut self, _usage: String) {}
    pub fn add_algorithm_usage(&mut self, _usage: String) {}
    pub fn add_weak_encryption_findings(&mut self, _findings: Vec<String>) {}
    pub fn add_rotation_compliance(&mut self, _compliance: String) {}
}

impl VulnerabilityReport {
    pub fn new() -> Self { Self }
}

impl ComplianceReport {
    pub fn new() -> Self { Self }
}

impl KeyRotationResult {
    pub fn new() -> Self { Self { rotated_keys: Vec::new(), failed_rotations: Vec::new() } }
    pub rotated_keys: Vec<KeyRotationEntry>,
    pub failed_rotations: Vec<KeyRotationFailure>,
}

impl std::fmt::Display for KeyRotationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Key rotation: {} succeeded, {} failed", 
               self.rotated_keys.len(), self.failed_rotations.len())
    }
}
```

## Summary
Security considerations require a comprehensive approach including threat modeling, access control, encryption, and continuous monitoring. Effective security integrates multiple defensive layers and proactive threat detection.

## Assignments
1. **Security Framework**: Build comprehensive security management system
2. **Threat Model**: Create detailed threat analysis for blockchain systems
3. **Access Control**: Implement role-based access control with auditing

## Questions to Ponder
1. How do you balance security with usability?
2. What security measures are most critical for blockchain systems?
3. How do you handle key management securely?
4. What indicators suggest a security breach?
5. How do you maintain security in distributed systems?