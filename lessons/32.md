# Lesson 32: Transaction Validation

*"Study hard what interests you the most in the most undisciplined, irreverent and original manner possible." - Richard Feynman*

## Files with Inline Comments for This Lesson
- `crates/transaction-pool/src/validate/mod.rs` - Core validation abstractions and outcomes
- `crates/transaction-pool/src/validate/eth.rs` - Ethereum-specific transaction validator
- `crates/transaction-pool/src/validate/task.rs` - Asynchronous validation task execution
- `crates/transaction-pool/src/error.rs` - Transaction validation error types

## Why Transaction Validation Matters

Transaction validation is the critical gatekeeper that prevents invalid, malicious, or uneconomical transactions from entering the transaction pool. It acts as the first line of defense against various attack vectors while ensuring the node only processes transactions that have a reasonable chance of inclusion in a block.

```
Transaction Journey Through Validation:
┌─────────────────────────────────────────────────┐
│                Raw Transaction                  │
│  From: Network Peer / Local Client / RPC       │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│            Stateless Validation                │
│  • Signature verification                      │
│  • Transaction format checks                   │
│  • EIP activation checks                       │
│  • Gas limit bounds                            │
│  • Intrinsic gas calculation                   │
│  • Fee structure validation                    │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│             Stateful Validation                │
│  • Account balance check                       │
│  • Nonce verification                          │
│  • Sender account status                       │
│  • Blob validation (EIP-4844)                  │
│  • Authorization list (EIP-7702)               │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│               Result                            │
│  Valid → Pool Insertion                        │
│  Invalid → Immediate Rejection                  │
│  Error → Retry or Ban                          │
└─────────────────────────────────────────────────┘
```

## Core Validation Framework

The validation framework is built around the `TransactionValidator` trait:

```rust
/// Core trait for transaction validation
/// Located in: crates/transaction-pool/src/validate/mod.rs

pub trait TransactionValidator: Debug + Send + Sync {
    /// The transaction type to validate
    type Transaction: PoolTransaction;

    /// Main validation method - async to allow state queries
    fn validate_transaction(
        &self,
        origin: TransactionOrigin,
        transaction: Self::Transaction,
    ) -> impl Future<Output = TransactionValidationOutcome<Self::Transaction>> + Send;

    /// Batch validation for efficiency
    fn validate_transactions(
        &self,
        transactions: Vec<(TransactionOrigin, Self::Transaction)>,
    ) -> impl Future<Output = Vec<TransactionValidationOutcome<Self::Transaction>>> + Send {
        async {
            // Default implementation processes transactions concurrently
            futures_util::future::join_all(
                transactions.into_iter().map(|(origin, tx)| {
                    self.validate_transaction(origin, tx)
                })
            ).await
        }
    }

    /// Update validation rules based on new head block
    /// This updates fork activation status and gas limits
    fn on_new_head_block<B>(&self, new_tip_block: &SealedBlock<B>)
    where
        B: Block,
    {
        // Optional: Update validator state based on new chain tip
    }
}

/// Outcome of transaction validation
#[derive(Debug)]
pub enum TransactionValidationOutcome<T: PoolTransaction> {
    /// Transaction is valid and can be inserted into pool
    Valid {
        /// Sender's current balance
        balance: U256,
        /// Sender's current nonce  
        state_nonce: u64,
        /// Sender's code hash (if any)
        bytecode_hash: Option<B256>,
        /// The validated transaction with optional blob sidecar
        transaction: ValidTransaction<T>,
        /// Whether to propagate to network
        propagate: bool,
        /// EIP-7702 authorization authorities
        authorities: Option<Vec<Address>>,
    },
    /// Transaction is permanently invalid
    Invalid(T, InvalidPoolTransactionError),
    /// Validation error occurred (may be retryable)
    Error(TxHash, Box<dyn core::error::Error + Send + Sync>),
}

impl<T: PoolTransaction> TransactionValidationOutcome<T> {
    /// Check if validation succeeded
    pub const fn is_valid(&self) -> bool {
        matches!(self, Self::Valid { .. })
    }

    /// Check if transaction is permanently invalid
    pub const fn is_invalid(&self) -> bool {
        matches!(self, Self::Invalid(_, _))
    }

    /// Check if an error occurred during validation
    pub const fn is_error(&self) -> bool {
        matches!(self, Self::Error(_, _))
    }
}
```

## Ethereum Transaction Validator

The `EthTransactionValidator` implements comprehensive validation for all Ethereum transaction types:

```rust
/// Ethereum-specific transaction validator
/// Located in: crates/transaction-pool/src/validate/eth.rs

#[derive(Debug, Clone)]
pub struct EthTransactionValidator<Client, T> {
    inner: Arc<EthTransactionValidatorInner<Client, T>>,
}

#[derive(Debug)]
struct EthTransactionValidatorInner<Client, T> {
    /// Database client for state access
    client: Client,
    
    /// Blob store for EIP-4844 validation
    blob_store: Box<dyn BlobStore>,
    
    /// Tracks activated forks for validation rules
    fork_tracker: ForkTracker,
    
    /// Transaction type support flags
    eip2718: bool,  // Typed transactions (EIP-2718)
    eip1559: bool,  // Dynamic fee transactions (EIP-1559) 
    eip4844: bool,  // Blob transactions (EIP-4844)
    eip7702: bool,  // Account code delegation (EIP-7702)
    
    /// Gas and fee constraints
    block_gas_limit: AtomicU64,
    tx_fee_cap: Option<u128>,
    minimum_priority_fee: Option<u128>,
    max_tx_gas_limit: Option<u64>,
    max_tx_input_bytes: usize,
    
    /// Cryptographic validation setup
    kzg_settings: EnvKzgSettings,
    
    /// Local transaction handling configuration
    local_transactions_config: LocalTransactionConfig,
    
    /// Validation metrics
    validation_metrics: TxPoolValidationMetrics,
}

impl<Client, Tx> EthTransactionValidatorInner<Client, Tx>
where
    Client: ChainSpecProvider<ChainSpec: EthereumHardforks> + StateProviderFactory,
    Tx: EthPoolTransaction,
{
    /// Main validation logic with two-phase approach
    fn validate_one_with_provider(
        &self,
        origin: TransactionOrigin,
        transaction: Tx,
        maybe_state: &mut Option<Box<dyn AccountInfoReader>>,
    ) -> TransactionValidationOutcome<Tx> {
        // Phase 1: Stateless validation (fast path)
        match self.validate_one_no_state(origin, transaction) {
            Ok(transaction) => {
                // Phase 2: Stateful validation (requires state access)
                if maybe_state.is_none() {
                    match self.client.latest() {
                        Ok(new_state) => {
                            *maybe_state = Some(Box::new(new_state));
                        }
                        Err(err) => {
                            return TransactionValidationOutcome::Error(
                                *transaction.hash(),
                                Box::new(err),
                            )
                        }
                    }
                }
                
                let state = maybe_state.as_deref().expect("provider is set");
                self.validate_one_against_state(origin, transaction, state)
            }
            Err(invalid_outcome) => invalid_outcome,
        }
    }
}
```

## Stateless Validation

The first phase checks all rules that don't require blockchain state:

```rust
/// Stateless validation - checks format and consensus rules
/// Located in: crates/transaction-pool/src/validate/eth.rs

impl<Client, Tx> EthTransactionValidatorInner<Client, Tx> {
    fn validate_one_no_state(
        &self,
        origin: TransactionOrigin,
        transaction: Tx,
    ) -> Result<Tx, TransactionValidationOutcome<Tx>> {
        // 1. Transaction type validation
        match transaction.ty() {
            LEGACY_TX_TYPE_ID => {
                // Always allowed
            }
            EIP2930_TX_TYPE_ID => {
                if !self.eip2718 {
                    return Err(TransactionValidationOutcome::Invalid(
                        transaction,
                        InvalidTransactionError::Eip2930Disabled.into(),
                    ));
                }
            }
            EIP1559_TX_TYPE_ID => {
                if !self.eip1559 {
                    return Err(TransactionValidationOutcome::Invalid(
                        transaction,
                        InvalidTransactionError::Eip1559Disabled.into(),
                    ));
                }
            }
            EIP4844_TX_TYPE_ID => {
                if !self.eip4844 {
                    return Err(TransactionValidationOutcome::Invalid(
                        transaction,
                        InvalidTransactionError::Eip4844Disabled.into(),
                    ));
                }
            }
            EIP7702_TX_TYPE_ID => {
                if !self.eip7702 {
                    return Err(TransactionValidationOutcome::Invalid(
                        transaction,
                        InvalidTransactionError::Eip7702Disabled.into(),
                    ));
                }
            }
            _ => {
                return Err(TransactionValidationOutcome::Invalid(
                    transaction,
                    InvalidTransactionError::TxTypeNotSupported.into(),
                ));
            }
        }

        // 2. Nonce validation (EIP-2681)
        if transaction.nonce() == u64::MAX {
            return Err(TransactionValidationOutcome::Invalid(
                transaction,
                InvalidPoolTransactionError::Eip2681,
            ));
        }

        // 3. Transaction size limits (DoS protection)
        let tx_input_len = transaction.input().len();
        if tx_input_len > self.max_tx_input_bytes {
            return Err(TransactionValidationOutcome::Invalid(
                transaction,
                InvalidPoolTransactionError::OversizedData(
                    tx_input_len, 
                    self.max_tx_input_bytes
                ),
            ));
        }

        // 4. Init code size check (EIP-3860, active after Shanghai)
        if self.fork_tracker.is_shanghai_activated() {
            if let Err(err) = transaction.ensure_max_init_code_size(MAX_INIT_CODE_BYTE_SIZE) {
                return Err(TransactionValidationOutcome::Invalid(transaction, err));
            }
        }

        // 5. Gas limit validation
        let transaction_gas_limit = transaction.gas_limit();
        let block_gas_limit = self.max_gas_limit();
        
        if transaction_gas_limit > block_gas_limit {
            return Err(TransactionValidationOutcome::Invalid(
                transaction,
                InvalidPoolTransactionError::ExceedsGasLimit(
                    transaction_gas_limit,
                    block_gas_limit,
                ),
            ));
        }

        // 6. Individual transaction gas limit (if configured)
        if let Some(max_tx_gas_limit) = self.max_tx_gas_limit {
            if transaction_gas_limit > max_tx_gas_limit {
                return Err(TransactionValidationOutcome::Invalid(
                    transaction,
                    InvalidPoolTransactionError::MaxTxGasLimitExceeded(
                        transaction_gas_limit,
                        max_tx_gas_limit,
                    ),
                ));
            }
        }

        // 7. Fee structure validation
        if transaction.max_priority_fee_per_gas() > Some(transaction.max_fee_per_gas()) {
            return Err(TransactionValidationOutcome::Invalid(
                transaction,
                InvalidTransactionError::TipAboveFeeCap.into(),
            ));
        }

        // 8. Fee cap validation for local transactions
        let is_local = self.local_transactions_config
            .is_local(origin, transaction.sender_ref());
        
        if is_local {
            if let Some(tx_fee_cap_wei) = self.tx_fee_cap {
                if tx_fee_cap_wei > 0 {
                    let gas_price = transaction.max_fee_per_gas();
                    let max_tx_fee_wei = gas_price
                        .saturating_mul(transaction.gas_limit() as u128);
                    
                    if max_tx_fee_wei > tx_fee_cap_wei {
                        return Err(TransactionValidationOutcome::Invalid(
                            transaction,
                            InvalidPoolTransactionError::ExceedsFeeCap {
                                max_tx_fee_wei,
                                tx_fee_cap_wei,
                            },
                        ));
                    }
                }
            }
        }

        // 9. Minimum priority fee check for non-local transactions
        if !is_local && 
           transaction.is_dynamic_fee() &&
           transaction.max_priority_fee_per_gas() < self.minimum_priority_fee
        {
            return Err(TransactionValidationOutcome::Invalid(
                transaction,
                InvalidPoolTransactionError::PriorityFeeBelowMinimum {
                    minimum_priority_fee: self.minimum_priority_fee
                        .expect("minimum priority fee is expected"),
                },
            ));
        }

        // 10. Chain ID validation
        if let Some(chain_id) = transaction.chain_id() {
            if chain_id != self.chain_id() {
                return Err(TransactionValidationOutcome::Invalid(
                    transaction,
                    InvalidTransactionError::ChainIdMismatch.into(),
                ));
            }
        }

        // 11. Intrinsic gas validation
        if let Err(err) = ensure_intrinsic_gas(&transaction, &self.fork_tracker) {
            return Err(TransactionValidationOutcome::Invalid(transaction, err));
        }

        // 12. EIP-4844 blob transaction pre-checks
        if transaction.is_eip4844() {
            if !self.fork_tracker.is_cancun_activated() {
                return Err(TransactionValidationOutcome::Invalid(
                    transaction,
                    InvalidTransactionError::TxTypeNotSupported.into(),
                ));
            }

            let blob_count = transaction.blob_versioned_hashes()
                .map(|b| b.len() as u64)
                .unwrap_or(0);
            
            if blob_count == 0 {
                return Err(TransactionValidationOutcome::Invalid(
                    transaction,
                    InvalidPoolTransactionError::Eip4844(
                        Eip4844PoolTransactionError::NoEip4844Blobs,
                    ),
                ));
            }

            let max_blob_count = self.fork_tracker.max_blob_count();
            if blob_count > max_blob_count {
                return Err(TransactionValidationOutcome::Invalid(
                    transaction,
                    InvalidPoolTransactionError::Eip4844(
                        Eip4844PoolTransactionError::TooManyEip4844Blobs {
                            have: blob_count,
                            permitted: max_blob_count,
                        },
                    ),
                ));
            }
        }

        Ok(transaction)
    }
}
```

## Stateful Validation

The second phase requires access to current blockchain state:

```rust
/// Stateful validation - checks account state and balances
/// Located in: crates/transaction-pool/src/validate/eth.rs

impl<Client, Tx> EthTransactionValidatorInner<Client, Tx> {
    fn validate_one_against_state<P>(
        &self,
        origin: TransactionOrigin,
        mut transaction: Tx,
        state: P,
    ) -> TransactionValidationOutcome<Tx>
    where
        P: AccountInfoReader,
    {
        // 1. Get sender account info
        let account = match state.basic_account(transaction.sender_ref()) {
            Ok(account) => account.unwrap_or_default(),
            Err(err) => {
                return TransactionValidationOutcome::Error(
                    *transaction.hash(), 
                    Box::new(err)
                );
            }
        };

        // 2. Validate sender account (must be EOA or EIP-7702)
        if let Some(code_hash) = &account.bytecode_hash {
            let is_eip7702 = if self.fork_tracker.is_prague_activated() {
                match state.bytecode_by_hash(code_hash) {
                    Ok(bytecode) => bytecode.unwrap_or_default().is_eip7702(),
                    Err(err) => {
                        return TransactionValidationOutcome::Error(
                            *transaction.hash(),
                            Box::new(err),
                        );
                    }
                }
            } else {
                false
            };

            if !is_eip7702 {
                return TransactionValidationOutcome::Invalid(
                    transaction,
                    InvalidTransactionError::SignerAccountHasBytecode.into(),
                );
            }
        }

        // 3. Nonce validation
        let tx_nonce = transaction.nonce();
        if tx_nonce < account.nonce {
            return TransactionValidationOutcome::Invalid(
                transaction,
                InvalidTransactionError::NonceNotConsistent { 
                    tx: tx_nonce, 
                    state: account.nonce 
                }.into(),
            );
        }

        // 4. Balance validation
        let cost = transaction.cost();
        if cost > &account.balance {
            return TransactionValidationOutcome::Invalid(
                transaction,
                InvalidTransactionError::InsufficientFunds(
                    GotExpected { 
                        got: account.balance, 
                        expected: *cost 
                    }.into(),
                ).into(),
            );
        }

        // 5. EIP-4844 blob validation (heavyweight)
        let mut maybe_blob_sidecar = None;
        if transaction.is_eip4844() {
            match transaction.take_blob() {
                EthBlobTransactionSidecar::Present(sidecar) => {
                    let now = Instant::now();
                    
                    // Validate blob against KZG commitments
                    if let Err(err) = transaction.validate_blob(
                        &sidecar, 
                        self.kzg_settings.get()
                    ) {
                        return TransactionValidationOutcome::Invalid(
                            transaction,
                            InvalidPoolTransactionError::Eip4844(
                                Eip4844PoolTransactionError::InvalidEip4844Blob(err),
                            ),
                        );
                    }
                    
                    // Record validation time for metrics
                    self.validation_metrics.blob_validation_duration
                        .record(now.elapsed());
                    
                    maybe_blob_sidecar = Some(sidecar);
                }
                EthBlobTransactionSidecar::Missing => {
                    // Check if blob is already in store (re-injected tx)
                    if !matches!(self.blob_store.contains(*transaction.hash()), Ok(true)) {
                        return TransactionValidationOutcome::Invalid(
                            transaction,
                            InvalidPoolTransactionError::Eip4844(
                                Eip4844PoolTransactionError::MissingEip4844BlobSidecar,
                            ),
                        );
                    }
                }
                EthBlobTransactionSidecar::None => {
                    return TransactionValidationOutcome::Invalid(
                        transaction,
                        InvalidTransactionError::TxTypeNotSupported.into(),
                    );
                }
            }
        }

        // 6. EIP-7702 authorization validation
        let authorities = transaction.authorization_list().map(|auths| {
            auths.iter()
                .flat_map(|auth| auth.recover_authority())
                .collect::<Vec<_>>()
        });

        // 7. Success - construct valid outcome
        TransactionValidationOutcome::Valid {
            balance: account.balance,
            state_nonce: account.nonce,
            bytecode_hash: account.bytecode_hash,
            transaction: ValidTransaction::new(transaction, maybe_blob_sidecar),
            propagate: match origin {
                TransactionOrigin::External => true,
                TransactionOrigin::Local => {
                    self.local_transactions_config.propagate_local_transactions
                }
                TransactionOrigin::Private => false,
            },
            authorities,
        }
    }
}
```

## Fork-Aware Validation

The validator tracks Ethereum forks to apply the correct validation rules:

```rust
/// Tracks activated forks for validation rules
/// Located in: crates/transaction-pool/src/validate/eth.rs

#[derive(Debug)]
pub struct ForkTracker {
    /// Shanghai fork status
    pub shanghai: AtomicBool,
    /// Cancun fork status (EIP-4844)
    pub cancun: AtomicBool,
    /// Prague fork status (EIP-7702)
    pub prague: AtomicBool,
    /// Osaka fork status (EIP-7594)
    pub osaka: AtomicBool,
    /// Maximum blobs per transaction
    pub max_blob_count: AtomicU64,
}

impl ForkTracker {
    /// Check if Shanghai is activated (EIP-3860 init code limit)
    pub fn is_shanghai_activated(&self) -> bool {
        self.shanghai.load(std::sync::atomic::Ordering::Relaxed)
    }

    /// Check if Cancun is activated (EIP-4844 blob transactions)
    pub fn is_cancun_activated(&self) -> bool {
        self.cancun.load(std::sync::atomic::Ordering::Relaxed)
    }

    /// Check if Prague is activated (EIP-7702 account delegation)
    pub fn is_prague_activated(&self) -> bool {
        self.prague.load(std::sync::atomic::Ordering::Relaxed)
    }

    /// Get maximum allowed blob count
    pub fn max_blob_count(&self) -> u64 {
        self.max_blob_count.load(std::sync::atomic::Ordering::Relaxed)
    }
}

/// Update fork status on new blocks
impl<Client, Tx> EthTransactionValidatorInner<Client, Tx> {
    fn on_new_head_block<T: BlockHeader>(&self, new_tip_block: &T) {
        // Update fork activation flags based on timestamp
        if self.chain_spec().is_shanghai_active_at_timestamp(new_tip_block.timestamp()) {
            self.fork_tracker.shanghai.store(true, std::sync::atomic::Ordering::Relaxed);
        }

        if self.chain_spec().is_cancun_active_at_timestamp(new_tip_block.timestamp()) {
            self.fork_tracker.cancun.store(true, std::sync::atomic::Ordering::Relaxed);
        }

        if self.chain_spec().is_prague_active_at_timestamp(new_tip_block.timestamp()) {
            self.fork_tracker.prague.store(true, std::sync::atomic::Ordering::Relaxed);
        }

        // Update blob parameters
        if let Some(blob_params) = self.chain_spec()
            .blob_params_at_timestamp(new_tip_block.timestamp())
        {
            self.fork_tracker.max_blob_count.store(
                blob_params.max_blobs_per_tx, 
                std::sync::atomic::Ordering::Relaxed
            );
        }

        // Update gas limit
        self.block_gas_limit.store(
            new_tip_block.gas_limit(), 
            std::sync::atomic::Ordering::Relaxed
        );
    }
}
```

## Assignments

### Assignment 1: Basic Validation Chain
Create a minimal transaction validator that demonstrates the validation pipeline:

```rust
use alloy_primitives::{Address, U256, B256};
use std::collections::HashMap;

/// Simple transaction for testing validation
#[derive(Debug, Clone)]
struct SimpleTransaction {
    from: Address,
    to: Option<Address>,
    value: U256,
    gas_limit: u64,
    gas_price: u128,
    nonce: u64,
    data: Vec<u8>,
    hash: B256,
}

/// Basic validator implementation
struct SimpleValidator {
    // TODO: Implement fields for:
    // - Account state storage
    // - Gas limit configuration  
    // - Fee requirements
    // - Nonce tracking
}

impl SimpleValidator {
    fn new() -> Self {
        // TODO: Initialize validator with default settings
        todo!("Implement validator initialization")
    }
    
    fn validate_transaction(&self, tx: SimpleTransaction) -> ValidationResult {
        // TODO: Implement validation chain:
        // 1. Basic format checks (gas limit > 0, valid addresses)
        // 2. Account state checks (balance >= value + gas cost)
        // 3. Nonce validation (tx.nonce >= account.nonce)
        // 4. Return appropriate result
        
        todo!("Implement transaction validation")
    }
}

#[derive(Debug)]
enum ValidationResult {
    Valid(SimpleTransaction),
    Invalid(String),
    Error(String),
}
```

### Assignment 2: EIP-1559 Fee Validation
Implement comprehensive fee validation for dynamic fee transactions:

```rust
use alloy_primitives::{U256, Address};

/// EIP-1559 transaction with dynamic fees
#[derive(Debug, Clone)]
struct DynamicFeeTransaction {
    from: Address,
    gas_limit: u64,
    max_fee_per_gas: u128,
    max_priority_fee_per_gas: u128,
    value: U256,
    nonce: u64,
}

/// Fee validator for EIP-1559 transactions
struct FeeValidator {
    base_fee: u128,
    minimum_priority_fee: Option<u128>,
    fee_cap: Option<u128>,
}

impl FeeValidator {
    fn validate_fees(&self, tx: &DynamicFeeTransaction) -> Result<FeeValidationInfo, FeeError> {
        // TODO: Implement the following fee validations:
        // 1. max_priority_fee_per_gas <= max_fee_per_gas
        // 2. Effective fee calculation: min(max_fee_per_gas - base_fee, max_priority_fee_per_gas)
        // 3. Check against minimum priority fee requirement
        // 4. Validate total cost doesn't exceed fee cap
        // 5. Calculate total transaction cost
        
        todo!("Implement fee validation logic")
    }
}

#[derive(Debug)]
struct FeeValidationInfo {
    effective_tip: u128,
    total_cost: U256,
    meets_minimum: bool,
}

#[derive(Debug)]
enum FeeError {
    TipAboveFeeCap,
    BelowMinimumPriority,
    ExceedsFeeCap,
    InsufficientFunds,
}
```

### Assignment 3: Blob Transaction Validation
Implement EIP-4844 blob transaction validation with KZG proof verification:

```rust
use alloy_primitives::{B256, Address, U256};

/// EIP-4844 blob transaction
#[derive(Debug)]
struct BlobTransaction {
    from: Address,
    gas_limit: u64,
    max_fee_per_gas: u128,
    max_fee_per_blob_gas: u128,
    blob_versioned_hashes: Vec<B256>,
    sidecar: Option<BlobSidecar>,
}

/// Blob sidecar with commitments and proofs
#[derive(Debug)]
struct BlobSidecar {
    blobs: Vec<Blob>,
    commitments: Vec<KzgCommitment>,
    proofs: Vec<KzgProof>,
}

#[derive(Debug)]
struct Blob([u8; 131072]); // 128KB blob

#[derive(Debug)]
struct KzgCommitment([u8; 48]);

#[derive(Debug)]
struct KzgProof([u8; 48]);

/// Blob validator with cryptographic verification
struct BlobValidator {
    max_blobs_per_tx: u64,
    blob_store: HashMap<B256, BlobSidecar>,
}

impl BlobValidator {
    fn validate_blob_transaction(
        &self, 
        tx: &mut BlobTransaction
    ) -> Result<BlobValidationResult, BlobError> {
        // TODO: Implement blob validation:
        // 1. Check blob count limits (1 <= count <= max_blobs_per_tx)
        // 2. Validate sidecar presence or check blob store
        // 3. Verify KZG commitments match versioned hashes
        // 4. Validate KZG proofs for each blob
        // 5. Calculate blob fee cost
        // 6. Store sidecar if valid
        
        todo!("Implement blob validation")
    }
    
    fn verify_kzg_proof(
        &self,
        blob: &Blob,
        commitment: &KzgCommitment,
        proof: &KzgProof,
    ) -> bool {
        // TODO: Implement KZG proof verification
        // This would normally use the c-kzg library
        // For this assignment, you can simulate verification
        
        todo!("Implement KZG verification")
    }
}

#[derive(Debug)]
struct BlobValidationResult {
    blob_fee_cost: U256,
    total_blobs: u64,
}

#[derive(Debug)]
enum BlobError {
    NoBlobs,
    TooManyBlobs,
    MissingSidecar,
    InvalidCommitment,
    InvalidProof,
}
```

## Assignment Answers

### Assignment 1 Answer: Basic Validation Chain

```rust
use alloy_primitives::{Address, U256, B256};
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct SimpleTransaction {
    from: Address,
    to: Option<Address>,
    value: U256,
    gas_limit: u64,
    gas_price: u128,
    nonce: u64,
    data: Vec<u8>,
    hash: B256,
}

#[derive(Debug, Default)]
struct AccountState {
    balance: U256,
    nonce: u64,
}

struct SimpleValidator {
    accounts: HashMap<Address, AccountState>,
    max_gas_limit: u64,
    minimum_gas_price: u128,
    max_data_size: usize,
}

impl SimpleValidator {
    fn new() -> Self {
        Self {
            accounts: HashMap::new(),
            max_gas_limit: 30_000_000, // 30M gas block limit
            minimum_gas_price: 1_000_000_000, // 1 gwei minimum
            max_data_size: 128 * 1024, // 128KB max transaction data
        }
    }
    
    fn add_account(&mut self, address: Address, balance: U256, nonce: u64) {
        self.accounts.insert(address, AccountState { balance, nonce });
    }
    
    fn validate_transaction(&self, tx: SimpleTransaction) -> ValidationResult {
        // 1. Basic format checks
        if tx.gas_limit == 0 {
            return ValidationResult::Invalid("Gas limit cannot be zero".to_string());
        }
        
        if tx.gas_limit > self.max_gas_limit {
            return ValidationResult::Invalid(format!(
                "Gas limit {} exceeds maximum {}", 
                tx.gas_limit, self.max_gas_limit
            ));
        }
        
        if tx.gas_price < self.minimum_gas_price {
            return ValidationResult::Invalid(format!(
                "Gas price {} below minimum {}", 
                tx.gas_price, self.minimum_gas_price
            ));
        }
        
        if tx.data.len() > self.max_data_size {
            return ValidationResult::Invalid(format!(
                "Transaction data size {} exceeds maximum {}", 
                tx.data.len(), self.max_data_size
            ));
        }
        
        // 2. Account state checks
        let account = match self.accounts.get(&tx.from) {
            Some(account) => account,
            None => return ValidationResult::Invalid("Sender account not found".to_string()),
        };
        
        // 3. Nonce validation
        if tx.nonce < account.nonce {
            return ValidationResult::Invalid(format!(
                "Nonce {} too low, expected >= {}", 
                tx.nonce, account.nonce
            ));
        }
        
        // 4. Balance validation
        let gas_cost = U256::from(tx.gas_limit) * U256::from(tx.gas_price);
        let total_cost = tx.value + gas_cost;
        
        if account.balance < total_cost {
            return ValidationResult::Invalid(format!(
                "Insufficient balance: have {}, need {}", 
                account.balance, total_cost
            ));
        }
        
        ValidationResult::Valid(tx)
    }
}

#[derive(Debug)]
enum ValidationResult {
    Valid(SimpleTransaction),
    Invalid(String),
    Error(String),
}

// Example usage and testing
fn test_basic_validation() {
    let mut validator = SimpleValidator::new();
    
    // Add test account
    let sender = Address::random();
    validator.add_account(sender, U256::from(1000000000000000000u64), 5); // 1 ETH, nonce 5
    
    // Valid transaction
    let valid_tx = SimpleTransaction {
        from: sender,
        to: Some(Address::random()),
        value: U256::from(100000000000000000u64), // 0.1 ETH
        gas_limit: 21000,
        gas_price: 20_000_000_000, // 20 gwei
        nonce: 5,
        data: vec![],
        hash: B256::random(),
    };
    
    match validator.validate_transaction(valid_tx) {
        ValidationResult::Valid(_) => println!("✓ Valid transaction passed"),
        result => println!("✗ Valid transaction failed: {:?}", result),
    }
    
    // Invalid transaction - nonce too low
    let invalid_tx = SimpleTransaction {
        from: sender,
        to: Some(Address::random()),
        value: U256::from(100000000000000000u64),
        gas_limit: 21000,
        gas_price: 20_000_000_000,
        nonce: 3, // Too low
        data: vec![],
        hash: B256::random(),
    };
    
    match validator.validate_transaction(invalid_tx) {
        ValidationResult::Invalid(reason) => println!("✓ Invalid transaction rejected: {}", reason),
        result => println!("✗ Invalid transaction not caught: {:?}", result),
    }
}

// Analysis: This basic validator demonstrates the core validation pipeline.
// It checks format constraints first (fast), then state constraints (slower).
// The separation allows for early rejection of obviously invalid transactions.
```

### Assignment 2 Answer: EIP-1559 Fee Validation

```rust
use alloy_primitives::{U256, Address};

#[derive(Debug, Clone)]
struct DynamicFeeTransaction {
    from: Address,
    gas_limit: u64,
    max_fee_per_gas: u128,
    max_priority_fee_per_gas: u128,
    value: U256,
    nonce: u64,
}

struct FeeValidator {
    base_fee: u128,
    minimum_priority_fee: Option<u128>,
    fee_cap: Option<u128>,
}

impl FeeValidator {
    fn new(base_fee: u128) -> Self {
        Self {
            base_fee,
            minimum_priority_fee: None,
            fee_cap: None,
        }
    }
    
    fn with_minimum_priority_fee(mut self, minimum: u128) -> Self {
        self.minimum_priority_fee = Some(minimum);
        self
    }
    
    fn with_fee_cap(mut self, cap: u128) -> Self {
        self.fee_cap = Some(cap);
        self
    }
    
    fn validate_fees(
        &self, 
        tx: &DynamicFeeTransaction,
        account_balance: U256,
    ) -> Result<FeeValidationInfo, FeeError> {
        // 1. Check max_priority_fee_per_gas <= max_fee_per_gas
        if tx.max_priority_fee_per_gas > tx.max_fee_per_gas {
            return Err(FeeError::TipAboveFeeCap);
        }
        
        // 2. Calculate effective tip
        // effective_tip = min(max_fee_per_gas - base_fee, max_priority_fee_per_gas)
        let effective_tip = if tx.max_fee_per_gas <= self.base_fee {
            0 // Transaction won't be included at current base fee
        } else {
            let max_tip_from_fee = tx.max_fee_per_gas - self.base_fee;
            std::cmp::min(max_tip_from_fee, tx.max_priority_fee_per_gas)
        };
        
        // 3. Check minimum priority fee requirement
        let meets_minimum = if let Some(minimum) = self.minimum_priority_fee {
            tx.max_priority_fee_per_gas >= minimum
        } else {
            true
        };
        
        if !meets_minimum {
            return Err(FeeError::BelowMinimumPriority);
        }
        
        // 4. Calculate total transaction cost
        // cost = value + (gas_limit * max_fee_per_gas)
        let gas_cost = U256::from(tx.gas_limit) * U256::from(tx.max_fee_per_gas);
        let total_cost = tx.value + gas_cost;
        
        // 5. Check fee cap (for local transactions)
        if let Some(fee_cap) = self.fee_cap {
            let max_fee_cost = U256::from(tx.gas_limit) * U256::from(tx.max_fee_per_gas);
            if max_fee_cost > U256::from(fee_cap) {
                return Err(FeeError::ExceedsFeeCap);
            }
        }
        
        // 6. Check account balance
        if account_balance < total_cost {
            return Err(FeeError::InsufficientFunds);
        }
        
        Ok(FeeValidationInfo {
            effective_tip,
            total_cost,
            meets_minimum,
            can_pay_base_fee: tx.max_fee_per_gas >= self.base_fee,
        })
    }
    
    /// Update base fee when new block arrives
    fn update_base_fee(&mut self, new_base_fee: u128) {
        self.base_fee = new_base_fee;
    }
}

#[derive(Debug)]
struct FeeValidationInfo {
    effective_tip: u128,
    total_cost: U256,
    meets_minimum: bool,
    can_pay_base_fee: bool,
}

#[derive(Debug, PartialEq)]
enum FeeError {
    TipAboveFeeCap,
    BelowMinimumPriority,
    ExceedsFeeCap,
    InsufficientFunds,
}

// Comprehensive test suite
fn test_fee_validation() {
    let base_fee = 20_000_000_000u128; // 20 gwei
    let validator = FeeValidator::new(base_fee)
        .with_minimum_priority_fee(1_000_000_000) // 1 gwei minimum tip
        .with_fee_cap(100_000_000_000_000_000); // 0.1 ETH max cost
    
    let account_balance = U256::from(1000000000000000000u64); // 1 ETH
    
    // Test case 1: Valid transaction
    let valid_tx = DynamicFeeTransaction {
        from: Address::random(),
        gas_limit: 21000,
        max_fee_per_gas: 25_000_000_000, // 25 gwei
        max_priority_fee_per_gas: 2_000_000_000, // 2 gwei tip
        value: U256::from(100000000000000000u64), // 0.1 ETH
        nonce: 1,
    };
    
    match validator.validate_fees(&valid_tx, account_balance) {
        Ok(info) => {
            println!("✓ Valid EIP-1559 transaction");
            println!("  Effective tip: {} gwei", info.effective_tip / 1_000_000_000);
            println!("  Total cost: {} ETH", info.total_cost / U256::from(1000000000000000000u64));
            assert_eq!(info.effective_tip, 2_000_000_000); // min(25-20, 2) = 2 gwei
        }
        Err(e) => println!("✗ Valid transaction failed: {:?}", e),
    }
    
    // Test case 2: Tip above fee cap
    let invalid_tx = DynamicFeeTransaction {
        from: Address::random(),
        gas_limit: 21000,
        max_fee_per_gas: 20_000_000_000, // 20 gwei
        max_priority_fee_per_gas: 25_000_000_000, // 25 gwei tip (too high!)
        value: U256::from(100000000000000000u64),
        nonce: 1,
    };
    
    match validator.validate_fees(&invalid_tx, account_balance) {
        Err(FeeError::TipAboveFeeCap) => println!("✓ Tip above fee cap correctly rejected"),
        result => println!("✗ Tip above fee cap not caught: {:?}", result),
    }
    
    // Test case 3: Below minimum priority fee
    let low_tip_tx = DynamicFeeTransaction {
        from: Address::random(),
        gas_limit: 21000,
        max_fee_per_gas: 25_000_000_000,
        max_priority_fee_per_gas: 500_000_000, // 0.5 gwei (below 1 gwei minimum)
        value: U256::from(100000000000000000u64),
        nonce: 1,
    };
    
    match validator.validate_fees(&low_tip_tx, account_balance) {
        Err(FeeError::BelowMinimumPriority) => println!("✓ Low priority fee correctly rejected"),
        result => println!("✗ Low priority fee not caught: {:?}", result),
    }
}

// Analysis: This implementation shows how EIP-1559 dynamic fees work in practice.
// The effective tip calculation is key - it determines miner incentive while the
// max fee provides an upper bound. The validator must check both fee structure
// validity and economic constraints like minimum tips and balance requirements.
```

### Assignment 3 Answer: Blob Transaction Validation

```rust
use alloy_primitives::{B256, Address, U256, keccak256};
use std::collections::HashMap;

#[derive(Debug)]
struct BlobTransaction {
    from: Address,
    gas_limit: u64,
    max_fee_per_gas: u128,
    max_fee_per_blob_gas: u128,
    blob_versioned_hashes: Vec<B256>,
    sidecar: Option<BlobSidecar>,
}

#[derive(Debug, Clone)]
struct BlobSidecar {
    blobs: Vec<Blob>,
    commitments: Vec<KzgCommitment>,
    proofs: Vec<KzgProof>,
}

#[derive(Debug, Clone)]
struct Blob(pub Vec<u8>); // Simplified - real blobs are 131072 bytes

#[derive(Debug, Clone)]
struct KzgCommitment(pub [u8; 48]);

#[derive(Debug, Clone)]
struct KzgProof(pub [u8; 48]);

struct BlobValidator {
    max_blobs_per_tx: u64,
    blob_store: HashMap<B256, BlobSidecar>,
    current_blob_base_fee: u128,
}

impl BlobValidator {
    fn new(max_blobs_per_tx: u64) -> Self {
        Self {
            max_blobs_per_tx,
            blob_store: HashMap::new(),
            current_blob_base_fee: 1_000_000_000, // 1 gwei default
        }
    }
    
    fn validate_blob_transaction(
        &mut self, 
        tx: &mut BlobTransaction,
        tx_hash: B256,
    ) -> Result<BlobValidationResult, BlobError> {
        // 1. Check blob count limits
        let blob_count = tx.blob_versioned_hashes.len() as u64;
        
        if blob_count == 0 {
            return Err(BlobError::NoBlobs);
        }
        
        if blob_count > self.max_blobs_per_tx {
            return Err(BlobError::TooManyBlobs);
        }
        
        // 2. Handle sidecar validation
        let sidecar = match &tx.sidecar {
            Some(sidecar) => sidecar.clone(),
            None => {
                // Check if we have the sidecar in store (re-injected transaction)
                match self.blob_store.get(&tx_hash) {
                    Some(stored_sidecar) => stored_sidecar.clone(),
                    None => return Err(BlobError::MissingSidecar),
                }
            }
        };
        
        // 3. Validate sidecar structure
        if sidecar.blobs.len() != blob_count as usize ||
           sidecar.commitments.len() != blob_count as usize ||
           sidecar.proofs.len() != blob_count as usize 
        {
            return Err(BlobError::InvalidCommitment);
        }
        
        // 4. Verify KZG commitments and proofs for each blob
        for (i, ((blob, commitment), proof)) in sidecar.blobs.iter()
            .zip(sidecar.commitments.iter())
            .zip(sidecar.proofs.iter())
            .enumerate() 
        {
            // Verify commitment matches versioned hash
            let versioned_hash = self.compute_versioned_hash(commitment);
            if versioned_hash != tx.blob_versioned_hashes[i] {
                return Err(BlobError::InvalidCommitment);
            }
            
            // Verify KZG proof
            if !self.verify_kzg_proof(blob, commitment, proof) {
                return Err(BlobError::InvalidProof);
            }
        }
        
        // 5. Calculate blob fee cost
        let blob_fee_cost = U256::from(blob_count) * U256::from(self.current_blob_base_fee);
        
        // 6. Store sidecar if it's new
        if tx.sidecar.is_some() {
            self.blob_store.insert(tx_hash, sidecar);
        }
        
        Ok(BlobValidationResult {
            blob_fee_cost,
            total_blobs: blob_count,
            commitment_hashes: tx.blob_versioned_hashes.clone(),
        })
    }
    
    fn verify_kzg_proof(
        &self,
        blob: &Blob,
        commitment: &KzgCommitment,
        proof: &KzgProof,
    ) -> bool {
        // Simplified KZG verification for demo purposes
        // Real implementation would use c-kzg library
        
        // Basic sanity checks
        if blob.0.is_empty() {
            return false;
        }
        
        if commitment.0.iter().all(|&x| x == 0) {
            return false; // Zero commitment is invalid
        }
        
        if proof.0.iter().all(|&x| x == 0) {
            return false; // Zero proof is invalid
        }
        
        // Simulate cryptographic verification
        // In practice, this would:
        // 1. Parse the blob into field elements
        // 2. Compute the polynomial commitment
        // 3. Verify the KZG proof against the commitment
        let blob_hash = keccak256(&blob.0);
        let commitment_hash = keccak256(&commitment.0);
        let proof_hash = keccak256(&proof.0);
        
        // Simple deterministic check for demo
        (blob_hash.0[0] ^ commitment_hash.0[0] ^ proof_hash.0[0]) != 0
    }
    
    fn compute_versioned_hash(&self, commitment: &KzgCommitment) -> B256 {
        // EIP-4844 versioned hash computation
        // versioned_hash = keccak256(BLOB_COMMITMENT_VERSION_KZG + commitment)
        const BLOB_COMMITMENT_VERSION_KZG: u8 = 0x01;
        
        let mut data = Vec::with_capacity(49);
        data.push(BLOB_COMMITMENT_VERSION_KZG);
        data.extend_from_slice(&commitment.0);
        
        keccak256(data)
    }
    
    fn update_blob_base_fee(&mut self, new_base_fee: u128) {
        self.current_blob_base_fee = new_base_fee;
    }
    
    fn get_stored_sidecar(&self, tx_hash: &B256) -> Option<&BlobSidecar> {
        self.blob_store.get(tx_hash)
    }
}

#[derive(Debug)]
struct BlobValidationResult {
    blob_fee_cost: U256,
    total_blobs: u64,
    commitment_hashes: Vec<B256>,
}

#[derive(Debug, PartialEq)]
enum BlobError {
    NoBlobs,
    TooManyBlobs,
    MissingSidecar,
    InvalidCommitment,
    InvalidProof,
}

// Comprehensive test suite
fn test_blob_validation() {
    let mut validator = BlobValidator::new(6); // Max 6 blobs per tx
    
    // Create test blob data
    let test_blob = Blob(vec![0u8; 1000]); // Simplified blob
    let test_commitment = KzgCommitment([1u8; 48]);
    let test_proof = KzgProof([2u8; 48]);
    
    // Compute the correct versioned hash
    let versioned_hash = validator.compute_versioned_hash(&test_commitment);
    
    // Test case 1: Valid blob transaction
    let mut valid_tx = BlobTransaction {
        from: Address::random(),
        gas_limit: 21000,
        max_fee_per_gas: 20_000_000_000,
        max_fee_per_blob_gas: 10_000_000_000,
        blob_versioned_hashes: vec![versioned_hash],
        sidecar: Some(BlobSidecar {
            blobs: vec![test_blob.clone()],
            commitments: vec![test_commitment],
            proofs: vec![test_proof],
        }),
    };
    
    let tx_hash = B256::random();
    match validator.validate_blob_transaction(&mut valid_tx, tx_hash) {
        Ok(result) => {
            println!("✓ Valid blob transaction");
            println!("  Blob count: {}", result.total_blobs);
            println!("  Blob fee cost: {} gwei", result.blob_fee_cost / U256::from(1_000_000_000u64));
        }
        Err(e) => println!("✗ Valid blob transaction failed: {:?}", e),
    }
    
    // Test case 2: No blobs (invalid)
    let mut no_blobs_tx = BlobTransaction {
        from: Address::random(),
        gas_limit: 21000,
        max_fee_per_gas: 20_000_000_000,
        max_fee_per_blob_gas: 10_000_000_000,
        blob_versioned_hashes: vec![],
        sidecar: Some(BlobSidecar {
            blobs: vec![],
            commitments: vec![],
            proofs: vec![],
        }),
    };
    
    match validator.validate_blob_transaction(&mut no_blobs_tx, B256::random()) {
        Err(BlobError::NoBlobs) => println!("✓ No blobs correctly rejected"),
        result => println!("✗ No blobs not caught: {:?}", result),
    }
    
    // Test case 3: Too many blobs
    let mut too_many_blobs_tx = BlobTransaction {
        from: Address::random(),
        gas_limit: 21000,
        max_fee_per_gas: 20_000_000_000,
        max_fee_per_blob_gas: 10_000_000_000,
        blob_versioned_hashes: vec![B256::random(); 10], // 10 > 6 max
        sidecar: None,
    };
    
    match validator.validate_blob_transaction(&mut too_many_blobs_tx, B256::random()) {
        Err(BlobError::TooManyBlobs) => println!("✓ Too many blobs correctly rejected"),
        result => println!("✗ Too many blobs not caught: {:?}", result),
    }
    
    // Test case 4: Re-injected transaction (sidecar in store)
    let stored_tx_hash = B256::random();
    let mut reinjected_tx = BlobTransaction {
        from: Address::random(),
        gas_limit: 21000,
        max_fee_per_gas: 20_000_000_000,
        max_fee_per_blob_gas: 10_000_000_000,
        blob_versioned_hashes: vec![versioned_hash],
        sidecar: None, // No sidecar - should find in store
    };
    
    match validator.validate_blob_transaction(&mut reinjected_tx, stored_tx_hash) {
        Ok(_) => println!("✓ Re-injected transaction found sidecar in store"),
        Err(e) => println!("✗ Re-injected transaction failed: {:?}", e),
    }
}

// Analysis: This blob validator demonstrates the complex validation required for
// EIP-4844 transactions. Key components include KZG proof verification, versioned
// hash computation, and sidecar management. The validator must handle both new
// transactions with sidecars and re-injected transactions where sidecars are stored
// separately. The cryptographic verification ensures data availability while the
// economic validation ensures proper fee payment for blob space.
```

## Questions to Ponder

1. **Validation Order**: Why does Reth perform stateless validation before stateful validation? What are the performance implications of this design choice?

2. **Fork Activation**: How does the validator handle transactions that become valid/invalid due to fork activations? Consider a blob transaction arriving before Cancun activation.

3. **Error vs Invalid**: What's the difference between `TransactionValidationOutcome::Error` and `TransactionValidationOutcome::Invalid`? When would you retry vs permanently reject?

4. **Local Transaction Privileges**: Why do local transactions get special treatment in validation? What security considerations apply to local transaction handling?

5. **Batch Validation Optimization**: How could batch validation be optimized further? Consider state provider reuse, parallel execution, and early termination strategies.