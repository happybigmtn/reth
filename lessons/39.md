# Lesson 39: Payload Building

*"Study hard what interests you the most in the most undisciplined, irreverent and original manner possible." - Richard Feynman*

## Files with Inline Comments for This Lesson
- `crates/payload/builder/src/lib.rs` - Core payload building abstractions
- `crates/payload/basic/src/lib.rs` - Basic payload job implementation
- `crates/transaction-pool/src/ordering.rs` - Transaction ordering for inclusion
- `crates/payload/basic/src/stack.rs` - Layered payload building
- `crates/payload/builder/src/service.rs` - Payload builder service

## What is Payload Building?

Payload building is the process of constructing new blocks when a validator is selected to propose. It's a race against time: the builder has ~12 seconds to create the most valuable block possible while ensuring it's valid.

```
Payload Building Flow:
┌─────────────────────────────────────────────────┐
│       Consensus Layer (Beacon Chain)            │
│  "You're the proposer! Build a block with      │
│   these attributes..."                          │
└─────────────────┬───────────────────────────────┘
                  │ forkchoiceUpdated + attrs
                  ▼
┌─────────────────────────────────────────────────┐
│         Payload Building Service                │
│  1. Create new job                              │
│  2. Start building immediately                  │
│  3. Keep improving the payload                  │
└─────────────────┬───────────────────────────────┘
                  │
        ┌─────────┴─────────┬─────────────┐
        ▼                   ▼             ▼
   Select TXs         Calculate Fees   Apply State
   from Pool          & Rewards        Changes
        │                   │             │
        └─────────┬─────────┴─────────────┘
                  ▼
┌─────────────────────────────────────────────────┐
│            Best Payload (Block)                 │
│  - Maximized fees                              │
│  - Valid state transitions                     │
│  - Ready for proposal                          │
└─────────────────────────────────────────────────┘
```

## Core Payload Building Abstractions

```rust
/// Payload building abstractions
/// Located in: crates/payload/builder/src/lib.rs

use alloy_primitives::U256;
use reth_payload_primitives::{PayloadBuilderAttributes, PayloadKind};

/// Generator for creating new payload jobs
/// LESSON 39: Job Generation
/// When CL requests a new payload, we create a job that:
/// 1. Tracks the building process
/// 2. Continuously improves the payload
/// 3. Can be resolved when CL calls getPayload
pub trait PayloadJobGenerator: Send + Sync {
    /// The job type this generator creates
    type Job: PayloadJob;
    
    /// Create new payload job from attributes
    fn new_payload_job(
        &self,
        attr: <Self::Job as PayloadJob>::PayloadAttributes,
    ) -> Result<Self::Job, PayloadBuilderError>;
}

/// A job that builds and improves payloads over time
pub trait PayloadJob: Future<Output = Result<(), PayloadBuilderError>> + Send + Sync {
    /// The payload attributes this job is building with
    type PayloadAttributes: PayloadBuilderAttributes;
    
    /// The built payload type
    type BuiltPayload: BuiltPayload;
    
    /// Future that resolves to final payload
    type ResolvePayloadFuture: Future<Output = Result<Self::BuiltPayload, PayloadBuilderError>>;
    
    /// Get the best payload built so far
    /// LESSON 39: Continuous Improvement
    /// This is called periodically to get better payloads
    /// as more transactions arrive or gas prices change
    fn best_payload(&self) -> Result<Self::BuiltPayload, PayloadBuilderError>;
    
    /// Resolve the job to final payload
    fn resolve_kind(
        &mut self,
        kind: PayloadKind,
    ) -> (Self::ResolvePayloadFuture, KeepPayloadJobAlive);
    
    /// Get the attributes this job is building with
    fn payload_attributes(&self) -> Result<Self::PayloadAttributes, PayloadBuilderError>;
}

/// Built payload with value information
pub trait BuiltPayload: Send + Sync + fmt::Debug {
    /// Get the block (sealed)
    fn block(&self) -> Arc<SealedBlock>;
    
    /// Get total fees earned by this payload
    /// LESSON 39: Payload Value
    /// This is what the validator earns from the block:
    /// - Priority fees (tips) from transactions  
    /// - MEV value from transaction ordering
    fn fees(&self) -> U256;
    
    /// Get the built block
    fn seal_block(&self) -> Arc<SealedBlock> {
        self.block()
    }
}

/// Attributes for building a new payload
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct EthPayloadBuilderAttributes {
    /// Payload ID from CL
    pub id: PayloadId,
    /// Parent block hash
    pub parent: B256,
    /// Block timestamp
    pub timestamp: u64,
    /// Suggested fee recipient (validator)
    pub suggested_fee_recipient: Address,
    /// Randomness from beacon chain
    pub prev_randao: B256,
    /// Withdrawals to process
    pub withdrawals: Vec<Withdrawal>,
    /// Parent beacon block root (4788)
    pub parent_beacon_block_root: Option<B256>,
}
```

## Basic Payload Job Implementation

```rust
/// Basic payload job that builds continuously
/// Located in: crates/payload/basic/src/lib.rs

pub struct BasicPayloadJob<Builder> {
    /// Payload attributes from CL
    attributes: Arc<dyn PayloadBuilderAttributes>,
    /// Handle to the builder task
    builder_task: CancelOnDrop<()>,
    /// Current best payload
    best_payload: PayloadStorage,
    /// Pending payload being built
    pending_payload: Option<PendingPayload>,
    /// Cached state reads
    cached_reads: CachedReads,
    /// Metrics
    metrics: PayloadBuilderMetrics,
}

impl<Builder> BasicPayloadJob<Builder> {
    /// Build initial payload when job starts
    /// LESSON 39: Initial Build
    /// We immediately build a payload so we have something
    /// even if getPayload is called right away
    async fn build_initial_payload(&mut self) -> Result<(), PayloadBuilderError> {
        let start = Instant::now();
        
        // Get parent block state
        let parent_header = self.client
            .sealed_header_by_hash(self.attributes.parent())?
            .ok_or(PayloadBuilderError::MissingParent)?;
        
        // Create state provider at parent
        let state_provider = self.client
            .state_provider_at(parent_header.hash())?;
        
        // Build the payload
        let outcome = self.builder.build_payload(BuildArguments {
            attributes: &self.attributes,
            parent: &parent_header,
            state: state_provider,
            cached_reads: Some(&self.cached_reads),
            cancel: None,
        })?;
        
        // Calculate fees
        let fees = self.calculate_fees(&outcome.block);
        
        // Store as best payload
        self.best_payload.update(BuiltPayload::new(
            self.attributes.id(),
            outcome.block,
            fees,
        ));
        
        self.metrics.record_build_time(start.elapsed());
        
        Ok(())
    }
    
    /// Keep building better payloads
    /// LESSON 39: Continuous Building Strategy
    /// We rebuild periodically to:
    /// 1. Include new high-value transactions
    /// 2. Remove transactions that became invalid
    /// 3. Adjust for changing gas prices
    fn spawn_build_task(&mut self) -> JoinHandle<()> {
        let builder = self.builder.clone();
        let attributes = self.attributes.clone();
        let client = self.client.clone();
        let payload_tx = self.best_payload.sender();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(BUILD_INTERVAL);
            let deadline = Instant::now() + MAX_BUILD_TIME;
            
            loop {
                tokio::select! {
                    _ = interval.tick() => {
                        // Rebuild with latest transactions
                        if let Ok(new_payload) = build_better_payload(&builder, &attributes, &client).await {
                            let _ = payload_tx.send(new_payload);
                        }
                    }
                    _ = tokio::time::sleep_until(deadline) => {
                        // Stop building after deadline
                        break;
                    }
                }
            }
        })
    }
}

impl<Builder> PayloadJob for BasicPayloadJob<Builder> {
    type PayloadAttributes = EthPayloadBuilderAttributes;
    type BuiltPayload = EthBuiltPayload;
    
    fn best_payload(&self) -> Result<Self::BuiltPayload, PayloadBuilderError> {
        self.best_payload
            .get()
            .ok_or(PayloadBuilderError::NoBestPayload)
    }
    
    fn resolve_kind(
        &mut self,
        kind: PayloadKind,
    ) -> (Self::ResolvePayloadFuture, KeepPayloadJobAlive) {
        match kind {
            PayloadKind::Earliest => {
                // Return immediately with current best
                let payload = self.best_payload();
                (Box::pin(async move { payload }), KeepPayloadJobAlive::No)
            }
            PayloadKind::WaitForPending => {
                // Wait for pending build to complete
                if let Some(pending) = self.pending_payload.take() {
                    (Box::pin(pending.wait()), KeepPayloadJobAlive::No)
                } else {
                    let payload = self.best_payload();
                    (Box::pin(async move { payload }), KeepPayloadJobAlive::No)
                }
            }
        }
    }
}

/// Thread-safe storage for best payload
struct PayloadStorage {
    best: Arc<RwLock<Option<EthBuiltPayload>>>,
    update_tx: mpsc::UnboundedSender<EthBuiltPayload>,
}

impl PayloadStorage {
    fn update(&self, payload: EthBuiltPayload) -> bool {
        let mut guard = self.best.write();
        
        // Only update if new payload is better
        if let Some(current) = &*guard {
            if payload.fees() <= current.fees() {
                return false;
            }
        }
        
        *guard = Some(payload.clone());
        let _ = self.update_tx.send(payload);
        true
    }
}
```

## Transaction Selection and Ordering

```rust
/// Transaction ordering for payload building
/// Located in: crates/transaction-pool/src/ordering.rs

use alloy_primitives::U256;

/// Determines transaction order in blocks
/// LESSON 39: Transaction Prioritization
/// The default strategy maximizes validator revenue
/// by ordering transactions by their tips
pub trait TransactionOrdering: Send + Sync + 'static {
    /// Priority value type
    type PriorityValue: Ord + Clone + Default + Debug;
    
    /// Transaction type
    type Transaction: PoolTransaction;
    
    /// Calculate priority for transaction
    fn priority(
        &self,
        transaction: &Self::Transaction,
        base_fee: u64,
    ) -> Priority<Self::PriorityValue>;
}

/// Default ordering by coinbase tip
#[derive(Debug, Default)]
pub struct CoinbaseTipOrdering<T>(PhantomData<T>);

impl<T: PoolTransaction> TransactionOrdering for CoinbaseTipOrdering<T> {
    type PriorityValue = U256;
    type Transaction = T;
    
    /// Priority = effective tip per gas
    /// LESSON 39: Fee Calculation
    /// For EIP-1559 transactions:
    /// tip = min(max_fee - base_fee, max_priority_fee)
    /// Higher tips = higher priority = included first
    fn priority(
        &self,
        transaction: &Self::Transaction,
        base_fee: u64,
    ) -> Priority<Self::PriorityValue> {
        transaction
            .effective_tip_per_gas(base_fee)
            .map(U256::from)
            .into()
    }
}

/// MEV-aware ordering that considers bundles
pub struct MevAwareOrdering<T> {
    /// Base ordering strategy
    base: CoinbaseTipOrdering<T>,
    /// Bundle evaluator
    bundle_scorer: BundleScorer,
}

impl<T: PoolTransaction> MevAwareOrdering<T> {
    /// Evaluate transaction considering MEV opportunities
    fn evaluate_with_mev(
        &self,
        tx: &T,
        pool_state: &PoolState,
    ) -> MevPriority {
        // Check if tx is part of a bundle
        if let Some(bundle_id) = pool_state.tx_bundle_map.get(&tx.hash()) {
            let bundle = &pool_state.bundles[bundle_id];
            
            // Calculate bundle value
            let bundle_value = self.bundle_scorer.score(bundle);
            
            // Amortize value across bundle transactions
            let tx_share = bundle_value / bundle.len() as u64;
            
            MevPriority {
                base_priority: self.base.priority(tx, pool_state.base_fee),
                mev_boost: U256::from(tx_share),
                is_bundle: true,
            }
        } else {
            MevPriority {
                base_priority: self.base.priority(tx, pool_state.base_fee),
                mev_boost: U256::ZERO,
                is_bundle: false,
            }
        }
    }
}
```

## Payload Building Strategy

```rust
/// Core payload building logic
pub struct PayloadBuilder {
    /// Transaction pool
    pool: Arc<TransactionPool>,
    /// EVM configuration
    evm_config: Arc<EvmConfig>,
    /// Block building strategy
    strategy: BuildingStrategy,
}

impl PayloadBuilder {
    /// Build the best possible payload
    pub fn build_payload(
        &self,
        args: BuildArguments,
    ) -> Result<BuildOutcome, PayloadBuilderError> {
        let BuildArguments {
            attributes,
            parent,
            state,
            cached_reads,
            cancel,
        } = args;
        
        // Initialize block environment
        let mut block_env = BlockEnv {
            number: parent.number + 1,
            timestamp: attributes.timestamp,
            gas_limit: self.calculate_gas_limit(parent),
            base_fee: self.calculate_base_fee(parent),
            difficulty: U256::ZERO, // Post-merge
            prevrandao: Some(attributes.prev_randao),
            coinbase: attributes.suggested_fee_recipient,
            ..Default::default()
        };
        
        // Initialize EVM with cached state
        let mut evm = self.evm_config.create_evm(
            state,
            block_env.clone(),
            cached_reads,
        );
        
        // Apply pre-block system calls
        self.apply_system_calls(&mut evm, attributes)?;
        
        // LESSON 39: Transaction Inclusion Loop
        // We try to include as many valuable transactions as possible
        // until we run out of gas or time
        let mut cumulative_gas_used = 0;
        let mut transactions = Vec::new();
        let mut receipts = Vec::new();
        let mut total_fees = U256::ZERO;
        
        // Get transactions ordered by priority
        let tx_iter = self.pool.best_transactions_with_ordering(
            self.strategy.ordering(),
            block_env.base_fee,
        );
        
        for tx in tx_iter {
            // Check if cancelled
            if let Some(cancel) = &cancel {
                if cancel.is_cancelled() {
                    break;
                }
            }
            
            // Check gas limit
            if cumulative_gas_used + tx.gas_limit() > block_env.gas_limit {
                continue; // Skip, try smaller transactions
            }
            
            // Try to execute transaction
            match self.execute_transaction(&mut evm, &tx) {
                Ok(result) => {
                    cumulative_gas_used += result.gas_used;
                    total_fees += calculate_tx_fee(&tx, result.gas_used, block_env.base_fee);
                    
                    transactions.push(tx);
                    receipts.push(result.receipt);
                }
                Err(e) => {
                    // Transaction failed, skip it
                    debug!(
                        target: "payload_builder",
                        tx_hash = ?tx.hash(),
                        error = ?e,
                        "Skipping invalid transaction"
                    );
                    
                    // Mark for removal from pool
                    self.pool.mark_invalid(&tx);
                }
            }
        }
        
        // Apply post-block system calls (e.g., block rewards)
        self.apply_post_block_calls(&mut evm, &attributes)?;
        
        // Build final block
        let block = self.finalize_block(
            attributes,
            parent,
            transactions,
            receipts,
            &evm,
        )?;
        
        Ok(BuildOutcome {
            block,
            total_fees,
            cached_reads: evm.take_cached_reads(),
        })
    }
    
    /// Calculate base fee for new block
    fn calculate_base_fee(&self, parent: &SealedHeader) -> u64 {
        // EIP-1559 base fee calculation
        let parent_gas_used = parent.gas_used;
        let parent_gas_target = parent.gas_limit / 2;
        let parent_base_fee = parent.base_fee_per_gas.unwrap_or(0);
        
        if parent_gas_used == parent_gas_target {
            parent_base_fee
        } else if parent_gas_used > parent_gas_target {
            // Increase base fee
            let gas_delta = parent_gas_used - parent_gas_target;
            let fee_delta = parent_base_fee * gas_delta / parent_gas_target / 8;
            parent_base_fee + fee_delta.max(1)
        } else {
            // Decrease base fee
            let gas_delta = parent_gas_target - parent_gas_used;
            let fee_delta = parent_base_fee * gas_delta / parent_gas_target / 8;
            parent_base_fee.saturating_sub(fee_delta)
        }
    }
}

/// Building strategy configuration
#[derive(Debug, Clone)]
pub struct BuildingStrategy {
    /// Maximum time to spend building
    pub max_build_time: Duration,
    /// How to order transactions
    pub ordering: Box<dyn TransactionOrdering>,
    /// Whether to enable MEV features
    pub enable_mev: bool,
}
```

## Assignment 1: Dynamic Fee Estimator

Create a system that dynamically adjusts fee estimates during payload building.

```rust
/// Dynamic fee estimation during payload building
pub struct DynamicFeeEstimator {
    /// Historical fee data
    fee_history: VecDeque<BlockFeeData>,
    /// Current mempool state
    mempool_analyzer: MempoolAnalyzer,
    /// Prediction model
    predictor: FeePredictor,
}

#[derive(Clone)]
pub struct BlockFeeData {
    pub block_number: u64,
    pub base_fee: u64,
    pub gas_used: u64,
    pub priority_fees: Vec<u64>,
    pub timestamp: u64,
}

pub struct FeeEstimate {
    pub base_fee: u64,
    pub suggested_tip: u64,
    pub confidence: f64,
    pub estimated_wait_blocks: u64,
}

impl DynamicFeeEstimator {
    pub fn new(history_size: usize) -> Self {
        // Your implementation here
        todo!()
    }
    
    /// Update estimates based on new block
    pub fn update_from_block(&mut self, block: &SealedBlock, receipts: &[Receipt]) {
        // Your implementation here
        todo!()
    }
    
    /// Estimate fees for next block
    pub fn estimate_next_block(&self, time_until_block: Duration) -> FeeEstimate {
        // Your implementation here
        todo!()
    }
    
    /// Suggest minimum tip for inclusion
    pub fn suggest_minimum_tip(&self, gas_limit: u64) -> u64 {
        // Your implementation here
        todo!()
    }
}

pub struct MempoolAnalyzer {
    /// Analyze current mempool state
    pub fn analyze_congestion(&self, pool: &TransactionPool) -> CongestionLevel {
        // Your implementation here
        todo!()
    }
}

#[derive(Debug, PartialEq)]
pub enum CongestionLevel {
    Low,
    Medium,
    High,
    Critical,
}
```

## Assignment 2: MEV-Aware Builder

Implement a payload builder that can handle MEV bundles and private transactions.

```rust
/// MEV-aware payload builder
pub struct MevPayloadBuilder {
    /// Base builder
    base_builder: BasicPayloadBuilder,
    /// Bundle pool
    bundle_pool: BundlePool,
    /// Private transaction pool
    private_pool: PrivateTransactionPool,
    /// Simulation engine
    simulator: BundleSimulator,
}

#[derive(Clone)]
pub struct Bundle {
    pub id: BundleId,
    pub transactions: Vec<Transaction>,
    pub min_timestamp: Option<u64>,
    pub max_timestamp: Option<u64>,
    pub reverting_tx_hashes: Vec<B256>,
}

pub struct BundleSimulationResult {
    pub gas_used: u64,
    pub coinbase_profit: U256,
    pub reverted_txs: Vec<B256>,
    pub state_changes: StateChanges,
}

impl MevPayloadBuilder {
    pub fn new(
        base_builder: BasicPayloadBuilder,
        bundle_pool: BundlePool,
        private_pool: PrivateTransactionPool,
    ) -> Self {
        // Your implementation here
        todo!()
    }
    
    /// Build MEV-optimized payload
    pub async fn build_mev_payload(
        &self,
        args: BuildArguments,
    ) -> Result<MevBuildOutcome, PayloadBuilderError> {
        // Your implementation here
        todo!()
    }
    
    /// Simulate and score bundles
    async fn evaluate_bundles(
        &self,
        bundles: Vec<Bundle>,
        state: &State,
        block_env: &BlockEnv,
    ) -> Vec<(Bundle, BundleSimulationResult)> {
        // Your implementation here
        todo!()
    }
    
    /// Merge bundles with regular transactions
    fn merge_bundles_and_txs(
        &self,
        bundles: Vec<(Bundle, BundleSimulationResult)>,
        regular_txs: Vec<Transaction>,
        gas_limit: u64,
    ) -> Vec<Transaction> {
        // Your implementation here
        todo!()
    }
}

pub struct MevBuildOutcome {
    pub block: SealedBlock,
    pub total_fees: U256,
    pub mev_profit: U256,
    pub bundles_included: Vec<BundleId>,
}
```

## Assignment 3: Adaptive Building Strategy

Design a payload building strategy that adapts based on network conditions.

```rust
/// Adaptive payload building strategy
pub struct AdaptivePayloadStrategy {
    /// Current strategy parameters
    params: Arc<RwLock<StrategyParams>>,
    /// Network monitor
    network_monitor: NetworkMonitor,
    /// Performance tracker
    performance: PerformanceTracker,
}

#[derive(Clone)]
pub struct StrategyParams {
    pub target_gas_usage: f64,
    pub min_tip_threshold: u64,
    pub max_build_time: Duration,
    pub enable_aggressive_packing: bool,
    pub priority_addresses: HashSet<Address>,
}

#[derive(Default)]
pub struct PerformanceMetrics {
    pub blocks_built: u64,
    pub average_gas_usage: f64,
    pub average_build_time: Duration,
    pub inclusion_rate: f64,
    pub reorg_count: u64,
}

impl AdaptivePayloadStrategy {
    pub fn new(initial_params: StrategyParams) -> Self {
        // Your implementation here
        todo!()
    }
    
    /// Adapt strategy based on recent performance
    pub fn adapt_strategy(&mut self) {
        // Your implementation here
        todo!()
    }
    
    /// Build with adaptive strategy
    pub async fn build_adaptive(
        &self,
        builder: &PayloadBuilder,
        args: BuildArguments,
    ) -> Result<AdaptiveBuildOutcome, PayloadBuilderError> {
        // Your implementation here
        todo!()
    }
    
    /// Update metrics after block
    pub fn record_outcome(&mut self, outcome: BuildOutcome, included: bool) {
        // Your implementation here
        todo!()
    }
}

pub struct NetworkMonitor {
    /// Estimate network congestion
    pub fn estimate_congestion(&self) -> NetworkCongestion {
        // Your implementation here
        todo!()
    }
    
    /// Predict reorg probability
    pub fn reorg_risk(&self) -> f64 {
        // Your implementation here
        todo!()
    }
}

#[derive(Debug)]
pub struct NetworkCongestion {
    pub mempool_size: usize,
    pub avg_gas_price: u64,
    pub pending_tx_count: usize,
    pub block_fill_rate: f64,
}

pub struct AdaptiveBuildOutcome {
    pub outcome: BuildOutcome,
    pub strategy_used: StrategyParams,
    pub adaptation_metrics: AdaptationMetrics,
}

#[derive(Debug)]
pub struct AdaptationMetrics {
    pub gas_efficiency: f64,
    pub build_time_ratio: f64,
    pub strategy_changes: Vec<String>,
}
```

## Assignment Answers

### Assignment 1: Dynamic Fee Estimator

```rust
use std::collections::VecDeque;
use std::time::Duration;

/// Dynamic fee estimation during payload building
pub struct DynamicFeeEstimator {
    /// Historical fee data
    fee_history: VecDeque<BlockFeeData>,
    /// Maximum history size
    max_history: usize,
    /// Current mempool state analyzer
    mempool_analyzer: MempoolAnalyzer,
    /// Prediction model
    predictor: FeePredictor,
}

#[derive(Clone)]
pub struct BlockFeeData {
    pub block_number: u64,
    pub base_fee: u64,
    pub gas_used: u64,
    pub priority_fees: Vec<u64>,
    pub timestamp: u64,
}

#[derive(Debug)]
pub struct FeeEstimate {
    pub base_fee: u64,
    pub suggested_tip: u64,
    pub confidence: f64,
    pub estimated_wait_blocks: u64,
}

impl DynamicFeeEstimator {
    pub fn new(history_size: usize) -> Self {
        Self {
            fee_history: VecDeque::with_capacity(history_size),
            max_history: history_size,
            mempool_analyzer: MempoolAnalyzer::new(),
            predictor: FeePredictor::new(),
        }
    }
    
    /// Update estimates based on new block
    pub fn update_from_block(&mut self, block: &SealedBlock, receipts: &[Receipt]) {
        // Extract priority fees from receipts
        let mut priority_fees = Vec::new();
        for (tx, receipt) in block.body.transactions.iter().zip(receipts) {
            if receipt.success {
                let priority_fee = tx.effective_tip_per_gas(block.header.base_fee_per_gas.unwrap_or(0));
                priority_fees.push(priority_fee);
            }
        }
        
        priority_fees.sort_unstable();
        
        let fee_data = BlockFeeData {
            block_number: block.header.number,
            base_fee: block.header.base_fee_per_gas.unwrap_or(0),
            gas_used: block.header.gas_used,
            priority_fees,
            timestamp: block.header.timestamp,
        };
        
        // Add to history
        self.fee_history.push_back(fee_data);
        
        // Maintain history size
        while self.fee_history.len() > self.max_history {
            self.fee_history.pop_front();
        }
        
        // Update predictor model
        self.predictor.update(&self.fee_history);
    }
    
    /// Estimate fees for next block
    pub fn estimate_next_block(&self, time_until_block: Duration) -> FeeEstimate {
        if self.fee_history.is_empty() {
            return FeeEstimate {
                base_fee: 1_000_000_000, // 1 gwei default
                suggested_tip: 2_000_000_000, // 2 gwei default
                confidence: 0.0,
                estimated_wait_blocks: 1,
            };
        }
        
        // Predict base fee using EIP-1559 formula
        let last_block = self.fee_history.back().unwrap();
        let predicted_base_fee = self.predict_base_fee(last_block);
        
        // Analyze recent priority fee trends
        let tip_percentiles = self.calculate_tip_percentiles();
        
        // Adjust based on mempool congestion
        let congestion = self.mempool_analyzer.analyze_congestion(&self.fee_history);
        let congestion_multiplier = match congestion {
            CongestionLevel::Low => 0.8,
            CongestionLevel::Medium => 1.0,
            CongestionLevel::High => 1.5,
            CongestionLevel::Critical => 2.0,
        };
        
        // Time-based adjustment
        let time_factor = (12.0 / time_until_block.as_secs_f64()).min(2.0).max(0.5);
        
        let suggested_tip = (tip_percentiles.p50 as f64 * congestion_multiplier * time_factor) as u64;
        
        // Estimate wait time based on tip level
        let estimated_wait = self.estimate_wait_blocks(suggested_tip, &tip_percentiles);
        
        // Calculate confidence based on data quality
        let confidence = self.calculate_confidence();
        
        FeeEstimate {
            base_fee: predicted_base_fee,
            suggested_tip,
            confidence,
            estimated_wait_blocks: estimated_wait,
        }
    }
    
    /// Suggest minimum tip for inclusion
    pub fn suggest_minimum_tip(&self, gas_limit: u64) -> u64 {
        let percentiles = self.calculate_tip_percentiles();
        
        // For high gas transactions, need higher tips
        let gas_factor = (gas_limit as f64 / 21_000.0).sqrt();
        
        // Start with 25th percentile as minimum
        let base_tip = percentiles.p25;
        
        // Adjust for gas usage
        (base_tip as f64 * gas_factor) as u64
    }
    
    fn predict_base_fee(&self, last_block: &BlockFeeData) -> u64 {
        let target_gas = 15_000_000; // Target gas (half of limit)
        let elasticity = 2;
        let denominator = 8;
        
        if last_block.gas_used == target_gas {
            last_block.base_fee
        } else if last_block.gas_used > target_gas {
            let delta = last_block.gas_used - target_gas;
            let base_fee_delta = (last_block.base_fee * delta) / target_gas / denominator;
            last_block.base_fee + base_fee_delta.max(1)
        } else {
            let delta = target_gas - last_block.gas_used;
            let base_fee_delta = (last_block.base_fee * delta) / target_gas / denominator;
            last_block.base_fee.saturating_sub(base_fee_delta)
        }
    }
    
    fn calculate_tip_percentiles(&self) -> TipPercentiles {
        let mut all_tips = Vec::new();
        
        for block in &self.fee_history {
            all_tips.extend(&block.priority_fees);
        }
        
        all_tips.sort_unstable();
        
        if all_tips.is_empty() {
            return TipPercentiles::default();
        }
        
        TipPercentiles {
            p10: all_tips[all_tips.len() / 10],
            p25: all_tips[all_tips.len() / 4],
            p50: all_tips[all_tips.len() / 2],
            p75: all_tips[all_tips.len() * 3 / 4],
            p90: all_tips[all_tips.len() * 9 / 10],
        }
    }
    
    fn estimate_wait_blocks(&self, tip: u64, percentiles: &TipPercentiles) -> u64 {
        if tip >= percentiles.p75 {
            1 // Next block
        } else if tip >= percentiles.p50 {
            2 // 1-2 blocks
        } else if tip >= percentiles.p25 {
            5 // 3-5 blocks
        } else {
            10 // May take a while
        }
    }
    
    fn calculate_confidence(&self) -> f64 {
        let data_points = self.fee_history.len();
        let max_history = self.max_history;
        
        // Confidence based on data availability
        let data_confidence = (data_points as f64 / max_history as f64).min(1.0);
        
        // Confidence based on variance
        let variance_confidence = self.predictor.model_confidence();
        
        (data_confidence * 0.7 + variance_confidence * 0.3).min(0.95)
    }
}

pub struct MempoolAnalyzer {
    fn new() -> Self {
        Self {}
    }
    
    /// Analyze current mempool state
    pub fn analyze_congestion(&self, history: &VecDeque<BlockFeeData>) -> CongestionLevel {
        if history.len() < 3 {
            return CongestionLevel::Medium;
        }
        
        // Check recent gas usage
        let recent_usage: Vec<f64> = history
            .iter()
            .rev()
            .take(5)
            .map(|b| b.gas_used as f64 / 30_000_000.0)
            .collect();
        
        let avg_usage = recent_usage.iter().sum::<f64>() / recent_usage.len() as f64;
        
        if avg_usage > 0.95 {
            CongestionLevel::Critical
        } else if avg_usage > 0.85 {
            CongestionLevel::High
        } else if avg_usage > 0.60 {
            CongestionLevel::Medium
        } else {
            CongestionLevel::Low
        }
    }
}

#[derive(Debug, PartialEq)]
pub enum CongestionLevel {
    Low,
    Medium,
    High,
    Critical,
}

struct TipPercentiles {
    p10: u64,
    p25: u64,
    p50: u64,
    p75: u64,
    p90: u64,
}

impl Default for TipPercentiles {
    fn default() -> Self {
        Self {
            p10: 1_000_000_000,
            p25: 1_500_000_000,
            p50: 2_000_000_000,
            p75: 3_000_000_000,
            p90: 5_000_000_000,
        }
    }
}

struct FeePredictor {
    model_confidence: f64,
}

impl FeePredictor {
    fn new() -> Self {
        Self { model_confidence: 0.5 }
    }
    
    fn update(&mut self, history: &VecDeque<BlockFeeData>) {
        // Update model based on prediction accuracy
        self.model_confidence = (history.len() as f64 / 100.0).min(0.9);
    }
    
    fn model_confidence(&self) -> f64 {
        self.model_confidence
    }
}
```

### Assignment 2: MEV-Aware Builder

```rust
use alloy_primitives::{Address, B256, U256};
use std::collections::{HashMap, HashSet};

/// MEV-aware payload builder
pub struct MevPayloadBuilder {
    /// Base builder
    base_builder: BasicPayloadBuilder,
    /// Bundle pool
    bundle_pool: BundlePool,
    /// Private transaction pool
    private_pool: PrivateTransactionPool,
    /// Simulation engine
    simulator: BundleSimulator,
    /// MEV configuration
    config: MevConfig,
}

#[derive(Clone)]
pub struct Bundle {
    pub id: BundleId,
    pub transactions: Vec<Transaction>,
    pub min_timestamp: Option<u64>,
    pub max_timestamp: Option<u64>,
    pub reverting_tx_hashes: Vec<B256>,
    pub signer: Address,
    pub min_profit: U256,
}

#[derive(Debug)]
pub struct BundleSimulationResult {
    pub gas_used: u64,
    pub coinbase_profit: U256,
    pub reverted_txs: Vec<B256>,
    pub state_changes: StateChanges,
}

#[derive(Clone)]
pub struct MevConfig {
    pub min_bundle_profit: U256,
    pub max_simulation_time: Duration,
    pub enable_bundle_merging: bool,
    pub flashbot_relay_url: Option<String>,
}

impl MevPayloadBuilder {
    pub fn new(
        base_builder: BasicPayloadBuilder,
        bundle_pool: BundlePool,
        private_pool: PrivateTransactionPool,
        config: MevConfig,
    ) -> Self {
        Self {
            base_builder,
            bundle_pool,
            private_pool,
            simulator: BundleSimulator::new(),
            config,
        }
    }
    
    /// Build MEV-optimized payload
    pub async fn build_mev_payload(
        &self,
        args: BuildArguments,
    ) -> Result<MevBuildOutcome, PayloadBuilderError> {
        let BuildArguments {
            attributes,
            parent,
            state,
            cached_reads,
            cancel,
        } = args;
        
        // Get eligible bundles
        let bundles = self.get_eligible_bundles(attributes.timestamp);
        
        // Get private transactions
        let private_txs = self.private_pool.get_transactions();
        
        // Get regular transactions from public pool
        let public_txs = self.base_builder.pool.best_transactions();
        
        // Create simulation environment
        let mut sim_state = SimulationState::new(state.clone(), cached_reads);
        let block_env = self.base_builder.create_block_env(&attributes, &parent);
        
        // Evaluate bundles
        let evaluated_bundles = self.evaluate_bundles(
            bundles,
            &mut sim_state,
            &block_env,
        ).await?;
        
        // Score and sort bundles by profit
        let mut scored_bundles: Vec<_> = evaluated_bundles
            .into_iter()
            .filter(|(_, result)| result.coinbase_profit >= self.config.min_bundle_profit)
            .collect();
        
        scored_bundles.sort_by_key(|(_, result)| std::cmp::Reverse(result.coinbase_profit));
        
        // Build optimal transaction sequence
        let tx_sequence = self.build_optimal_sequence(
            scored_bundles,
            private_txs,
            public_txs,
            block_env.gas_limit,
            &mut sim_state,
        )?;
        
        // Execute final sequence
        let outcome = self.base_builder.execute_transactions(
            tx_sequence.transactions,
            args,
        )?;
        
        Ok(MevBuildOutcome {
            block: outcome.block,
            total_fees: outcome.total_fees,
            mev_profit: tx_sequence.mev_profit,
            bundles_included: tx_sequence.bundles_included,
        })
    }
    
    /// Get bundles eligible for inclusion
    fn get_eligible_bundles(&self, block_timestamp: u64) -> Vec<Bundle> {
        self.bundle_pool
            .get_bundles()
            .into_iter()
            .filter(|bundle| {
                // Check timestamp constraints
                if let Some(min_ts) = bundle.min_timestamp {
                    if block_timestamp < min_ts {
                        return false;
                    }
                }
                if let Some(max_ts) = bundle.max_timestamp {
                    if block_timestamp > max_ts {
                        return false;
                    }
                }
                true
            })
            .collect()
    }
    
    /// Simulate and score bundles
    async fn evaluate_bundles(
        &self,
        bundles: Vec<Bundle>,
        state: &mut SimulationState,
        block_env: &BlockEnv,
    ) -> Result<Vec<(Bundle, BundleSimulationResult)>, PayloadBuilderError> {
        let mut results = Vec::new();
        
        for bundle in bundles {
            // Create checkpoint for rollback
            let checkpoint = state.checkpoint();
            
            // Simulate bundle execution
            match self.simulator.simulate_bundle(&bundle, state, block_env).await {
                Ok(result) => {
                    // Check if profitable
                    if result.coinbase_profit >= bundle.min_profit {
                        results.push((bundle, result));
                    }
                }
                Err(e) => {
                    debug!(
                        target: "mev_builder",
                        bundle_id = ?bundle.id,
                        error = ?e,
                        "Bundle simulation failed"
                    );
                }
            }
            
            // Rollback state
            state.revert_to_checkpoint(checkpoint);
        }
        
        Ok(results)
    }
    
    /// Build optimal transaction sequence
    fn build_optimal_sequence(
        &self,
        mut bundles: Vec<(Bundle, BundleSimulationResult)>,
        private_txs: Vec<Transaction>,
        public_txs: Vec<Transaction>,
        gas_limit: u64,
        state: &mut SimulationState,
    ) -> Result<TransactionSequence, PayloadBuilderError> {
        let mut sequence = TransactionSequence::new();
        let mut used_gas = 0;
        let mut included_tx_hashes = HashSet::new();
        
        // First, try to include profitable bundles
        for (bundle, result) in bundles {
            if used_gas + result.gas_used > gas_limit {
                continue;
            }
            
            // Check for conflicts with already included transactions
            let has_conflict = bundle.transactions.iter().any(|tx| {
                included_tx_hashes.contains(&tx.hash())
            });
            
            if !has_conflict {
                // Add bundle transactions
                for tx in bundle.transactions {
                    included_tx_hashes.insert(tx.hash());
                    sequence.add_transaction(tx, true);
                }
                
                sequence.bundles_included.push(bundle.id);
                sequence.mev_profit += result.coinbase_profit;
                used_gas += result.gas_used;
            }
        }
        
        // Then add private transactions
        for tx in private_txs {
            if included_tx_hashes.contains(&tx.hash()) {
                continue;
            }
            
            if let Ok(gas) = self.simulator.estimate_gas(&tx, state) {
                if used_gas + gas <= gas_limit {
                    sequence.add_transaction(tx, false);
                    used_gas += gas;
                }
            }
        }
        
        // Finally, fill with public transactions
        for tx in public_txs {
            if included_tx_hashes.contains(&tx.hash()) {
                continue;
            }
            
            if used_gas + tx.gas_limit() <= gas_limit {
                sequence.add_transaction(tx, false);
                used_gas += tx.gas_limit();
            }
        }
        
        Ok(sequence)
    }
}

pub struct BundlePool {
    bundles: HashMap<BundleId, Bundle>,
}

impl BundlePool {
    fn get_bundles(&self) -> Vec<Bundle> {
        self.bundles.values().cloned().collect()
    }
}

pub struct PrivateTransactionPool {
    transactions: Vec<Transaction>,
}

impl PrivateTransactionPool {
    fn get_transactions(&self) -> Vec<Transaction> {
        self.transactions.clone()
    }
}

pub struct BundleSimulator {
    fn new() -> Self {
        Self {}
    }
    
    async fn simulate_bundle(
        &self,
        bundle: &Bundle,
        state: &mut SimulationState,
        block_env: &BlockEnv,
    ) -> Result<BundleSimulationResult, SimulationError> {
        let mut gas_used = 0;
        let mut coinbase_profit = U256::ZERO;
        let mut reverted_txs = Vec::new();
        let mut state_changes = StateChanges::new();
        
        let initial_coinbase_balance = state.get_balance(block_env.coinbase);
        
        for tx in &bundle.transactions {
            match state.execute_transaction(tx, block_env) {
                Ok(result) => {
                    gas_used += result.gas_used;
                    state_changes.merge(result.state_changes);
                    
                    // Check if this is a reverting tx that should revert
                    if bundle.reverting_tx_hashes.contains(&tx.hash()) && !result.reverted {
                        return Err(SimulationError::ExpectedRevert);
                    }
                }
                Err(e) => {
                    if !bundle.reverting_tx_hashes.contains(&tx.hash()) {
                        return Err(SimulationError::UnexpectedRevert(e));
                    }
                    reverted_txs.push(tx.hash());
                }
            }
        }
        
        let final_coinbase_balance = state.get_balance(block_env.coinbase);
        coinbase_profit = final_coinbase_balance.saturating_sub(initial_coinbase_balance);
        
        Ok(BundleSimulationResult {
            gas_used,
            coinbase_profit,
            reverted_txs,
            state_changes,
        })
    }
    
    fn estimate_gas(&self, tx: &Transaction, state: &SimulationState) -> Result<u64, SimulationError> {
        // Simplified gas estimation
        Ok(tx.gas_limit())
    }
}

#[derive(Debug)]
pub struct MevBuildOutcome {
    pub block: SealedBlock,
    pub total_fees: U256,
    pub mev_profit: U256,
    pub bundles_included: Vec<BundleId>,
}

struct TransactionSequence {
    transactions: Vec<Transaction>,
    mev_profit: U256,
    bundles_included: Vec<BundleId>,
    is_bundle_tx: HashMap<B256, bool>,
}

impl TransactionSequence {
    fn new() -> Self {
        Self {
            transactions: Vec::new(),
            mev_profit: U256::ZERO,
            bundles_included: Vec::new(),
            is_bundle_tx: HashMap::new(),
        }
    }
    
    fn add_transaction(&mut self, tx: Transaction, is_bundle: bool) {
        self.is_bundle_tx.insert(tx.hash(), is_bundle);
        self.transactions.push(tx);
    }
}

type BundleId = B256;

#[derive(Debug)]
enum SimulationError {
    ExecutionError(String),
    ExpectedRevert,
    UnexpectedRevert(String),
}

struct SimulationState {
    // Simplified state tracking
    balances: HashMap<Address, U256>,
    storage: HashMap<(Address, U256), U256>,
}

impl SimulationState {
    fn new(_state: Box<dyn StateProvider>, _cached: Option<CachedReads>) -> Self {
        Self {
            balances: HashMap::new(),
            storage: HashMap::new(),
        }
    }
    
    fn checkpoint(&self) -> StateCheckpoint {
        StateCheckpoint {
            balances: self.balances.clone(),
            storage: self.storage.clone(),
        }
    }
    
    fn revert_to_checkpoint(&mut self, checkpoint: StateCheckpoint) {
        self.balances = checkpoint.balances;
        self.storage = checkpoint.storage;
    }
    
    fn get_balance(&self, address: Address) -> U256 {
        self.balances.get(&address).copied().unwrap_or(U256::ZERO)
    }
    
    fn execute_transaction(&mut self, _tx: &Transaction, _env: &BlockEnv) -> Result<ExecutionResult, String> {
        // Simplified execution
        Ok(ExecutionResult {
            gas_used: 21000,
            reverted: false,
            state_changes: StateChanges::new(),
        })
    }
}

struct StateCheckpoint {
    balances: HashMap<Address, U256>,
    storage: HashMap<(Address, U256), U256>,
}

struct ExecutionResult {
    gas_used: u64,
    reverted: bool,
    state_changes: StateChanges,
}

#[derive(Default)]
struct StateChanges {
    balance_changes: HashMap<Address, U256>,
    storage_changes: HashMap<(Address, U256), U256>,
}

impl StateChanges {
    fn new() -> Self {
        Self::default()
    }
    
    fn merge(&mut self, other: StateChanges) {
        self.balance_changes.extend(other.balance_changes);
        self.storage_changes.extend(other.storage_changes);
    }
}
```

### Assignment 3: Adaptive Building Strategy

```rust
use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};

/// Adaptive payload building strategy
pub struct AdaptivePayloadStrategy {
    /// Current strategy parameters
    params: Arc<RwLock<StrategyParams>>,
    /// Network monitor
    network_monitor: NetworkMonitor,
    /// Performance tracker
    performance: Arc<RwLock<PerformanceTracker>>,
    /// Adaptation history
    adaptation_history: Arc<RwLock<VecDeque<AdaptationEvent>>>,
}

#[derive(Clone, Debug)]
pub struct StrategyParams {
    pub target_gas_usage: f64,
    pub min_tip_threshold: u64,
    pub max_build_time: Duration,
    pub enable_aggressive_packing: bool,
    pub priority_addresses: HashSet<Address>,
    pub reorg_protection_depth: u64,
    pub mev_optimization_level: MevLevel,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum MevLevel {
    Disabled,
    Conservative,
    Moderate,
    Aggressive,
}

#[derive(Default)]
pub struct PerformanceMetrics {
    pub blocks_built: u64,
    pub average_gas_usage: f64,
    pub average_build_time: Duration,
    pub inclusion_rate: f64,
    pub reorg_count: u64,
    pub average_profit: U256,
}

impl AdaptivePayloadStrategy {
    pub fn new(initial_params: StrategyParams) -> Self {
        Self {
            params: Arc::new(RwLock::new(initial_params)),
            network_monitor: NetworkMonitor::new(),
            performance: Arc::new(RwLock::new(PerformanceTracker::new())),
            adaptation_history: Arc::new(RwLock::new(VecDeque::with_capacity(100))),
        }
    }
    
    /// Adapt strategy based on recent performance
    pub fn adapt_strategy(&mut self) {
        let metrics = self.performance.read().unwrap().get_metrics();
        let network_state = self.network_monitor.get_state();
        
        let mut params = self.params.write().unwrap();
        let mut adaptations = Vec::new();
        
        // Adapt gas usage target
        if metrics.average_gas_usage < 0.7 && network_state.congestion.block_fill_rate > 0.9 {
            // Network is congested but we're not using enough gas
            params.target_gas_usage = (params.target_gas_usage * 1.1).min(0.98);
            adaptations.push("Increased target gas usage".to_string());
        } else if metrics.average_gas_usage > 0.95 && metrics.inclusion_rate < 0.8 {
            // We're packing too aggressively and getting excluded
            params.target_gas_usage *= 0.95;
            adaptations.push("Decreased target gas usage".to_string());
        }
        
        // Adapt tip threshold based on inclusion rate
        if metrics.inclusion_rate < 0.7 {
            // Too many blocks excluded, increase min tip
            params.min_tip_threshold = (params.min_tip_threshold as f64 * 1.2) as u64;
            adaptations.push("Increased minimum tip threshold".to_string());
        } else if metrics.inclusion_rate > 0.95 && network_state.avg_tip > params.min_tip_threshold * 2 {
            // We're being too conservative
            params.min_tip_threshold = (params.min_tip_threshold as f64 * 0.9) as u64;
            adaptations.push("Decreased minimum tip threshold".to_string());
        }
        
        // Adapt build time based on performance
        let avg_build_ms = metrics.average_build_time.as_millis() as f64;
        let max_build_ms = params.max_build_time.as_millis() as f64;
        
        if avg_build_ms < max_build_ms * 0.5 && metrics.blocks_built > 10 {
            // We have time to build better blocks
            params.max_build_time = Duration::from_millis((max_build_ms * 1.2) as u64);
            params.enable_aggressive_packing = true;
            adaptations.push("Increased build time and enabled aggressive packing".to_string());
        }
        
        // Adapt MEV strategy based on network conditions
        match network_state.mev_opportunity_score() {
            score if score > 0.8 => {
                if params.mev_optimization_level != MevLevel::Aggressive {
                    params.mev_optimization_level = MevLevel::Aggressive;
                    adaptations.push("Switched to aggressive MEV optimization".to_string());
                }
            }
            score if score > 0.5 => {
                if params.mev_optimization_level != MevLevel::Moderate {
                    params.mev_optimization_level = MevLevel::Moderate;
                    adaptations.push("Switched to moderate MEV optimization".to_string());
                }
            }
            score if score > 0.2 => {
                if params.mev_optimization_level != MevLevel::Conservative {
                    params.mev_optimization_level = MevLevel::Conservative;
                    adaptations.push("Switched to conservative MEV optimization".to_string());
                }
            }
            _ => {
                if params.mev_optimization_level != MevLevel::Disabled {
                    params.mev_optimization_level = MevLevel::Disabled;
                    adaptations.push("Disabled MEV optimization".to_string());
                }
            }
        }
        
        // Adapt reorg protection based on recent reorgs
        if metrics.reorg_count > 2 {
            params.reorg_protection_depth = params.reorg_protection_depth.saturating_add(1);
            adaptations.push("Increased reorg protection depth".to_string());
        }
        
        // Record adaptation event
        if !adaptations.is_empty() {
            let event = AdaptationEvent {
                timestamp: Instant::now(),
                adaptations,
                metrics_snapshot: metrics.clone(),
                network_snapshot: network_state.clone(),
            };
            
            let mut history = self.adaptation_history.write().unwrap();
            history.push_back(event);
            
            // Keep only recent history
            while history.len() > 100 {
                history.pop_front();
            }
        }
    }
    
    /// Build with adaptive strategy
    pub async fn build_adaptive(
        &self,
        builder: &PayloadBuilder,
        args: BuildArguments,
    ) -> Result<AdaptiveBuildOutcome, PayloadBuilderError> {
        let start = Instant::now();
        let params = self.params.read().unwrap().clone();
        
        // Configure builder with adaptive parameters
        let mut build_config = BuildConfig {
            target_gas_usage: params.target_gas_usage,
            min_tip: params.min_tip_threshold,
            max_time: params.max_build_time,
            enable_mev: params.mev_optimization_level != MevLevel::Disabled,
            priority_senders: params.priority_addresses.clone(),
        };
        
        // Adjust based on current network state
        let network_state = self.network_monitor.get_state();
        if network_state.reorg_risk() > 0.3 {
            // High reorg risk, build more conservatively
            build_config.target_gas_usage *= 0.9;
            build_config.max_time = build_config.max_time * 3 / 4;
        }
        
        // Build with configured parameters
        let outcome = builder.build_with_config(args, build_config).await?;
        
        let build_time = start.elapsed();
        
        // Analyze adaptation effectiveness
        let adaptation_metrics = self.analyze_adaptation(&outcome, &params, build_time);
        
        Ok(AdaptiveBuildOutcome {
            outcome,
            strategy_used: params,
            adaptation_metrics,
        })
    }
    
    /// Update metrics after block
    pub fn record_outcome(&mut self, outcome: BuildOutcome, included: bool) {
        let mut tracker = self.performance.write().unwrap();
        tracker.record_block(BlockRecord {
            gas_used: outcome.block.header.gas_used,
            gas_limit: outcome.block.header.gas_limit,
            build_time: outcome.build_time,
            total_fees: outcome.total_fees,
            included,
            timestamp: Instant::now(),
        });
        
        // Trigger adaptation check periodically
        if tracker.blocks_recorded() % 10 == 0 {
            self.adapt_strategy();
        }
    }
    
    fn analyze_adaptation(
        &self,
        outcome: &BuildOutcome,
        params: &StrategyParams,
        build_time: Duration,
    ) -> AdaptationMetrics {
        let gas_efficiency = outcome.block.header.gas_used as f64 / outcome.block.header.gas_limit as f64;
        let build_time_ratio = build_time.as_secs_f64() / params.max_build_time.as_secs_f64();
        
        let mut strategy_changes = Vec::new();
        
        if gas_efficiency < params.target_gas_usage * 0.9 {
            strategy_changes.push("Underutilized gas limit".to_string());
        }
        
        if build_time_ratio > 0.95 {
            strategy_changes.push("Near build time limit".to_string());
        }
        
        AdaptationMetrics {
            gas_efficiency,
            build_time_ratio,
            strategy_changes,
        }
    }
}

pub struct NetworkMonitor {
    recent_blocks: VecDeque<BlockInfo>,
    mempool_samples: VecDeque<MempoolSample>,
}

impl NetworkMonitor {
    fn new() -> Self {
        Self {
            recent_blocks: VecDeque::with_capacity(100),
            mempool_samples: VecDeque::with_capacity(50),
        }
    }
    
    fn get_state(&self) -> NetworkState {
        let congestion = self.estimate_congestion();
        let avg_tip = self.calculate_average_tip();
        let volatility = self.calculate_volatility();
        
        NetworkState {
            congestion,
            avg_tip,
            volatility,
            recent_blocks: self.recent_blocks.len(),
        }
    }
    
    /// Estimate network congestion
    pub fn estimate_congestion(&self) -> NetworkCongestion {
        let recent_usage: Vec<f64> = self.recent_blocks
            .iter()
            .take(10)
            .map(|b| b.gas_used as f64 / b.gas_limit as f64)
            .collect();
        
        let avg_fill_rate = if recent_usage.is_empty() {
            0.5
        } else {
            recent_usage.iter().sum::<f64>() / recent_usage.len() as f64
        };
        
        let latest_sample = self.mempool_samples.back();
        
        NetworkCongestion {
            mempool_size: latest_sample.map(|s| s.total_txs).unwrap_or(0),
            avg_gas_price: latest_sample.map(|s| s.avg_gas_price).unwrap_or(1_000_000_000),
            pending_tx_count: latest_sample.map(|s| s.pending_txs).unwrap_or(0),
            block_fill_rate: avg_fill_rate,
        }
    }
    
    fn calculate_average_tip(&self) -> u64 {
        let tips: Vec<u64> = self.recent_blocks
            .iter()
            .flat_map(|b| &b.priority_fees)
            .copied()
            .collect();
        
        if tips.is_empty() {
            2_000_000_000 // 2 gwei default
        } else {
            tips.iter().sum::<u64>() / tips.len() as u64
        }
    }
    
    fn calculate_volatility(&self) -> f64 {
        if self.recent_blocks.len() < 2 {
            return 0.0;
        }
        
        let gas_prices: Vec<f64> = self.recent_blocks
            .iter()
            .map(|b| b.base_fee as f64)
            .collect();
        
        let mean = gas_prices.iter().sum::<f64>() / gas_prices.len() as f64;
        let variance = gas_prices.iter()
            .map(|p| (p - mean).powi(2))
            .sum::<f64>() / gas_prices.len() as f64;
        
        variance.sqrt() / mean
    }
    
    /// Predict reorg probability
    pub fn reorg_risk(&self) -> f64 {
        // Simplified reorg risk based on volatility and congestion
        let volatility = self.calculate_volatility();
        let congestion = self.estimate_congestion();
        
        (volatility * 0.5 + congestion.block_fill_rate * 0.5).min(1.0)
    }
}

#[derive(Clone, Debug)]
pub struct NetworkState {
    congestion: NetworkCongestion,
    avg_tip: u64,
    volatility: f64,
    recent_blocks: usize,
}

impl NetworkState {
    fn mev_opportunity_score(&self) -> f64 {
        // High congestion + high tips = MEV opportunities
        let congestion_score = self.congestion.block_fill_rate;
        let tip_score = (self.avg_tip as f64 / 10_000_000_000.0).min(1.0); // Normalize to 10 gwei
        
        (congestion_score * 0.6 + tip_score * 0.4) * (1.0 + self.volatility).min(2.0)
    }
}

#[derive(Debug, Clone)]
pub struct NetworkCongestion {
    pub mempool_size: usize,
    pub avg_gas_price: u64,
    pub pending_tx_count: usize,
    pub block_fill_rate: f64,
}

struct PerformanceTracker {
    recent_blocks: VecDeque<BlockRecord>,
    total_stats: PerformanceMetrics,
}

impl PerformanceTracker {
    fn new() -> Self {
        Self {
            recent_blocks: VecDeque::with_capacity(100),
            total_stats: PerformanceMetrics::default(),
        }
    }
    
    fn record_block(&mut self, record: BlockRecord) {
        self.recent_blocks.push_back(record);
        
        // Keep only recent blocks
        while self.recent_blocks.len() > 100 {
            self.recent_blocks.pop_front();
        }
        
        // Update stats
        self.update_stats();
    }
    
    fn update_stats(&mut self) {
        if self.recent_blocks.is_empty() {
            return;
        }
        
        let total = self.recent_blocks.len() as f64;
        
        self.total_stats.blocks_built = self.recent_blocks.len() as u64;
        
        self.total_stats.average_gas_usage = self.recent_blocks
            .iter()
            .map(|r| r.gas_used as f64 / r.gas_limit as f64)
            .sum::<f64>() / total;
        
        self.total_stats.average_build_time = Duration::from_secs_f64(
            self.recent_blocks
                .iter()
                .map(|r| r.build_time.as_secs_f64())
                .sum::<f64>() / total
        );
        
        self.total_stats.inclusion_rate = self.recent_blocks
            .iter()
            .filter(|r| r.included)
            .count() as f64 / total;
        
        self.total_stats.average_profit = U256::from(
            (self.recent_blocks
                .iter()
                .map(|r| r.total_fees.as_u64())
                .sum::<u64>() / self.recent_blocks.len() as u64) as u128
        );
    }
    
    fn get_metrics(&self) -> PerformanceMetrics {
        self.total_stats.clone()
    }
    
    fn blocks_recorded(&self) -> usize {
        self.recent_blocks.len()
    }
}

#[derive(Clone)]
struct BlockRecord {
    gas_used: u64,
    gas_limit: u64,
    build_time: Duration,
    total_fees: U256,
    included: bool,
    timestamp: Instant,
}

pub struct AdaptiveBuildOutcome {
    pub outcome: BuildOutcome,
    pub strategy_used: StrategyParams,
    pub adaptation_metrics: AdaptationMetrics,
}

#[derive(Debug)]
pub struct AdaptationMetrics {
    pub gas_efficiency: f64,
    pub build_time_ratio: f64,
    pub strategy_changes: Vec<String>,
}

struct AdaptationEvent {
    timestamp: Instant,
    adaptations: Vec<String>,
    metrics_snapshot: PerformanceMetrics,
    network_snapshot: NetworkState,
}

struct BlockInfo {
    number: u64,
    gas_used: u64,
    gas_limit: u64,
    base_fee: u64,
    priority_fees: Vec<u64>,
}

struct MempoolSample {
    timestamp: Instant,
    total_txs: usize,
    pending_txs: usize,
    avg_gas_price: u64,
}

#[derive(Clone)]
struct BuildConfig {
    target_gas_usage: f64,
    min_tip: u64,
    max_time: Duration,
    enable_mev: bool,
    priority_senders: HashSet<Address>,
}
```

## Questions to Ponder

1. **Time vs Value Trade-off**: How should builders balance between quick block production and maximizing value?

2. **MEV Integration**: What are the ethical considerations when building MEV-aware payloads?

3. **Transaction Censorship**: How can we ensure fair transaction inclusion while maximizing profits?

4. **Network Effects**: How do multiple builders competing affect overall network efficiency?

5. **Future Improvements**: What role will techniques like parallel transaction execution play in payload building?

Understanding payload building is essential for grasping how new blocks are created in modern Ethereum and the economic incentives driving block production.