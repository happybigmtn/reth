# Lesson 22: Gas Mechanics and Metering

*"Nobody ever figures out what life is all about, and it doesn't matter. Explore the world. Nearly everything is really interesting if you go into it deeply enough." - Richard Feynman*

## Files with Inline Comments for This Lesson
- `crates/evm/evm/src/metrics.rs` - Gas metrics and monitoring
- `crates/primitives-traits/src/constants/gas_units.rs` - Gas unit constants
- `crates/rpc/rpc-eth-types/src/fee_history.rs` - Fee history tracking
- `crates/transaction-pool/src/validate/eth.rs` - Transaction gas validation

## Understanding Gas in Ethereum: The Economic Engine

**WHY Gas Exists - The Fundamental Problem**: Imagine if you could run infinite loops on every computer in the world for free. That's what Ethereum would be without gas. Gas solves the "halting problem" economically.

**Real-world analogy**: Gas is like electricity billing. You pay per kilowatt-hour, not a flat rate, because that's fair and prevents abuse. Ethereum charges per computational step.

**The Four Pillars of Gas Design**:
1. **Computational Fairness**: Heavy computations pay more (like using more electricity)
2. **Economic Security**: Validators get paid for their work (like electrical workers)
3. **Priority Queuing**: Urgent transactions pay premium prices (like rush delivery)
4. **Spam Prevention**: Every action costs something (no free lunch)

**CRITICAL INSIGHT**: Gas isn't just about payment - it's about making the network's resources finite and rationally allocated.

## The Gas Model: Economics in Code

### The Gas Transaction Lifecycle (WHY Each Step Matters)

**Step 1: Gas Commitment** 
```
User commits: "I'm willing to pay up to gas_limit × gas_price"
WHY: Prevents users from starting expensive operations they can't pay for
```

**Step 2: Upfront Payment**
```
Network deducts: gas_limit × gas_price from user's balance
WHY: Ensures payment even if transaction fails mid-execution
```

**Step 3: Execution & Metering**
```
For each EVM operation:
  - Charge gas based on computational complexity
  - Track cumulative gas used
  - Stop if gas_used > gas_limit (out of gas error)
WHY: Fair pricing - complex operations cost more
```

**Step 4: Settlement**
```
Refund unused gas: (gas_limit - gas_used) × gas_price
WHY: You only pay for what you actually used
```

**Step 5: Validator Reward**
```
Validator receives: gas_used × gas_price
WHY: Incentivizes validators to include and execute transactions
```

### EIP-1559: The Gas Revolution (WHY It Was Necessary)

**The Problem EIP-1559 Solved**: Imagine an auction where you have to guess what everyone else will bid, and if you guess wrong, you either overpay by 10x or your transaction fails. That was pre-EIP-1559 Ethereum.

**Real-world analogy**: EIP-1559 changed Ethereum from a "blind auction" to "posted pricing" like at a gas station - you know the base price, and you just add a tip for faster service.

```
Pre-EIP-1559 Problems:
❌ Fee auctions caused massive overpayment during congestion
❌ Users had to guess gas prices (often wrong)
❌ Miners captured all the economic rent
❌ Extreme fee volatility (1 gwei to 1000 gwei swings)

EIP-1559 Solutions:
✓ Base fee burns ETH (reduces supply, aligns incentives)
✓ Predictable base fee + optional priority tip
✓ Automatic price discovery mechanism
✓ Much smoother fee curves
```

**CRITICAL INSIGHT**: Base fee burning wasn't just about tokenomics - it solved the "tragedy of the commons" problem where miners had no incentive to optimize for user experience.

## Gas Constants and Units

### Gas Unit Definitions

```rust
/// Gas units for better readability and logging
/// Located in: crates/primitives-traits/src/constants/gas_units.rs

/// Represents one Kilogas, or 1,000 gas
/// Used for small operations like SLOAD
pub const KILOGAS: u64 = 1_000;

/// Represents one Megagas, or 1,000,000 gas
/// Typical transaction uses 21-100 Kgas
pub const MEGAGAS: u64 = KILOGAS * 1_000;

/// Represents one Gigagas, or 1,000,000,000 gas
/// Full blocks contain ~30 Mgas
pub const GIGAGAS: u64 = MEGAGAS * 1_000;

/// Format gas for human-readable output
pub fn format_gas(gas: u64) -> String {
    let gas = gas as f64;
    if gas < MEGAGAS as f64 {
        format!("{:.2} Kgas", gas / KILOGAS as f64)
    } else if gas < GIGAGAS as f64 {
        format!("{:.2} Mgas", gas / MEGAGAS as f64)
    } else {
        format!("{:.2} Ggas", gas / GIGAGAS as f64)
    }
}

/// Format gas throughput (gas per second)
/// Shows blockchain processing capacity
pub fn format_gas_throughput(gas: u64, execution_duration: Duration) -> String {
    let gas_per_second = gas as f64 / execution_duration.as_secs_f64();
    
    // Choose appropriate unit based on magnitude
    if gas_per_second < MEGAGAS as f64 {
        format!("{:.2} Kgas/second", gas_per_second / KILOGAS as f64)
    } else if gas_per_second < GIGAGAS as f64 {
        format!("{:.2} Mgas/second", gas_per_second / MEGAGAS as f64)
    } else {
        format!("{:.2} Ggas/second", gas_per_second / GIGAGAS as f64)
    }
}
```

## Gas Metering and Metrics

### Tracking Gas Consumption

```rust
/// Executor metrics for monitoring gas usage
/// Located in: crates/evm/evm/src/metrics.rs

#[derive(Metrics, Clone)]
#[metrics(scope = "sync.execution")]
pub struct ExecutorMetrics {
    /// Total gas processed by this node
    /// Monotonically increasing counter
    pub gas_processed_total: Counter,
    
    /// Current gas processing rate
    /// Updated after each block
    pub gas_per_second: Gauge,
    
    /// Distribution of gas used per block
    /// Helps identify unusual blocks
    pub gas_used_histogram: Histogram,
    
    /// Execution time tracking
    pub execution_histogram: Histogram,
    pub execution_duration: Gauge,
}

impl ExecutorMetrics {
    /// Execute a block and record gas metrics
    fn metered<F, R, B>(&self, block: &RecoveredBlock<B>, f: F) -> R
    where
        F: FnOnce() -> R,
        B: Block,
    {
        // Start timing
        let execute_start = Instant::now();
        
        // Execute the actual work
        let output = f();
        
        // Calculate metrics
        let execution_duration = execute_start.elapsed().as_secs_f64();
        let gas_used = block.header().gas_used();
        
        // Update gas metrics
        self.gas_processed_total.increment(gas_used);
        self.gas_per_second.set(gas_used as f64 / execution_duration);
        self.gas_used_histogram.record(gas_used as f64);
        
        // Update timing metrics
        self.execution_histogram.record(execution_duration);
        self.execution_duration.set(execution_duration);
        
        output
    }
}
```

### Detailed Execution Metrics

```rust
/// Track resource usage during execution
impl ExecutorMetrics {
    /// Execute with detailed state tracking
    pub fn execute_metered<E, DB>(
        &self,
        executor: E,
        input: &RecoveredBlock<impl Block>,
        state_hook: Box<dyn OnStateHook>,
    ) -> Result<BlockExecutionOutput<E::Receipt>, BlockExecutionError>
    where
        DB: Database,
        E: BlockExecutor,
    {
        // Wrap the state hook to capture metrics
        let wrapper = MeteredStateHook { 
            metrics: self.clone(), 
            inner_hook: state_hook 
        };
        
        let mut executor = executor.with_state_hook(Some(Box::new(wrapper)));
        
        // Execute with gas tracking
        let (mut db, result) = self.metered(input, || {
            // Pre-execution setup
            executor.apply_pre_execution_changes()?;
            
            // Execute each transaction
            for tx in input.transactions_recovered() {
                executor.execute_transaction(tx)?;
            }
            
            // Finalize execution
            executor.finish()
        })?;
        
        // Record state changes
        let output = BlockExecutionOutput { 
            result, 
            state: db.take_bundle() 
        };
        
        // Metrics for state size
        let accounts = output.state.state.len();
        let storage_slots = output.state.state.values()
            .map(|account| account.storage.len())
            .sum::<usize>();
        let bytecodes = output.state.contracts.len();
        
        self.accounts_updated_histogram.record(accounts as f64);
        self.storage_slots_updated_histogram.record(storage_slots as f64);
        self.bytecodes_updated_histogram.record(bytecodes as f64);
        
        Ok(output)
    }
}
```

## Gas Costs by Operation Type

### Operation Gas Costs

```rust
/// Common gas costs in the EVM
pub mod gas_costs {
    /// Basic operations
    pub const ADD: u64 = 3;          // Addition
    pub const MUL: u64 = 5;          // Multiplication
    pub const SLOAD: u64 = 2100;     // Storage read (warm)
    pub const SSTORE: u64 = 20000;   // Storage write (cold)
    
    /// Memory operations
    pub const MEMORY_WORD: u64 = 3;  // Per word of memory expansion
    
    /// Contract operations
    pub const CREATE: u64 = 32000;   // Contract creation
    pub const CALL: u64 = 700;       // Call to another contract
    
    /// Transaction costs
    pub const TX_BASE: u64 = 21000;  // Base transaction cost
    pub const TX_DATA_ZERO: u64 = 4; // Per zero byte in data
    pub const TX_DATA_NON_ZERO: u64 = 16; // Per non-zero byte
}

/// Calculate intrinsic gas for a transaction
pub fn calculate_intrinsic_gas(tx: &Transaction) -> u64 {
    let mut gas = gas_costs::TX_BASE;
    
    // Add data costs
    for byte in tx.data() {
        if *byte == 0 {
            gas += gas_costs::TX_DATA_ZERO;
        } else {
            gas += gas_costs::TX_DATA_NON_ZERO;
        }
    }
    
    // Contract creation costs extra
    if tx.to().is_none() {
        gas += gas_costs::CREATE;
    }
    
    gas
}
```

## Fee History and Gas Price Oracle

### Tracking Historical Gas Prices

```rust
/// Fee history cache for gas price estimation
/// Located in: crates/rpc/rpc-eth-types/src/fee_history.rs

#[derive(Debug, Clone)]
pub struct FeeHistoryCache<H> {
    inner: Arc<FeeHistoryCacheInner<H>>,
}

#[derive(Debug)]
struct FeeHistoryCacheInner<H> {
    /// Oldest block we track
    lower_bound: AtomicU64,
    /// Newest block we track
    upper_bound: AtomicU64,
    /// Configuration
    config: FeeHistoryCacheConfig,
    /// Cached entries by block number
    entries: RwLock<BTreeMap<u64, FeeHistoryEntry<H>>>,
}

/// Entry for a single block's fee data
#[derive(Debug, Clone)]
pub struct FeeHistoryEntry<H> {
    /// Block header with gas info
    pub header: H,
    /// Gas used ratio (0.0 to 1.0)
    pub gas_used_ratio: f64,
    /// Base fee for this block
    pub base_fee_per_gas: u64,
    /// Blob base fee (EIP-4844)
    pub base_fee_per_blob_gas: Option<u64>,
    /// Reward percentiles
    pub rewards: Vec<u128>,
}

impl<H: BlockHeader> FeeHistoryCache<H> {
    /// Insert blocks with fee data
    async fn insert_blocks<'a, I, B, R, C>(&self, blocks: I, chain_spec: &C)
    where
        B: Block<Header = H> + 'a,
        R: TxReceipt + 'a,
        I: IntoIterator<Item = (&'a SealedBlock<B>, &'a [R])>,
        C: EthChainSpec,
    {
        let mut entries = self.inner.entries.write().await;
        let percentiles = self.predefined_percentiles();
        
        for (block, receipts) in blocks {
            // Create fee history entry
            let mut entry = FeeHistoryEntry::<H>::new(
                block,
                chain_spec.blob_params_at_timestamp(block.header().timestamp()),
            );
            
            // Calculate reward percentiles for gas price oracle
            entry.rewards = calculate_reward_percentiles_for_block(
                &percentiles,
                entry.header.gas_used(),
                entry.header.base_fee_per_gas().unwrap_or_default(),
                block.body().transactions(),
                receipts,
            ).unwrap_or_default();
            
            entries.insert(block.number(), entry);
        }
        
        // Update bounds
        self.update_bounds();
    }
    
    /// Get fee history for RPC response
    pub async fn get_history(
        &self,
        block_count: u64,
        newest_block: u64,
        reward_percentiles: &[f64],
    ) -> Result<FeeHistory, EthApiError> {
        let entries = self.inner.entries.read().await;
        
        let mut base_fees = Vec::new();
        let mut gas_used_ratios = Vec::new();
        let mut rewards = Vec::new();
        
        // Collect data for requested range
        let start_block = newest_block.saturating_sub(block_count - 1);
        
        for block_num in start_block..=newest_block {
            if let Some(entry) = entries.get(&block_num) {
                base_fees.push(entry.base_fee_per_gas);
                gas_used_ratios.push(entry.gas_used_ratio);
                
                // Calculate requested percentiles
                if !reward_percentiles.is_empty() {
                    rewards.push(self.calculate_percentiles(entry, reward_percentiles));
                }
            }
        }
        
        Ok(FeeHistory {
            oldest_block: start_block,
            base_fee_per_gas: base_fees,
            gas_used_ratio: gas_used_ratios,
            reward: if rewards.is_empty() { None } else { Some(rewards) },
        })
    }
}
```

## Transaction Pool Gas Validation

### Validating Transaction Gas

```rust
/// Transaction validation for gas requirements
/// Located in: crates/transaction-pool/src/validate/eth.rs

#[derive(Debug, Clone)]
pub struct EthTransactionValidator<C> {
    chain_spec: Arc<C>,
    /// Minimum gas price to accept
    minimum_priority_fee: u128,
    /// Current block info
    block_info: BlockInfo,
}

impl<C: ChainSpec> EthTransactionValidator<C> {
    /// Validate a transaction's gas settings
    pub fn validate_gas(
        &self,
        tx: &Transaction,
    ) -> Result<(), InvalidTransactionError> {
        // Check gas limit
        if tx.gas_limit() < calculate_intrinsic_gas(tx) {
            return Err(InvalidTransactionError::GasTooLow);
        }
        
        // Check max gas limit
        if tx.gas_limit() > self.block_info.gas_limit {
            return Err(InvalidTransactionError::GasTooHigh);
        }
        
        // Validate EIP-1559 fields
        if let Some(max_fee) = tx.max_fee_per_gas() {
            // Max fee must cover base fee
            if max_fee < self.block_info.base_fee {
                return Err(InvalidTransactionError::FeeCapTooLow);
            }
            
            // Priority fee can't exceed max fee
            if let Some(max_priority) = tx.max_priority_fee_per_gas() {
                if max_priority > max_fee {
                    return Err(InvalidTransactionError::TipAboveFeeCap);
                }
                
                // Check minimum priority fee
                if max_priority < self.minimum_priority_fee {
                    return Err(InvalidTransactionError::PriorityFeeTooLow);
                }
            }
        }
        
        // Check account balance
        let max_cost = self.calculate_max_cost(tx)?;
        if self.get_balance(tx.sender())? < max_cost {
            return Err(InvalidTransactionError::InsufficientFunds);
        }
        
        Ok(())
    }
    
    /// Calculate maximum possible cost
    fn calculate_max_cost(&self, tx: &Transaction) -> Result<U256, Error> {
        let gas_cost = tx.gas_limit() * tx.max_fee_per_gas().unwrap_or(tx.gas_price());
        let total = gas_cost + tx.value();
        Ok(total)
    }
}
```

## Base Fee Calculation (EIP-1559)

### Base Fee Algorithm

```rust
/// Calculate next block's base fee
pub fn calculate_next_base_fee(
    gas_used: u64,
    gas_limit: u64,
    base_fee: u64,
    elasticity_multiplier: u64,
) -> u64 {
    // Target gas is 50% of limit (with elasticity)
    let gas_target = gas_limit / elasticity_multiplier;
    
    if gas_used == gas_target {
        // Perfect utilization - no change
        base_fee
    } else if gas_used > gas_target {
        // Increase base fee
        let gas_used_delta = gas_used - gas_target;
        let base_fee_delta = base_fee * gas_used_delta / gas_target / 8;
        base_fee + base_fee_delta.max(1)
    } else {
        // Decrease base fee
        let gas_used_delta = gas_target - gas_used;
        let base_fee_delta = base_fee * gas_used_delta / gas_target / 8;
        base_fee.saturating_sub(base_fee_delta)
    }
}

/// Example base fee updates
/// 
/// Block 1: 50% full, base_fee = 1 gwei → no change
/// Block 2: 100% full, base_fee = 1 gwei → 1.125 gwei (+12.5%)
/// Block 3: 0% full, base_fee = 1.125 gwei → 0.984 gwei (-12.5%)
```

## Gas Refunds and Optimization

### Gas Refund Mechanism

```rust
/// Track gas refunds during execution
pub struct GasRefundTracker {
    /// Current refund counter
    refund_counter: u64,
    /// Maximum refund (50% of gas used)
    max_refund: u64,
}

impl GasRefundTracker {
    /// Add refund for storage operations
    pub fn add_storage_refund(&mut self, slots_cleared: u64) {
        // SSTORE refund for clearing storage
        const REFUND_PER_SLOT: u64 = 15_000;
        self.refund_counter += slots_cleared * REFUND_PER_SLOT;
    }
    
    /// Add refund for self-destruct
    pub fn add_selfdestruct_refund(&mut self) {
        const SELFDESTRUCT_REFUND: u64 = 24_000;
        self.refund_counter += SELFDESTRUCT_REFUND;
    }
    
    /// Calculate final refund amount
    pub fn calculate_refund(&self, gas_used: u64) -> u64 {
        // Refund is capped at 50% of gas used
        let max_refund = gas_used / 2;
        self.refund_counter.min(max_refund)
    }
}
```

## Advanced Gas Concepts

### Dynamic Gas Costs

```rust
/// Some operations have dynamic gas costs
pub struct DynamicGasCosts;

impl DynamicGasCosts {
    /// Memory expansion cost
    pub fn memory_expansion_cost(new_size: u64, current_size: u64) -> u64 {
        if new_size <= current_size {
            return 0;
        }
        
        let new_words = (new_size + 31) / 32;
        let current_words = (current_size + 31) / 32;
        
        let new_cost = new_words * 3 + new_words * new_words / 512;
        let current_cost = current_words * 3 + current_words * current_words / 512;
        
        new_cost - current_cost
    }
    
    /// Call gas calculation
    pub fn call_gas_cost(
        value: U256,
        target_exists: bool,
        target_empty: bool,
    ) -> u64 {
        let mut gas = 700; // Base CALL cost
        
        if !value.is_zero() {
            gas += 9000; // Value transfer cost
            
            if !target_exists {
                gas += 25000; // New account creation
            }
        }
        
        gas
    }
    
    /// Access list costs (EIP-2930)
    pub fn access_list_cost(addresses: usize, storage_keys: usize) -> u64 {
        const ADDRESS_COST: u64 = 2400;
        const STORAGE_KEY_COST: u64 = 1900;
        
        addresses as u64 * ADDRESS_COST + storage_keys as u64 * STORAGE_KEY_COST
    }
}
```

### Gas Optimization Patterns

```rust
/// Common gas optimization techniques
pub mod optimizations {
    /// Pack struct variables
    /// Bad: Uses 3 storage slots (96k gas to initialize)
    pub struct Unoptimized {
        a: u256,  // Slot 0
        b: u8,    // Slot 1 (wastes 31 bytes)
        c: u256,  // Slot 2
    }
    
    /// Good: Uses 2 storage slots (64k gas to initialize)
    pub struct Optimized {
        a: u256,  // Slot 0
        c: u256,  // Slot 1
        b: u8,    // Slot 1 (packed with c)
    }
    
    /// Use events instead of storage for historical data
    pub fn log_instead_of_store(data: Data) {
        // Bad: 20k+ gas
        // self.history.push(data);
        
        // Good: 375 gas + 8 gas per byte
        emit DataLogged(data);
    }
    
    /// Cache storage values
    pub fn cache_storage_reads() {
        // Bad: 2100 gas per read
        // for i in 0..10 {
        //     use(self.value);  // 21,000 gas total
        // }
        
        // Good: Single read
        let cached = self.value;  // 2100 gas
        for i in 0..10 {
            use(cached);  // ~3 gas per use
        }
    }
}
```

## Performance Monitoring

### Real-time Gas Metrics

```rust
/// Monitor gas usage in production
pub struct GasMonitor {
    /// Rolling window of gas usage
    window: VecDeque<GasMetric>,
    /// Window duration
    window_size: Duration,
}

#[derive(Debug, Clone)]
pub struct GasMetric {
    timestamp: Instant,
    block_number: u64,
    gas_used: u64,
    gas_limit: u64,
    base_fee: u64,
    transaction_count: usize,
}

impl GasMonitor {
    /// Add new block metrics
    pub fn record_block(&mut self, block: &Block) {
        let metric = GasMetric {
            timestamp: Instant::now(),
            block_number: block.number,
            gas_used: block.gas_used,
            gas_limit: block.gas_limit,
            base_fee: block.base_fee_per_gas,
            transaction_count: block.transactions.len(),
        };
        
        self.window.push_back(metric);
        self.cleanup_old_metrics();
    }
    
    /// Calculate current network metrics
    pub fn calculate_metrics(&self) -> NetworkGasMetrics {
        let total_gas = self.window.iter().map(|m| m.gas_used).sum::<u64>();
        let total_time = self.window.back()
            .map(|last| last.timestamp.duration_since(self.window[0].timestamp))
            .unwrap_or_default();
        
        let avg_gas_price = self.window.iter()
            .map(|m| m.base_fee)
            .sum::<u64>() / self.window.len() as u64;
        
        let utilization = self.window.iter()
            .map(|m| m.gas_used as f64 / m.gas_limit as f64)
            .sum::<f64>() / self.window.len() as f64;
        
        NetworkGasMetrics {
            gas_per_second: total_gas as f64 / total_time.as_secs_f64(),
            average_base_fee: avg_gas_price,
            network_utilization: utilization,
            blocks_in_window: self.window.len(),
        }
    }
}
```

## Assignments

### Assignment 1: Gas Price Predictor

Implement a gas price prediction system:

```rust
use std::collections::VecDeque;
use std::time::{Duration, Instant};

/// Predicts future gas prices based on historical data
pub struct GasPricePredictor {
    /// Historical base fees
    history: VecDeque<BaseFeeSample>,
    /// Prediction model parameters
    model: PredictionModel,
    /// Network congestion detector
    congestion_detector: CongestionDetector,
}

#[derive(Debug, Clone)]
struct BaseFeeSample {
    timestamp: Instant,
    block_number: u64,
    base_fee: u64,
    gas_used: u64,
    gas_limit: u64,
}

#[derive(Debug, Clone)]
struct PredictionModel {
    /// Weight for recent samples
    recency_weight: f64,
    /// Weight for congestion factor
    congestion_weight: f64,
    /// Smoothing factor for EMA
    smoothing_factor: f64,
    /// Prediction horizons
    horizons: Vec<Duration>,
}

#[derive(Debug)]
struct CongestionDetector {
    /// Threshold for high congestion
    high_threshold: f64,
    /// Threshold for low congestion
    low_threshold: f64,
    /// Current congestion score
    current_score: f64,
}

impl GasPricePredictor {
    pub fn new() -> Self {
        Self {
            history: VecDeque::with_capacity(1000),
            model: PredictionModel {
                recency_weight: 0.7,
                congestion_weight: 0.3,
                smoothing_factor: 0.2,
                horizons: vec![
                    Duration::from_secs(15),    // Next block
                    Duration::from_secs(60),    // 1 minute
                    Duration::from_secs(300),   // 5 minutes
                    Duration::from_secs(900),   // 15 minutes
                ],
            },
            congestion_detector: CongestionDetector {
                high_threshold: 0.85,
                low_threshold: 0.50,
                current_score: 0.0,
            },
        }
    }
    
    /// Add new block data
    pub fn add_block(&mut self, block: &Block) {
        let sample = BaseFeeSample {
            timestamp: Instant::now(),
            block_number: block.number,
            base_fee: block.base_fee_per_gas,
            gas_used: block.gas_used,
            gas_limit: block.gas_limit,
        };
        
        self.history.push_back(sample);
        
        // Keep only recent history (e.g., last hour)
        while self.history.len() > 0 && 
              self.history[0].timestamp.elapsed() > Duration::from_secs(3600) {
            self.history.pop_front();
        }
        
        // Update congestion score
        self.update_congestion_score();
    }
    
    /// Update network congestion score
    fn update_congestion_score(&mut self) {
        if self.history.len() < 10 {
            return;
        }
        
        // Calculate average utilization over last 10 blocks
        let recent_samples: Vec<_> = self.history.iter().rev().take(10).collect();
        let avg_utilization = recent_samples.iter()
            .map(|s| s.gas_used as f64 / s.gas_limit as f64)
            .sum::<f64>() / recent_samples.len() as f64;
        
        // Update congestion score with smoothing
        self.congestion_detector.current_score = 
            self.model.smoothing_factor * avg_utilization + 
            (1.0 - self.model.smoothing_factor) * self.congestion_detector.current_score;
    }
    
    /// Predict gas prices for different time horizons
    pub fn predict(&self) -> GasPricePredictions {
        let mut predictions = GasPricePredictions::default();
        
        if self.history.len() < 20 {
            return predictions; // Not enough data
        }
        
        // Calculate base predictions
        let base_prediction = self.calculate_base_prediction();
        let trend = self.calculate_trend();
        let volatility = self.calculate_volatility();
        
        // Generate predictions for each horizon
        for horizon in &self.model.horizons {
            let blocks_ahead = horizon.as_secs() / 12; // ~12 second blocks
            
            // Extrapolate based on trend
            let trend_adjustment = trend * blocks_ahead as f64;
            
            // Add congestion premium
            let congestion_premium = self.calculate_congestion_premium(
                self.congestion_detector.current_score
            );
            
            // Calculate confidence based on volatility
            let confidence = self.calculate_confidence(volatility, blocks_ahead);
            
            let prediction = GasPricePrediction {
                horizon: *horizon,
                base_fee: (base_prediction + trend_adjustment) as u64,
                min_fee: ((base_prediction + trend_adjustment) * (1.0 - volatility)) as u64,
                max_fee: ((base_prediction + trend_adjustment) * (1.0 + volatility)) as u64,
                recommended_fee: ((base_prediction + trend_adjustment) * (1.0 + congestion_premium)) as u64,
                confidence,
                congestion_level: self.get_congestion_level(),
            };
            
            predictions.add_prediction(prediction);
        }
        
        predictions
    }
    
    /// Calculate base prediction using weighted average
    fn calculate_base_prediction(&self) -> f64 {
        let recent_samples: Vec<_> = self.history.iter().rev().take(20).collect();
        let now = Instant::now();
        
        let weighted_sum = recent_samples.iter().enumerate()
            .map(|(i, sample)| {
                let age = now.duration_since(sample.timestamp).as_secs_f64();
                let recency_weight = (-age / 300.0).exp(); // Decay over 5 minutes
                sample.base_fee as f64 * recency_weight
            })
            .sum::<f64>();
        
        let weight_sum = recent_samples.iter().enumerate()
            .map(|(i, sample)| {
                let age = now.duration_since(sample.timestamp).as_secs_f64();
                (-age / 300.0).exp()
            })
            .sum::<f64>();
        
        weighted_sum / weight_sum
    }
    
    /// Calculate price trend
    fn calculate_trend(&self) -> f64 {
        if self.history.len() < 10 {
            return 0.0;
        }
        
        // Simple linear regression over last 10 blocks
        let recent: Vec<_> = self.history.iter().rev().take(10).collect();
        let n = recent.len() as f64;
        
        let sum_x = (0..recent.len()).map(|i| i as f64).sum::<f64>();
        let sum_y = recent.iter().map(|s| s.base_fee as f64).sum::<f64>();
        let sum_xy = recent.iter().enumerate()
            .map(|(i, s)| i as f64 * s.base_fee as f64)
            .sum::<f64>();
        let sum_x2 = (0..recent.len()).map(|i| (i * i) as f64).sum::<f64>();
        
        // Slope of linear regression
        (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)
    }
    
    /// Calculate price volatility
    fn calculate_volatility(&self) -> f64 {
        if self.history.len() < 20 {
            return 0.1; // Default volatility
        }
        
        let recent: Vec<_> = self.history.iter().rev().take(20).collect();
        let mean = recent.iter().map(|s| s.base_fee as f64).sum::<f64>() / recent.len() as f64;
        
        let variance = recent.iter()
            .map(|s| {
                let diff = s.base_fee as f64 - mean;
                diff * diff
            })
            .sum::<f64>() / recent.len() as f64;
        
        // Coefficient of variation
        (variance.sqrt() / mean).min(0.5) // Cap at 50%
    }
    
    /// Calculate congestion premium
    fn calculate_congestion_premium(&self, congestion_score: f64) -> f64 {
        if congestion_score > self.congestion_detector.high_threshold {
            0.2 // 20% premium for high congestion
        } else if congestion_score > self.congestion_detector.low_threshold {
            0.1 * (congestion_score - self.congestion_detector.low_threshold) / 
                (self.congestion_detector.high_threshold - self.congestion_detector.low_threshold)
        } else {
            0.0
        }
    }
    
    /// Calculate prediction confidence
    fn calculate_confidence(&self, volatility: f64, blocks_ahead: u64) -> f64 {
        // Confidence decreases with volatility and time
        let base_confidence = 1.0 - volatility;
        let time_decay = (-blocks_ahead as f64 / 100.0).exp();
        (base_confidence * time_decay * 100.0).max(0.0)
    }
    
    /// Get current congestion level
    fn get_congestion_level(&self) -> CongestionLevel {
        let score = self.congestion_detector.current_score;
        if score > self.congestion_detector.high_threshold {
            CongestionLevel::High
        } else if score > self.congestion_detector.low_threshold {
            CongestionLevel::Medium
        } else {
            CongestionLevel::Low
        }
    }
}

#[derive(Debug, Clone)]
pub struct GasPricePrediction {
    pub horizon: Duration,
    pub base_fee: u64,
    pub min_fee: u64,
    pub max_fee: u64,
    pub recommended_fee: u64,
    pub confidence: f64,
    pub congestion_level: CongestionLevel,
}

#[derive(Debug, Clone, Copy)]
pub enum CongestionLevel {
    Low,
    Medium,
    High,
}

#[derive(Debug, Default)]
pub struct GasPricePredictions {
    predictions: Vec<GasPricePrediction>,
}

impl GasPricePredictions {
    fn add_prediction(&mut self, prediction: GasPricePrediction) {
        self.predictions.push(prediction);
    }
    
    pub fn get_next_block(&self) -> Option<&GasPricePrediction> {
        self.predictions.first()
    }
    
    pub fn get_optimal_fee(&self, urgency: Urgency) -> u64 {
        match urgency {
            Urgency::Low => {
                // Use 5-minute prediction
                self.predictions.iter()
                    .find(|p| p.horizon == Duration::from_secs(300))
                    .map(|p| p.min_fee)
                    .unwrap_or(0)
            }
            Urgency::Medium => {
                // Use 1-minute prediction
                self.predictions.iter()
                    .find(|p| p.horizon == Duration::from_secs(60))
                    .map(|p| p.base_fee)
                    .unwrap_or(0)
            }
            Urgency::High => {
                // Use next block with premium
                self.predictions.first()
                    .map(|p| p.recommended_fee)
                    .unwrap_or(0)
            }
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub enum Urgency {
    Low,    // Can wait 5+ minutes
    Medium, // Should confirm within 1 minute
    High,   // Must confirm in next block
}

// Usage example
#[tokio::main]
async fn main() {
    let mut predictor = GasPricePredictor::new();
    
    // Simulate adding blocks
    for i in 0..100 {
        let block = Block {
            number: i,
            base_fee_per_gas: 30_000_000_000 + (i % 10) * 1_000_000_000, // 30-40 gwei
            gas_used: 15_000_000 + (i % 5) * 1_000_000,
            gas_limit: 30_000_000,
            ..Default::default()
        };
        
        predictor.add_block(&block);
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
    
    // Get predictions
    let predictions = predictor.predict();
    
    println!("Gas Price Predictions:");
    for prediction in &predictions.predictions {
        println!("  {:?}: {} gwei (confidence: {:.1}%)",
            prediction.horizon,
            prediction.base_fee / 1_000_000_000,
            prediction.confidence
        );
    }
    
    // Get optimal fees for different urgencies
    println!("\nOptimal Fees:");
    println!("  Low urgency: {} gwei", 
        predictions.get_optimal_fee(Urgency::Low) / 1_000_000_000);
    println!("  Medium urgency: {} gwei", 
        predictions.get_optimal_fee(Urgency::Medium) / 1_000_000_000);
    println!("  High urgency: {} gwei", 
        predictions.get_optimal_fee(Urgency::High) / 1_000_000_000);
}
```

### Assignment 2: Gas Usage Analyzer

Create a system to analyze gas usage patterns:

```rust
use std::collections::{HashMap, BTreeMap};
use std::sync::Arc;

/// Analyzes gas usage patterns across different transaction types
pub struct GasUsageAnalyzer {
    /// Transaction type patterns
    patterns: HashMap<TransactionPattern, GasStats>,
    /// Contract-specific stats
    contract_stats: HashMap<Address, ContractGasStats>,
    /// Time-based analysis
    temporal_analysis: TemporalGasAnalysis,
    /// Anomaly detector
    anomaly_detector: GasAnomalyDetector,
}

#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub enum TransactionPattern {
    SimpleTransfer,
    ERC20Transfer,
    ERC721Transfer,
    UniswapSwap,
    ContractCreation,
    SmartContractCall,
    BatchTransaction,
    Other(String),
}

#[derive(Debug, Clone, Default)]
pub struct GasStats {
    pub count: u64,
    pub total_gas: u64,
    pub min_gas: u64,
    pub max_gas: u64,
    pub average_gas: u64,
    pub median_gas: u64,
    pub std_deviation: f64,
    pub percentiles: BTreeMap<u8, u64>, // 25th, 50th, 75th, 90th, 95th, 99th
}

#[derive(Debug, Clone)]
pub struct ContractGasStats {
    pub address: Address,
    pub total_calls: u64,
    pub method_stats: HashMap<[u8; 4], MethodGasStats>, // selector -> stats
    pub deployment_gas: Option<u64>,
    pub average_gas_per_call: u64,
    pub gas_efficiency_score: f64,
}

#[derive(Debug, Clone)]
pub struct MethodGasStats {
    pub selector: [u8; 4],
    pub name: Option<String>,
    pub call_count: u64,
    pub gas_stats: GasStats,
    pub revert_rate: f64,
}

pub struct TemporalGasAnalysis {
    /// Hourly gas usage
    hourly_stats: [GasStats; 24],
    /// Daily gas usage (last 30 days)
    daily_stats: VecDeque<DailyGasStats>,
    /// Weekly patterns
    weekly_patterns: WeeklyPattern,
}

#[derive(Debug, Clone)]
pub struct DailyGasStats {
    pub date: chrono::NaiveDate,
    pub total_gas: u64,
    pub transaction_count: u64,
    pub unique_senders: HashSet<Address>,
    pub peak_hour: u8,
    pub gas_price_stats: GasStats,
}

pub struct GasAnomalyDetector {
    /// Historical baselines
    baselines: HashMap<TransactionPattern, GasBaseline>,
    /// Anomaly threshold (standard deviations)
    threshold: f64,
    /// Recent anomalies
    anomalies: VecDeque<GasAnomaly>,
}

#[derive(Debug, Clone)]
pub struct GasAnomaly {
    pub timestamp: Instant,
    pub transaction_hash: H256,
    pub pattern: TransactionPattern,
    pub expected_gas: u64,
    pub actual_gas: u64,
    pub deviation: f64,
    pub severity: AnomalySeverity,
}

#[derive(Debug, Clone, Copy)]
pub enum AnomalySeverity {
    Low,    // 2-3 standard deviations
    Medium, // 3-5 standard deviations
    High,   // 5+ standard deviations
}

impl GasUsageAnalyzer {
    pub fn new() -> Self {
        Self {
            patterns: HashMap::new(),
            contract_stats: HashMap::new(),
            temporal_analysis: TemporalGasAnalysis::new(),
            anomaly_detector: GasAnomalyDetector::new(3.0), // 3 sigma threshold
        }
    }
    
    /// Analyze a transaction
    pub fn analyze_transaction(&mut self, tx: &Transaction, receipt: &Receipt) {
        let pattern = self.identify_pattern(tx);
        let gas_used = receipt.gas_used;
        
        // Update pattern statistics
        self.update_pattern_stats(&pattern, gas_used);
        
        // Update contract statistics if applicable
        if let Some(to) = tx.to() {
            self.update_contract_stats(to, tx, receipt);
        }
        
        // Update temporal analysis
        self.temporal_analysis.record_transaction(tx, receipt);
        
        // Check for anomalies
        if let Some(anomaly) = self.anomaly_detector.check_transaction(&pattern, tx, receipt) {
            self.handle_anomaly(anomaly);
        }
    }
    
    /// Identify transaction pattern
    fn identify_pattern(&self, tx: &Transaction) -> TransactionPattern {
        // No input data = simple transfer
        if tx.data().is_empty() {
            return TransactionPattern::SimpleTransfer;
        }
        
        // Contract creation
        if tx.to().is_none() {
            return TransactionPattern::ContractCreation;
        }
        
        // Check method selector
        if tx.data().len() >= 4 {
            let selector = &tx.data()[0..4];
            
            match selector {
                // ERC20 transfer: 0xa9059cbb
                [0xa9, 0x05, 0x9c, 0xbb] => TransactionPattern::ERC20Transfer,
                // ERC721 transferFrom: 0x23b872dd
                [0x23, 0xb8, 0x72, 0xdd] => TransactionPattern::ERC721Transfer,
                // Uniswap V2 swap: 0x022c0d9f
                [0x02, 0x2c, 0x0d, 0x9f] => TransactionPattern::UniswapSwap,
                // Multicall: 0xac9650d8
                [0xac, 0x96, 0x50, 0xd8] => TransactionPattern::BatchTransaction,
                _ => TransactionPattern::SmartContractCall,
            }
        } else {
            TransactionPattern::Other("Unknown".to_string())
        }
    }
    
    /// Update pattern statistics
    fn update_pattern_stats(&mut self, pattern: &TransactionPattern, gas_used: u64) {
        let stats = self.patterns.entry(pattern.clone()).or_insert_with(GasStats::default);
        
        stats.count += 1;
        stats.total_gas += gas_used;
        stats.min_gas = stats.min_gas.min(gas_used);
        stats.max_gas = stats.max_gas.max(gas_used);
        stats.average_gas = stats.total_gas / stats.count;
        
        // Update percentiles (simplified - in practice use a more efficient algorithm)
        self.update_percentiles(stats, gas_used);
    }
    
    /// Generate analysis report
    pub fn generate_report(&self) -> GasAnalysisReport {
        GasAnalysisReport {
            pattern_analysis: self.analyze_patterns(),
            contract_analysis: self.analyze_contracts(),
            temporal_analysis: self.analyze_temporal_patterns(),
            anomaly_summary: self.summarize_anomalies(),
            optimization_recommendations: self.generate_recommendations(),
        }
    }
    
    /// Analyze gas usage patterns
    fn analyze_patterns(&self) -> PatternAnalysis {
        let mut analysis = PatternAnalysis::default();
        
        // Find most gas-intensive patterns
        let mut patterns_by_total: Vec<_> = self.patterns.iter()
            .map(|(pattern, stats)| (pattern, stats.total_gas))
            .collect();
        patterns_by_total.sort_by_key(|(_, gas)| std::cmp::Reverse(*gas));
        
        analysis.top_gas_consumers = patterns_by_total.into_iter()
            .take(10)
            .map(|(pattern, _)| pattern.clone())
            .collect();
        
        // Find most efficient patterns
        let mut patterns_by_avg: Vec<_> = self.patterns.iter()
            .map(|(pattern, stats)| (pattern, stats.average_gas))
            .collect();
        patterns_by_avg.sort_by_key(|(_, gas)| *gas);
        
        analysis.most_efficient = patterns_by_avg.into_iter()
            .take(5)
            .map(|(pattern, _)| pattern.clone())
            .collect();
        
        // Calculate pattern distribution
        let total_transactions: u64 = self.patterns.values().map(|s| s.count).sum();
        analysis.pattern_distribution = self.patterns.iter()
            .map(|(pattern, stats)| {
                (pattern.clone(), stats.count as f64 / total_transactions as f64 * 100.0)
            })
            .collect();
        
        analysis
    }
    
    /// Generate optimization recommendations
    fn generate_recommendations(&self) -> Vec<GasOptimizationRecommendation> {
        let mut recommendations = Vec::new();
        
        // Check for inefficient patterns
        for (pattern, stats) in &self.patterns {
            match pattern {
                TransactionPattern::SimpleTransfer => {
                    if stats.average_gas > 21_000 {
                        recommendations.push(GasOptimizationRecommendation {
                            pattern: pattern.clone(),
                            issue: "Simple transfers using more than 21k gas".to_string(),
                            recommendation: "Check for unnecessary data in transactions".to_string(),
                            potential_savings: stats.average_gas - 21_000,
                        });
                    }
                }
                TransactionPattern::ERC20Transfer => {
                    if stats.average_gas > 65_000 {
                        recommendations.push(GasOptimizationRecommendation {
                            pattern: pattern.clone(),
                            issue: "ERC20 transfers using excessive gas".to_string(),
                            recommendation: "Consider batching transfers or optimizing contract".to_string(),
                            potential_savings: stats.average_gas - 65_000,
                        });
                    }
                }
                _ => {}
            }
        }
        
        // Check for high-frequency inefficient contracts
        for (address, contract_stats) in &self.contract_stats {
            if contract_stats.gas_efficiency_score < 0.5 && contract_stats.total_calls > 1000 {
                recommendations.push(GasOptimizationRecommendation {
                    pattern: TransactionPattern::Other(format!("Contract {}", address)),
                    issue: "Inefficient contract with high usage".to_string(),
                    recommendation: "Consider optimizing or replacing this contract".to_string(),
                    potential_savings: contract_stats.average_gas_per_call / 4, // Assume 25% improvement
                });
            }
        }
        
        recommendations
    }
}

#[derive(Debug)]
pub struct GasAnalysisReport {
    pub pattern_analysis: PatternAnalysis,
    pub contract_analysis: ContractAnalysis,
    pub temporal_analysis: TemporalAnalysisResult,
    pub anomaly_summary: AnomalySummary,
    pub optimization_recommendations: Vec<GasOptimizationRecommendation>,
}

#[derive(Debug, Default)]
pub struct PatternAnalysis {
    pub top_gas_consumers: Vec<TransactionPattern>,
    pub most_efficient: Vec<TransactionPattern>,
    pub pattern_distribution: HashMap<TransactionPattern, f64>,
}

#[derive(Debug)]
pub struct GasOptimizationRecommendation {
    pub pattern: TransactionPattern,
    pub issue: String,
    pub recommendation: String,
    pub potential_savings: u64,
}

// Usage example
impl GasUsageAnalyzer {
    pub fn analyze_block(&mut self, block: &Block, receipts: &[Receipt]) {
        for (tx, receipt) in block.transactions.iter().zip(receipts.iter()) {
            self.analyze_transaction(tx, receipt);
        }
    }
    
    pub fn print_summary(&self) {
        println!("Gas Usage Analysis Summary");
        println!("=========================");
        
        // Pattern summary
        println!("\nTransaction Patterns:");
        for (pattern, stats) in &self.patterns {
            println!("  {:?}:", pattern);
            println!("    Count: {}", stats.count);
            println!("    Average Gas: {} ({:.2} Kgas)", 
                stats.average_gas, 
                stats.average_gas as f64 / 1000.0
            );
            println!("    Total Gas: {} ({:.2} Mgas)", 
                stats.total_gas,
                stats.total_gas as f64 / 1_000_000.0
            );
        }
        
        // Top contracts by gas usage
        let mut contracts_by_gas: Vec<_> = self.contract_stats.iter()
            .map(|(addr, stats)| (addr, stats.total_calls * stats.average_gas_per_call))
            .collect();
        contracts_by_gas.sort_by_key(|(_, gas)| std::cmp::Reverse(*gas));
        
        println!("\nTop Gas-Consuming Contracts:");
        for (addr, total_gas) in contracts_by_gas.iter().take(5) {
            let stats = &self.contract_stats[addr];
            println!("  {}: {:.2} Mgas total ({} calls, {:.2} Kgas avg)",
                addr,
                *total_gas as f64 / 1_000_000.0,
                stats.total_calls,
                stats.average_gas_per_call as f64 / 1000.0
            );
        }
        
        // Recent anomalies
        if !self.anomaly_detector.anomalies.is_empty() {
            println!("\nRecent Gas Anomalies:");
            for anomaly in self.anomaly_detector.anomalies.iter().take(5) {
                println!("  {} - {:?} pattern: expected {} gas, got {} gas ({:.1}σ deviation)",
                    anomaly.transaction_hash,
                    anomaly.pattern,
                    anomaly.expected_gas,
                    anomaly.actual_gas,
                    anomaly.deviation
                );
            }
        }
    }
}

#[tokio::main]
async fn main() {
    let mut analyzer = GasUsageAnalyzer::new();
    
    // Simulate analyzing blocks
    // In practice, this would connect to a real node
    
    let report = analyzer.generate_report();
    println!("Gas Analysis Report: {:?}", report);
    
    analyzer.print_summary();
}
```

### Assignment 3: MEV-Aware Gas Pricing

Implement a gas pricing strategy that accounts for MEV (Maximal Extractable Value):

```rust
use std::collections::{HashMap, BTreeSet};
use std::sync::Arc;
use tokio::sync::RwLock;

/// MEV-aware gas pricing system
pub struct MevAwareGasPricer {
    /// Current mempool state
    mempool: Arc<RwLock<MempoolState>>,
    /// MEV opportunity detector
    mev_detector: MevDetector,
    /// Bundle builder for MEV extraction
    bundle_builder: BundleBuilder,
    /// Pricing strategy
    strategy: PricingStrategy,
}

#[derive(Debug)]
struct MempoolState {
    /// Pending transactions by gas price
    transactions: BTreeSet<PendingTransaction>,
    /// MEV opportunities
    opportunities: Vec<MevOpportunity>,
    /// Current base fee
    base_fee: u64,
    /// Next block gas limit
    gas_limit: u64,
}

#[derive(Debug, Clone, Eq, PartialEq)]
struct PendingTransaction {
    hash: H256,
    sender: Address,
    to: Option<Address>,
    value: U256,
    gas_price: u64,
    gas_limit: u64,
    data: Vec<u8>,
    nonce: u64,
}

impl Ord for PendingTransaction {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        // Order by gas price (descending)
        other.gas_price.cmp(&self.gas_price)
            .then_with(|| self.nonce.cmp(&other.nonce))
    }
}

impl PartialOrd for PendingTransaction {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

#[derive(Debug, Clone)]
pub enum MevOpportunity {
    Arbitrage {
        profit: U256,
        gas_required: u64,
        transactions: Vec<Transaction>,
    },
    Sandwich {
        victim_tx: H256,
        profit: U256,
        front_run_gas: u64,
        back_run_gas: u64,
    },
    Liquidation {
        target: Address,
        profit: U256,
        gas_required: u64,
    },
}

pub struct MevDetector {
    /// DEX routers to monitor
    dex_routers: HashMap<Address, DexInfo>,
    /// Price oracles
    price_feeds: HashMap<Address, PriceFeed>,
    /// Lending protocols
    lending_protocols: HashMap<Address, LendingProtocol>,
}

#[derive(Debug)]
struct DexInfo {
    name: String,
    router_address: Address,
    factory_address: Address,
    swap_signatures: Vec<[u8; 4]>,
}

impl MevAwareGasPricer {
    pub fn new(base_fee: u64, gas_limit: u64) -> Self {
        Self {
            mempool: Arc::new(RwLock::new(MempoolState {
                transactions: BTreeSet::new(),
                opportunities: Vec::new(),
                base_fee,
                gas_limit,
            })),
            mev_detector: MevDetector::new(),
            bundle_builder: BundleBuilder::new(),
            strategy: PricingStrategy::default(),
        }
    }
    
    /// Add transaction to mempool and detect MEV
    pub async fn add_transaction(&self, tx: Transaction) -> Result<(), Error> {
        let pending = PendingTransaction::from_transaction(tx)?;
        
        // Add to mempool
        let mut mempool = self.mempool.write().await;
        mempool.transactions.insert(pending.clone());
        
        // Detect MEV opportunities
        let opportunities = self.mev_detector.detect_opportunities(&pending, &mempool)?;
        mempool.opportunities.extend(opportunities);
        
        Ok(())
    }
    
    /// Calculate optimal gas price for a transaction
    pub async fn calculate_gas_price(
        &self,
        tx: &Transaction,
        urgency: TxUrgency,
        mev_protection: bool,
    ) -> GasPriceRecommendation {
        let mempool = self.mempool.read().await;
        
        // Base calculation
        let base_price = self.calculate_base_price(&mempool, urgency);
        
        // Check if transaction is MEV-vulnerable
        let mev_risk = if mev_protection {
            self.assess_mev_risk(tx, &mempool)
        } else {
            MevRisk::None
        };
        
        // Adjust price based on MEV risk
        let adjusted_price = match mev_risk {
            MevRisk::None => base_price,
            MevRisk::Low => base_price * 110 / 100,   // 10% premium
            MevRisk::Medium => base_price * 125 / 100, // 25% premium
            MevRisk::High => base_price * 150 / 100,   // 50% premium
        };
        
        // Build recommendation
        GasPriceRecommendation {
            base_fee: mempool.base_fee,
            priority_fee: adjusted_price - mempool.base_fee,
            max_fee: adjusted_price * 120 / 100, // 20% buffer
            mev_risk,
            estimated_inclusion_blocks: self.estimate_inclusion_time(&mempool, adjusted_price),
            alternative_strategies: self.suggest_alternatives(tx, &mev_risk),
        }
    }
    
    /// Calculate base gas price without MEV considerations
    fn calculate_base_price(&self, mempool: &MempoolState, urgency: TxUrgency) -> u64 {
        let pending_txs: Vec<_> = mempool.transactions.iter().collect();
        
        match urgency {
            TxUrgency::Immediate => {
                // Price to be in top 10% of mempool
                let target_position = pending_txs.len() / 10;
                pending_txs.get(target_position)
                    .map(|tx| tx.gas_price + 1)
                    .unwrap_or(mempool.base_fee * 2)
            }
            TxUrgency::Fast => {
                // Price to be in top 25%
                let target_position = pending_txs.len() / 4;
                pending_txs.get(target_position)
                    .map(|tx| tx.gas_price)
                    .unwrap_or(mempool.base_fee * 150 / 100)
            }
            TxUrgency::Standard => {
                // Median price
                let median_position = pending_txs.len() / 2;
                pending_txs.get(median_position)
                    .map(|tx| tx.gas_price)
                    .unwrap_or(mempool.base_fee * 110 / 100)
            }
            TxUrgency::Slow => {
                // Just above base fee
                mempool.base_fee * 105 / 100
            }
        }
    }
    
    /// Assess MEV risk for a transaction
    fn assess_mev_risk(&self, tx: &Transaction, mempool: &MempoolState) -> MevRisk {
        // Check if interacting with DEX
        if self.is_dex_interaction(tx) {
            let swap_size = self.estimate_swap_size(tx);
            
            if swap_size > U256::from(10_000u64) * 10u64.pow(18) { // > $10k
                return MevRisk::High;
            } else if swap_size > U256::from(1_000u64) * 10u64.pow(18) { // > $1k
                return MevRisk::Medium;
            } else {
                return MevRisk::Low;
            }
        }
        
        // Check if it's a liquidation
        if self.is_liquidation(tx) {
            return MevRisk::High;
        }
        
        // Check if it reveals valuable information
        if self.reveals_price_info(tx) {
            return MevRisk::Medium;
        }
        
        MevRisk::None
    }
    
    /// Build MEV bundle for block production
    pub async fn build_mev_bundle(
        &self,
        block_space: u64,
    ) -> Result<MevBundle, Error> {
        let mempool = self.mempool.read().await;
        let mut bundle = MevBundle::new();
        let mut remaining_gas = block_space;
        
        // Sort opportunities by profit/gas ratio
        let mut opportunities: Vec<_> = mempool.opportunities.iter()
            .map(|opp| (opp, self.calculate_profit_ratio(opp)))
            .collect();
        opportunities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
        
        // Build bundle with most profitable opportunities
        for (opportunity, _ratio) in opportunities {
            let gas_needed = self.get_opportunity_gas(opportunity);
            
            if gas_needed <= remaining_gas {
                match opportunity {
                    MevOpportunity::Arbitrage { transactions, .. } => {
                        bundle.add_transactions(transactions.clone());
                    }
                    MevOpportunity::Sandwich { victim_tx, .. } => {
                        // Add front-run transaction
                        if let Some(front_run) = self.build_frontrun_tx(*victim_tx, &mempool) {
                            bundle.add_transaction(front_run);
                        }
                        
                        // Include victim transaction
                        if let Some(victim) = self.find_transaction(*victim_tx, &mempool) {
                            bundle.add_transaction(victim.clone());
                        }
                        
                        // Add back-run transaction
                        if let Some(back_run) = self.build_backrun_tx(*victim_tx, &mempool) {
                            bundle.add_transaction(back_run);
                        }
                    }
                    MevOpportunity::Liquidation { target, .. } => {
                        if let Some(liq_tx) = self.build_liquidation_tx(*target) {
                            bundle.add_transaction(liq_tx);
                        }
                    }
                }
                
                remaining_gas -= gas_needed;
            }
        }
        
        Ok(bundle)
    }
    
    /// Suggest alternative strategies to avoid MEV
    fn suggest_alternatives(&self, tx: &Transaction, mev_risk: &MevRisk) -> Vec<AlternativeStrategy> {
        let mut strategies = Vec::new();
        
        match mev_risk {
            MevRisk::High => {
                strategies.push(AlternativeStrategy::UsePrivateMempool {
                    provider: "Flashbots Protect".to_string(),
                    additional_cost: 0,
                });
                
                strategies.push(AlternativeStrategy::SplitTransaction {
                    recommended_parts: 4,
                    time_delay: Duration::from_secs(60),
                });
                
                strategies.push(AlternativeStrategy::UseCommitReveal {
                    commit_gas: 50_000,
                    reveal_gas: 100_000,
                    delay: Duration::from_secs(120),
                });
            }
            MevRisk::Medium => {
                strategies.push(AlternativeStrategy::AddNoise {
                    description: "Add small random amounts to avoid detection".to_string(),
                });
                
                strategies.push(AlternativeStrategy::TimeDelay {
                    wait_time: Duration::from_secs(30),
                    reason: "Wait for lower MEV activity".to_string(),
                });
            }
            _ => {}
        }
        
        strategies
    }
}

#[derive(Debug, Clone)]
pub struct GasPriceRecommendation {
    pub base_fee: u64,
    pub priority_fee: u64,
    pub max_fee: u64,
    pub mev_risk: MevRisk,
    pub estimated_inclusion_blocks: u64,
    pub alternative_strategies: Vec<AlternativeStrategy>,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum MevRisk {
    None,
    Low,
    Medium,
    High,
}

#[derive(Debug, Clone, Copy)]
pub enum TxUrgency {
    Immediate,  // Next block
    Fast,       // 1-2 blocks
    Standard,   // 3-5 blocks
    Slow,       // 6+ blocks
}

#[derive(Debug, Clone)]
pub enum AlternativeStrategy {
    UsePrivateMempool {
        provider: String,
        additional_cost: u64,
    },
    SplitTransaction {
        recommended_parts: usize,
        time_delay: Duration,
    },
    UseCommitReveal {
        commit_gas: u64,
        reveal_gas: u64,
        delay: Duration,
    },
    AddNoise {
        description: String,
    },
    TimeDelay {
        wait_time: Duration,
        reason: String,
    },
}

#[derive(Debug)]
pub struct MevBundle {
    transactions: Vec<Transaction>,
    total_gas: u64,
    expected_profit: U256,
}

impl MevBundle {
    fn new() -> Self {
        Self {
            transactions: Vec::new(),
            total_gas: 0,
            expected_profit: U256::zero(),
        }
    }
    
    fn add_transaction(&mut self, tx: Transaction) {
        self.total_gas += tx.gas_limit;
        self.transactions.push(tx);
    }
    
    fn add_transactions(&mut self, txs: Vec<Transaction>) {
        for tx in txs {
            self.add_transaction(tx);
        }
    }
}

// Usage example
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let pricer = MevAwareGasPricer::new(30_000_000_000, 30_000_000); // 30 gwei base, 30M gas
    
    // Simulate a swap transaction
    let swap_tx = Transaction {
        to: Some(Address::from([0x7a; 20])), // Uniswap router
        value: U256::zero(),
        data: hex::decode("38ed1739...")?, // swapExactTokensForTokens
        gas_limit: 200_000,
        ..Default::default()
    };
    
    // Get gas price recommendation
    let recommendation = pricer.calculate_gas_price(
        &swap_tx,
        TxUrgency::Fast,
        true, // Enable MEV protection
    ).await;
    
    println!("Gas Price Recommendation:");
    println!("  Base Fee: {} gwei", recommendation.base_fee / 1_000_000_000);
    println!("  Priority Fee: {} gwei", recommendation.priority_fee / 1_000_000_000);
    println!("  Max Fee: {} gwei", recommendation.max_fee / 1_000_000_000);
    println!("  MEV Risk: {:?}", recommendation.mev_risk);
    println!("  Estimated Inclusion: {} blocks", recommendation.estimated_inclusion_blocks);
    
    if !recommendation.alternative_strategies.is_empty() {
        println!("\nAlternative Strategies:");
        for (i, strategy) in recommendation.alternative_strategies.iter().enumerate() {
            println!("  {}. {:?}", i + 1, strategy);
        }
    }
    
    // Build MEV bundle for block builders
    let bundle = pricer.build_mev_bundle(15_000_000).await?; // 15M gas for MEV
    println!("\nMEV Bundle:");
    println!("  Transactions: {}", bundle.transactions.len());
    println!("  Total Gas: {}", bundle.total_gas);
    println!("  Expected Profit: {} ETH", 
        bundle.expected_profit.as_u128() as f64 / 10f64.powi(18));
    
    Ok(())
}
```

## Questions to Ponder - Detailed Answers

### 1. How does EIP-1559 improve gas price predictability and user experience?

**Answer**: EIP-1559 revolutionized Ethereum's fee market in several ways:

**Predictability Improvements**:
- **Algorithmic Base Fee**: The base fee adjusts by at most 12.5% per block based on network congestion, making it highly predictable
- **No More Bidding Wars**: Users don't need to guess what others are bidding; they just need to meet the base fee
- **Clear Inclusion Rules**: If max_fee >= base_fee and the block has space, the transaction will be included

**User Experience Benefits**:
- **Simplified Mental Model**: Users set a max fee they're willing to pay and a priority tip for miners
- **Better Wallet UX**: Wallets can accurately estimate fees without complex gas price oracles
- **Overpayment Protection**: Users only pay base_fee + priority_fee, not their full max_fee bid
- **Reduced Stuck Transactions**: The predictable base fee means fewer transactions get stuck with too-low fees

**Economic Benefits**:
- **ETH Burning**: Base fees are burned, creating deflationary pressure on ETH supply
- **Reduced MEV**: More predictable inclusion reduces opportunities for transaction ordering manipulation
- **Fair Pricing**: All transactions in a block pay the same base fee, ensuring fairness

**Example Scenario**:
```
Pre-EIP-1559: Gas prices spike from 50 to 200 gwei in minutes
- User bids 60 gwei → Transaction stuck
- User replaces with 250 gwei → Overpays significantly

Post-EIP-1559: Base fee at 50 gwei
- User sets max_fee: 100 gwei, priority: 2 gwei
- Base fee rises to 56 gwei → Transaction still included
- User pays: 58 gwei total (56 base + 2 priority)
```

### 2. What are the trade-offs between gas efficiency and code readability/security?

**Answer**: This is one of the most important tensions in smart contract development:

**Gas Optimization Trade-offs**:

1. **Assembly Usage**:
   - Pro: Can save 20-50% gas for critical operations
   - Con: Much harder to audit, prone to security bugs
   - Example: Using assembly for tight loops vs. Solidity's built-in constructs

2. **Storage Packing**:
   - Pro: Reduces storage slots used (saves ~20k gas per slot)
   - Con: Makes code less intuitive, harder to upgrade
   - Example: Packing multiple uint128s vs. using natural uint256s

3. **Function Complexity**:
   - Pro: Combining operations saves gas on calls
   - Con: Violates single responsibility principle, harder to test
   - Example: One function doing mint+transfer vs. separate functions

**Security Implications**:
- **Reentrancy Risks**: Gas optimizations might change execution order
- **Integer Overflow**: Packed values need careful handling
- **Upgrade Difficulty**: Highly optimized storage layouts are hard to modify

**Best Practices Balance**:
1. **Profile First**: Only optimize functions that are frequently called
2. **Document Heavily**: Explain every optimization with comments
3. **Test Extensively**: Gas-optimized code needs more test coverage
4. **Security > Gas**: Never compromise security for gas savings
5. **Consider L2s**: On L2s, gas matters less than on mainnet

**Real Example**:
```solidity
// Readable but expensive (100k+ gas)
mapping(address => uint256) public balances;
mapping(address => mapping(address => uint256)) public allowances;
mapping(address => bool) public isBlacklisted;
mapping(address => uint256) public nonces;

// Optimized but complex (60k gas)
mapping(address => uint256) public packedUserData;
// Bits 0-127: balance
// Bits 128-191: nonce  
// Bit 192: isBlacklisted
// Bits 193-255: reserved
```

The optimized version saves gas but is much harder to understand and maintain.

### 3. How do gas costs influence protocol design and user behavior on Ethereum?

**Answer**: Gas costs fundamentally shape how protocols are designed and how users interact with Ethereum:

**Protocol Design Impacts**:

1. **Batching Operations**:
   - Protocols implement multicall to amortize base transaction costs
   - Example: Uniswap v3's multi-hop swaps in one transaction

2. **Off-chain Computation**:
   - Complex calculations moved off-chain with on-chain verification
   - Example: Merkle tree proofs for airdrops instead of storing all recipients

3. **State Rent Workarounds**:
   - Protocols incentivize users to clean up storage for gas refunds
   - Example: Uniswap LP tokens can be burned for gas refunds

4. **L2 Migration**:
   - High gas costs drive protocols to deploy on L2s
   - Example: Gaming and NFT projects primarily on Polygon/Arbitrum

**User Behavior Changes**:

1. **Transaction Timing**:
   - Users wait for low-gas periods (weekends, late night US time)
   - Gas price trackers and alerts become essential tools

2. **Aggregation Services**:
   - Users prefer services that batch operations
   - Example: DEX aggregators that find gas-efficient routes

3. **Value Threshold**:
   - Small transactions become uneconomical
   - Minimum viable transaction size increases with gas prices

4. **Alternative Chains**:
   - Users bridge to cheaper chains for smaller transactions
   - Multi-chain strategies based on transaction size

**Economic Models**:

1. **Fee Abstraction**:
   - Protocols pay gas on behalf of users (meta-transactions)
   - Subsidized onboarding for new users

2. **Gas Tokens** (now deprecated):
   - Users would mint gas tokens when gas was cheap
   - Burn them when gas was expensive for refunds

3. **MEV Protection**:
   - Users pay extra for private mempools to avoid sandwiching
   - Time-based or commit-reveal schemes to hide intentions

**Innovation Drivers**:

Gas costs have driven innovation in:
- **Rollup Technology**: Optimistic and ZK rollups for scaling
- **Account Abstraction**: Better gas payment flexibility
- **State Channels**: Off-chain transactions with on-chain settlement
- **Efficient Standards**: ERC-1155 for batch NFT operations

The high cost of computation on Ethereum has paradoxically led to more innovative and efficient designs, pushing the boundaries of what's possible within constrained resources.

## Assignment Answers

### Answer 1: Gas Price Predictor

The gas price predictor implementation uses several key techniques:

1. **Time-Weighted Averaging**: Recent samples are weighted more heavily using exponential decay
2. **Linear Regression**: Calculates trend over the last 10 blocks to predict direction
3. **Volatility Calculation**: Uses coefficient of variation to estimate price stability
4. **Congestion Detection**: Monitors block utilization to add premiums during high demand

Key insights from the implementation:
- The predictor maintains a rolling window of historical data (1 hour)
- Confidence decreases exponentially with prediction horizon
- Congestion premiums are applied when utilization exceeds thresholds
- Multiple time horizons allow users to choose based on urgency

### Answer 2: Gas Usage Analyzer

The analyzer provides comprehensive insights into gas consumption patterns:

1. **Pattern Recognition**: Identifies transaction types by method selectors
2. **Statistical Analysis**: Tracks min/max/average/median gas per pattern
3. **Contract Profiling**: Monitors gas efficiency of frequently-used contracts
4. **Temporal Analysis**: Identifies hourly, daily, and weekly usage patterns

Key optimizations discovered:
- Simple transfers using more than 21k gas indicate unnecessary data
- ERC20 transfers above 65k gas suggest inefficient implementations
- Batching similar operations can save 30-40% on base transaction costs
- Time-of-day patterns can reduce costs by 20-50%

### Answer 3: MEV-Aware Gas Pricing

The MEV-aware pricing system addresses sandwich attacks and front-running:

1. **Risk Assessment**: Evaluates transaction vulnerability based on:
   - DEX interaction size (larger swaps = higher risk)
   - Liquidation potential
   - Price oracle updates

2. **Dynamic Pricing**: Adjusts gas prices based on MEV risk:
   - Low risk: 10% premium
   - Medium risk: 25% premium  
   - High risk: 50% premium

3. **Alternative Strategies**:
   - Private mempools (Flashbots Protect)
   - Transaction splitting to reduce per-tx value
   - Commit-reveal schemes for sensitive operations
   - Adding noise to obscure intentions

4. **Bundle Building**: For block producers, the system:
   - Sorts opportunities by profit/gas ratio
   - Constructs optimal transaction ordering
   - Maximizes extracted value within gas limits

The implementation shows how modern Ethereum users must consider not just gas prices but also the game-theoretic aspects of public mempools.