# Lesson 33: Understanding Opcodes

*"I learned very early the difference between knowing the name of something and knowing something." - Richard Feynman*

## Files with Inline Comments for This Lesson
- `examples/custom-inspector/src/main.rs` - Example of opcode inspection in practice
- `crates/rpc/rpc/src/debug.rs` - Debug API using opcode tracing
- `crates/evm/evm/src/execute.rs` - EVM execution framework
- External: `revm-bytecode/src/opcode.rs` - Core opcode definitions (in dependencies)

## What Are EVM Opcodes?

EVM opcodes are the fundamental instructions that make up the Ethereum Virtual Machine's instruction set. Each opcode represents a single operation that the EVM can perform, from basic arithmetic to complex contract interactions. Think of them as the "assembly language" of Ethereum smart contracts.

```
EVM Instruction Execution Flow:
┌─────────────────────────────────────────────────┐
│              Smart Contract Bytecode            │
│  0x60 0x80 0x40 0x52 0x34 0x80 0x15 0x61...    │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│             Opcode Decoder                     │
│  0x60 → PUSH1    0x80 → Stack Input            │
│  0x40 → Stack Position   0x52 → MSTORE         │
└─────────────────┬───────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────┐
│            Instruction Execution               │
│  • Load opcode implementation                  │
│  • Check gas requirements                      │
│  • Validate stack/memory constraints           │
│  • Execute operation                           │
│  • Update VM state                             │
└─────────────────────────────────────────────────┘

Example: PUSH1 0x80 PUSH1 0x40 MSTORE
1. PUSH1 0x80    → Push 0x80 onto stack
2. PUSH1 0x40    → Push 0x40 onto stack  
3. MSTORE        → Store 0x80 at memory[0x40]
```

## Opcode Categories

The EVM instruction set consists of several categories of opcodes:

### 1. Stack Operations
```rust
/// Stack manipulation opcodes
/// Located in: revm-interpreter/src/instructions/stack.rs

// PUSH operations - put immediate values onto stack
pub const PUSH1: u8 = 0x60;   // Push 1-byte value
pub const PUSH2: u8 = 0x61;   // Push 2-byte value
// ... up to PUSH32
pub const PUSH32: u8 = 0x7F;  // Push 32-byte value

// DUP operations - duplicate stack items
pub const DUP1: u8 = 0x80;    // Duplicate 1st stack item
pub const DUP2: u8 = 0x81;    // Duplicate 2nd stack item
// ... up to DUP16
pub const DUP16: u8 = 0x8F;   // Duplicate 16th stack item

// SWAP operations - swap stack items
pub const SWAP1: u8 = 0x90;   // Swap top two items
pub const SWAP2: u8 = 0x91;   // Swap 1st and 3rd items
// ... up to SWAP16
pub const SWAP16: u8 = 0x9F;  // Swap 1st and 17th items

// Stack management
pub const POP: u8 = 0x50;     // Remove top stack item

/// Example implementation of PUSH operation
pub fn push<const N: usize, H: Host + ?Sized>(
    interpreter: &mut Interpreter,
    _host: &mut H,
) -> InstructionResult {
    // Gas cost is constant for PUSH operations
    gas!(interpreter, gas::VERYLOW);
    
    // Ensure we have enough immediate bytes
    if interpreter.instruction_pointer + N > interpreter.bytecode.len() {
        return InstructionResult::OutOfGas;
    }
    
    // Read N bytes from bytecode
    let immediate = interpreter.bytecode.slice(
        interpreter.instruction_pointer,
        interpreter.instruction_pointer + N
    );
    
    // Push onto stack (stack grows upward)
    push!(interpreter, U256::from_be_slice(&immediate));
    
    // Advance instruction pointer past immediate
    interpreter.instruction_pointer += N;
    
    InstructionResult::Continue
}
```

### 2. Arithmetic and Logic Operations
```rust
/// Arithmetic and bitwise operations
/// Located in: revm-interpreter/src/instructions/arithmetic.rs

pub const ADD: u8 = 0x01;     // Addition
pub const SUB: u8 = 0x03;     // Subtraction  
pub const MUL: u8 = 0x02;     // Multiplication
pub const DIV: u8 = 0x04;     // Integer division
pub const MOD: u8 = 0x06;     // Modulo operation
pub const EXP: u8 = 0x0A;     // Exponentiation

pub const LT: u8 = 0x10;      // Less than
pub const GT: u8 = 0x11;      // Greater than
pub const EQ: u8 = 0x14;      // Equality
pub const ISZERO: u8 = 0x15;  // Is zero check

pub const AND: u8 = 0x16;     // Bitwise AND
pub const OR: u8 = 0x17;      // Bitwise OR
pub const XOR: u8 = 0x18;     // Bitwise XOR
pub const NOT: u8 = 0x19;     // Bitwise NOT

/// Example: ADD operation implementation
pub fn add<H: Host + ?Sized>(
    interpreter: &mut Interpreter, 
    _host: &mut H
) -> InstructionResult {
    // Charge base gas cost
    gas!(interpreter, gas::VERYLOW);
    
    // Pop two operands from stack
    pop_top!(interpreter, op1, op2);
    
    // Perform addition (wrapping on overflow)
    let result = op1.wrapping_add(op2);
    
    // Push result back onto stack
    push!(interpreter, result);
    
    InstructionResult::Continue
}

/// Example: EXP operation with dynamic gas costs
pub fn exp<H: Host + ?Sized>(
    interpreter: &mut Interpreter, 
    _host: &mut H
) -> InstructionResult {
    // Pop base and exponent
    pop_top!(interpreter, base, exponent);
    
    // Calculate dynamic gas cost based on exponent size
    let exponent_byte_size = if exponent.is_zero() {
        0
    } else {
        (exponent.bit_len() + 7) / 8
    };
    
    let gas_cost = gas::EXP + gas::EXP_BYTE * exponent_byte_size as u64;
    gas!(interpreter, gas_cost);
    
    // Perform exponentiation
    let result = base.pow(exponent);
    push!(interpreter, result);
    
    InstructionResult::Continue
}
```

### 3. Memory Operations
```rust
/// Memory access and manipulation
/// Located in: revm-interpreter/src/instructions/memory.rs

pub const MLOAD: u8 = 0x51;   // Load word from memory
pub const MSTORE: u8 = 0x52;  // Store word to memory  
pub const MSTORE8: u8 = 0x53; // Store byte to memory
pub const MSIZE: u8 = 0x59;   // Get size of active memory

/// MSTORE implementation - store 32 bytes to memory
pub fn mstore<H: Host + ?Sized>(
    interpreter: &mut Interpreter,
    _host: &mut H,
) -> InstructionResult {
    // Pop offset and value from stack
    pop!(interpreter, offset, value);
    
    // Calculate memory expansion cost
    let offset_usize = as_usize_or_fail!(interpreter, offset);
    let memory_offset = offset_usize.saturating_add(32);
    
    // Charge gas for memory expansion if needed
    resize_memory!(interpreter, memory_offset);
    
    // Store 32-byte value at memory offset
    interpreter.shared_memory.set_u256(offset_usize, value);
    
    InstructionResult::Continue
}

/// MLOAD implementation - load 32 bytes from memory
pub fn mload<H: Host + ?Sized>(
    interpreter: &mut Interpreter,
    _host: &mut H,
) -> InstructionResult {
    // Pop memory offset from stack
    pop!(interpreter, offset);
    
    let offset_usize = as_usize_or_fail!(interpreter, offset);
    let memory_end = offset_usize.saturating_add(32);
    
    // Charge gas for memory expansion if needed
    resize_memory!(interpreter, memory_end);
    
    // Load 32-byte value from memory
    let value = interpreter.shared_memory.get_u256(offset_usize);
    push!(interpreter, value);
    
    InstructionResult::Continue
}
```

### 4. Storage Operations
```rust
/// Contract storage access
/// Located in: revm-interpreter/src/instructions/host.rs

pub const SLOAD: u8 = 0x54;   // Load from storage
pub const SSTORE: u8 = 0x55;  // Store to storage

/// SLOAD implementation - load from contract storage
pub fn sload<H: Host + ?Sized>(
    interpreter: &mut Interpreter,
    host: &mut H,
) -> InstructionResult {
    // Pop storage key from stack
    pop!(interpreter, key);
    
    // Load from storage via host interface
    let (value, is_cold) = host.sload(interpreter.contract.target_address, key)?;
    
    // Charge gas based on whether storage was cold or warm
    let gas_cost = if is_cold { 
        gas::COLD_SLOAD_COST 
    } else { 
        gas::WARM_STORAGE_READ_COST 
    };
    gas!(interpreter, gas_cost);
    
    // Push loaded value onto stack
    push!(interpreter, value);
    
    InstructionResult::Continue
}

/// SSTORE implementation - store to contract storage
pub fn sstore<H: Host + ?Sized>(
    interpreter: &mut Interpreter,
    host: &mut H,
) -> InstructionResult {
    // Check if we're in a static call context
    check_staticcall!(interpreter);
    
    // Pop key and value from stack
    pop_top!(interpreter, key, value);
    
    // Store via host interface (handles gas cost calculation)
    let (gas_cost, gas_refund) = host.sstore(
        interpreter.contract.target_address, 
        key, 
        value
    )?;
    
    // Charge dynamic gas cost for storage operation
    gas!(interpreter, gas_cost);
    
    // Add any gas refund
    if gas_refund != 0 {
        interpreter.gas.record_refund(gas_refund);
    }
    
    InstructionResult::Continue
}
```

### 5. Control Flow Operations
```rust
/// Program control flow
/// Located in: revm-interpreter/src/instructions/control.rs

pub const JUMP: u8 = 0x56;     // Jump to PC
pub const JUMPI: u8 = 0x57;    // Conditional jump
pub const JUMPDEST: u8 = 0x5B; // Jump destination marker
pub const STOP: u8 = 0x00;     // Halt execution
pub const RETURN: u8 = 0xF3;   // Return data and halt
pub const REVERT: u8 = 0xFD;   // Revert state and return

/// JUMP implementation - unconditional jump
pub fn jump<H: Host + ?Sized>(
    interpreter: &mut Interpreter,
    _host: &mut H,
) -> InstructionResult {
    gas!(interpreter, gas::MID);
    
    // Pop jump destination from stack
    pop!(interpreter, dest);
    
    // Convert to program counter
    let dest_pc = as_usize_or_fail!(interpreter, dest);
    
    // Validate jump destination
    if !interpreter.contract.is_valid_jump(dest_pc) {
        return InstructionResult::InvalidJump;
    }
    
    // Update program counter
    interpreter.instruction_pointer = dest_pc;
    
    InstructionResult::Continue
}

/// JUMPI implementation - conditional jump
pub fn jumpi<H: Host + ?Sized>(
    interpreter: &mut Interpreter,
    _host: &mut H,
) -> InstructionResult {
    gas!(interpreter, gas::HIGH);
    
    // Pop destination and condition from stack
    pop_top!(interpreter, dest, condition);
    
    // Only jump if condition is non-zero
    if !condition.is_zero() {
        let dest_pc = as_usize_or_fail!(interpreter, dest);
        
        if !interpreter.contract.is_valid_jump(dest_pc) {
            return InstructionResult::InvalidJump;
        }
        
        interpreter.instruction_pointer = dest_pc;
    }
    
    InstructionResult::Continue
}
```

### 6. Contract Interaction
```rust
/// Contract calls and creation
/// Located in: revm-interpreter/src/instructions/contract.rs

pub const CALL: u8 = 0xF1;        // Message call
pub const CALLCODE: u8 = 0xF2;    // Message call with alternative msg.sender
pub const DELEGATECALL: u8 = 0xF4; // Message call with same msg.sender and value
pub const STATICCALL: u8 = 0xFA;   // Static message call
pub const CREATE: u8 = 0xF0;       // Create new contract
pub const CREATE2: u8 = 0xF5;      // Create new contract with deterministic address

/// CALL implementation - external contract call
pub fn call<H: Host + ?Sized>(
    interpreter: &mut Interpreter,
    host: &mut H,
) -> InstructionResult {
    // Pop arguments: gas, address, value, args_offset, args_size, ret_offset, ret_size
    pop!(interpreter, local_gas_limit);
    pop!(interpreter, to);
    pop!(interpreter, value);
    pop!(interpreter, args_offset, args_size);
    pop!(interpreter, ret_offset, ret_size);
    
    // Convert to appropriate types
    let to_address = Address::from_word(to);
    let local_gas_limit = u64::try_from(local_gas_limit).unwrap_or(u64::MAX);
    
    // Calculate memory expansion costs
    let args_offset_usize = as_usize_or_fail!(interpreter, args_offset);
    let args_size_usize = as_usize_or_fail!(interpreter, args_size);
    let ret_offset_usize = as_usize_or_fail!(interpreter, ret_offset);
    let ret_size_usize = as_usize_or_fail!(interpreter, ret_size);
    
    // Charge base gas cost
    let mut gas_cost = gas::CALL;
    
    // Add cost for value transfer
    if !value.is_zero() {
        gas_cost += gas::CALL_VALUE;
        
        // Additional cost if creating new account
        if host.load_account(to_address)?.is_empty() {
            gas_cost += gas::CALL_NEW_ACCOUNT;
        }
    }
    
    // Charge for memory expansion
    resize_memory!(interpreter, args_offset_usize + args_size_usize);
    resize_memory!(interpreter, ret_offset_usize + ret_size_usize);
    
    gas!(interpreter, gas_cost);
    
    // Extract call data from memory
    let input = interpreter.shared_memory.slice(args_offset_usize, args_size_usize);
    
    // Execute the call via host interface
    let outcome = host.call(CallInputs {
        contract: to_address,
        transfer: Transfer { source: interpreter.contract.caller, target: to_address, value },
        input: input.to_vec(),
        gas_limit: local_gas_limit,
        context: CallContext::Call,
        is_static: interpreter.is_static,
        return_memory_offset: ret_offset_usize..ret_offset_usize + ret_size_usize,
    })?;
    
    // Handle return data
    if let Some(return_data) = outcome.output {
        let copy_size = std::cmp::min(return_data.len(), ret_size_usize);
        interpreter.shared_memory.set(
            ret_offset_usize,
            &return_data[..copy_size]
        );
    }
    
    // Push success flag onto stack
    push!(interpreter, if outcome.result.is_success() { U256::from(1) } else { U256::ZERO });
    
    InstructionResult::Continue
}
```

## Gas Calculation for Opcodes

Gas costs vary significantly between opcodes based on their computational complexity:

```rust
/// Gas cost constants for different opcode categories
/// Located in: revm-interpreter/src/gas/constants.rs

pub const ZERO: u64 = 0;         // Free operations (like STOP)
pub const BASE: u64 = 2;         // Basic operations
pub const VERYLOW: u64 = 3;      // Simple stack operations
pub const LOW: u64 = 5;          // Memory/storage access
pub const MID: u64 = 8;          // Complex arithmetic
pub const HIGH: u64 = 10;        // Conditional operations

// Storage operation costs (EIP-2929)
pub const COLD_SLOAD_COST: u64 = 2100;        // First storage read
pub const WARM_STORAGE_READ_COST: u64 = 100;  // Subsequent reads
pub const SSTORE_SET: u64 = 20000;             // Storage write (new)
pub const SSTORE_RESET: u64 = 5000;           // Storage write (existing)

// Memory expansion cost calculation
pub fn memory_gas(memory_size: usize) -> u64 {
    let memory_size_word = (memory_size + 31) / 32;
    let memory_cost = memory_size_word as u64 * gas::MEMORY 
        + (memory_size_word as u64 * memory_size_word as u64) / 512;
    memory_cost
}

/// Dynamic gas calculation example for KECCAK256
pub fn keccak256_cost(data_size: usize) -> u64 {
    gas::KECCAK256 + (data_size as u64 + 31) / 32 * gas::KECCAK256_WORD
}
```

## Opcode Inspection in Practice

Reth provides powerful tools for inspecting opcode execution:

```rust
/// Custom opcode inspector for debugging and analysis
/// Located in: examples/custom-inspector/src/main.rs

#[derive(Default, Debug, Clone)]
struct OpcodeTracer {
    trace: Vec<TraceStep>,
}

#[derive(Debug, Clone)]
struct TraceStep {
    pc: usize,
    opcode: u8,
    opcode_name: String,
    gas_remaining: u64,
    stack_depth: usize,
    memory_size: usize,
}

impl<CTX> Inspector<CTX, EthInterpreter> for OpcodeTracer
where
    CTX: ContextTr,
{
    /// Called at each EVM instruction
    fn step(&mut self, interp: &mut Interpreter<EthInterpreter>, _context: &mut CTX) {
        let opcode_byte = interp.bytecode.opcode();
        
        // Get opcode information
        let opcode_info = if let Some(opcode) = OpCode::new(opcode_byte) {
            format!("{:?}", opcode)
        } else {
            format!("INVALID(0x{:02x})", opcode_byte)
        };
        
        // Record execution state
        self.trace.push(TraceStep {
            pc: interp.bytecode.pc(),
            opcode: opcode_byte,
            opcode_name: opcode_info,
            gas_remaining: interp.gas.remaining(),
            stack_depth: interp.stack.len(),
            memory_size: interp.shared_memory.len(),
        });
        
        // Optional: Stop tracing at specific conditions
        if self.trace.len() > 10000 {
            // Prevent excessive memory usage
            interp.instruction_result = InstructionResult::Stop;
        }
    }
    
    /// Called when a call is made
    fn call(
        &mut self,
        _context: &mut CTX,
        inputs: &CallInputs,
    ) -> Option<CallOutcome> {
        println!("External call to: {:?}", inputs.target_address);
        None // Let the EVM handle the call normally
    }
    
    /// Called when a contract is created
    fn create(
        &mut self,
        _context: &mut CTX,
        inputs: &CreateInputs,
    ) -> Option<CreateOutcome> {
        println!("Contract creation with {} bytes of code", inputs.init_code.len());
        None // Let the EVM handle the creation normally
    }
}

/// Usage example: trace a transaction's opcode execution
pub fn trace_transaction_opcodes(
    tx: &TransactionRequest,
    evm_config: &EvmConfig,
    state: &dyn StateProvider,
) -> Result<Vec<TraceStep>, EthApiError> {
    let mut tracer = OpcodeTracer::default();
    
    // Execute transaction with tracer
    let mut evm = evm_config.evm_with_env_and_inspector(
        state,
        evm_env,
        &mut tracer,
    );
    
    let result = evm.transact(tx_env)?;
    
    // Return the collected trace
    Ok(tracer.trace)
}
```

## Assignments

### Assignment 1: Basic Opcode Analyzer
Create a tool that analyzes bytecode and categorizes opcodes:

```rust
use std::collections::HashMap;

/// Analyze bytecode and categorize opcodes by type
struct BytecodeAnalyzer {
    // TODO: Implement fields for:
    // - Opcode frequency counting
    // - Gas cost estimation
    // - Control flow analysis
    // - Stack depth tracking
}

impl BytecodeAnalyzer {
    fn new() -> Self {
        // TODO: Initialize analyzer
        todo!("Implement analyzer initialization")
    }
    
    fn analyze_bytecode(&mut self, bytecode: &[u8]) -> AnalysisResult {
        // TODO: Implement bytecode analysis:
        // 1. Parse bytecode into individual instructions
        // 2. Handle PUSH instructions with immediate data
        // 3. Categorize opcodes (arithmetic, memory, storage, etc.)
        // 4. Count opcode frequencies
        // 5. Estimate total gas cost
        // 6. Identify jump destinations
        
        todo!("Implement bytecode analysis")
    }
}

#[derive(Debug)]
struct AnalysisResult {
    total_instructions: usize,
    opcode_categories: HashMap<String, usize>,
    estimated_gas_cost: u64,
    max_stack_depth: usize,
    jump_destinations: Vec<usize>,
}

#[derive(Debug)]
enum OpcodeCategory {
    Arithmetic,
    Memory,
    Storage,
    Control,
    Environment,
    Contract,
}
```

### Assignment 2: Gas Cost Calculator
Implement a gas cost calculator for common opcode patterns:

```rust
use std::collections::HashMap;

/// Calculate gas costs for opcode sequences
struct GasCostCalculator {
    base_costs: HashMap<u8, u64>,
    memory_size: usize,
    storage_slots: HashMap<[u8; 32], bool>, // track warm/cold storage
}

impl GasCostCalculator {
    fn new() -> Self {
        // TODO: Initialize with base gas costs for each opcode
        todo!("Implement gas cost calculator initialization")
    }
    
    fn calculate_execution_cost(&mut self, opcodes: &[OpcodeExecution]) -> GasCalculation {
        // TODO: Implement gas cost calculation:
        // 1. Base gas cost for each opcode
        // 2. Memory expansion costs
        // 3. Storage access costs (warm vs cold)
        // 4. Dynamic costs for complex operations
        // 5. Call data costs
        
        todo!("Implement gas cost calculation")
    }
    
    fn estimate_memory_expansion_cost(&self, new_size: usize) -> u64 {
        // TODO: Implement EIP-150 memory cost calculation
        // cost = (memory_size_word)² / 512 + (3 * memory_size_word)
        
        todo!("Implement memory cost calculation")
    }
}

#[derive(Debug)]
struct OpcodeExecution {
    opcode: u8,
    immediate_data: Option<Vec<u8>>,
    memory_access: Option<MemoryAccess>,
    storage_access: Option<StorageAccess>,
}

#[derive(Debug)]
struct MemoryAccess {
    offset: usize,
    size: usize,
}

#[derive(Debug)]
struct StorageAccess {
    key: [u8; 32],
    is_write: bool,
}

#[derive(Debug)]
struct GasCalculation {
    total_gas: u64,
    breakdown: HashMap<String, u64>,
}
```

### Assignment 3: EVM Opcode Simulator
Build a simplified EVM that can execute basic opcodes:

```rust
use std::collections::HashMap;

/// Simplified EVM implementation for educational purposes
struct SimpleEVM {
    stack: Vec<[u8; 32]>,
    memory: Vec<u8>,
    storage: HashMap<[u8; 32], [u8; 32]>,
    pc: usize,
    gas_remaining: u64,
    bytecode: Vec<u8>,
    halted: bool,
}

impl SimpleEVM {
    fn new(bytecode: Vec<u8>, initial_gas: u64) -> Self {
        // TODO: Initialize EVM state
        todo!("Implement EVM initialization")
    }
    
    fn execute_step(&mut self) -> Result<ExecutionResult, EvmError> {
        // TODO: Implement single step execution:
        // 1. Fetch instruction at PC
        // 2. Decode opcode and immediate data
        // 3. Check gas requirements
        // 4. Execute operation
        // 5. Update EVM state
        // 6. Advance PC
        
        todo!("Implement step execution")
    }
    
    fn execute_until_halt(&mut self) -> Result<FinalResult, EvmError> {
        // TODO: Execute until STOP, RETURN, REVERT, or error
        while !self.halted && self.gas_remaining > 0 {
            self.execute_step()?;
        }
        
        todo!("Implement execution loop")
    }
    
    // Individual opcode implementations
    fn execute_push(&mut self, size: usize) -> Result<(), EvmError> {
        // TODO: Implement PUSH1-PUSH32
        todo!("Implement PUSH opcodes")
    }
    
    fn execute_add(&mut self) -> Result<(), EvmError> {
        // TODO: Implement ADD opcode
        todo!("Implement ADD opcode")
    }
    
    fn execute_mstore(&mut self) -> Result<(), EvmError> {
        // TODO: Implement MSTORE opcode
        todo!("Implement MSTORE opcode")
    }
    
    fn execute_sstore(&mut self) -> Result<(), EvmError> {
        // TODO: Implement SSTORE opcode
        todo!("Implement SSTORE opcode")
    }
}

#[derive(Debug)]
enum ExecutionResult {
    Continue,
    Halt,
    Revert,
}

#[derive(Debug)]
struct FinalResult {
    gas_used: u64,
    return_data: Vec<u8>,
    success: bool,
}

#[derive(Debug)]
enum EvmError {
    StackUnderflow,
    StackOverflow,
    OutOfGas,
    InvalidOpcode,
    InvalidJump,
}
```

## Assignment Answers

### Assignment 1 Answer: Basic Opcode Analyzer

```rust
use std::collections::HashMap;

struct BytecodeAnalyzer {
    opcode_frequencies: HashMap<u8, usize>,
    category_counts: HashMap<OpcodeCategory, usize>,
    estimated_gas: u64,
    max_stack_depth: usize,
    current_stack_depth: isize,
}

impl BytecodeAnalyzer {
    fn new() -> Self {
        Self {
            opcode_frequencies: HashMap::new(),
            category_counts: HashMap::new(),
            estimated_gas: 0,
            max_stack_depth: 0,
            current_stack_depth: 0,
        }
    }
    
    fn analyze_bytecode(&mut self, bytecode: &[u8]) -> AnalysisResult {
        let mut pc = 0;
        let mut total_instructions = 0;
        let mut jump_destinations = Vec::new();
        
        // First pass: find all JUMPDEST instructions
        let mut jumpdests = std::collections::HashSet::new();
        let mut temp_pc = 0;
        while temp_pc < bytecode.len() {
            if bytecode[temp_pc] == 0x5B { // JUMPDEST
                jumpdests.insert(temp_pc);
            }
            temp_pc += 1 + self.get_immediate_size(bytecode[temp_pc]);
        }
        
        // Main analysis pass
        while pc < bytecode.len() {
            let opcode = bytecode[pc];
            total_instructions += 1;
            
            // Count opcode frequency
            *self.opcode_frequencies.entry(opcode).or_insert(0) += 1;
            
            // Categorize opcode
            let category = self.categorize_opcode(opcode);
            *self.category_counts.entry(category).or_insert(0) += 1;
            
            // Estimate gas cost
            self.estimated_gas += self.get_base_gas_cost(opcode);
            
            // Track stack depth changes
            self.update_stack_depth(opcode);
            
            // Handle JUMPDEST
            if opcode == 0x5B {
                jump_destinations.push(pc);
            }
            
            // Skip immediate data for PUSH instructions
            let immediate_size = self.get_immediate_size(opcode);
            pc += 1 + immediate_size;
        }
        
        AnalysisResult {
            total_instructions,
            opcode_categories: self.category_counts.iter()
                .map(|(cat, count)| (format!("{:?}", cat), *count))
                .collect(),
            estimated_gas_cost: self.estimated_gas,
            max_stack_depth: self.max_stack_depth,
            jump_destinations,
        }
    }
    
    fn categorize_opcode(&self, opcode: u8) -> OpcodeCategory {
        match opcode {
            0x01..=0x0B | 0x10..=0x1A => OpcodeCategory::Arithmetic,
            0x50..=0x5A => OpcodeCategory::Memory,
            0x54..=0x55 => OpcodeCategory::Storage,
            0x56..=0x5B | 0x00 | 0xF3 | 0xFD => OpcodeCategory::Control,
            0x30..=0x3A | 0x40..=0x48 => OpcodeCategory::Environment,
            0xF0..=0xF5 | 0xFA => OpcodeCategory::Contract,
            _ => OpcodeCategory::Other,
        }
    }
    
    fn get_immediate_size(&self, opcode: u8) -> usize {
        match opcode {
            0x60..=0x7F => (opcode - 0x60 + 1) as usize, // PUSH1-PUSH32
            _ => 0,
        }
    }
    
    fn get_base_gas_cost(&self, opcode: u8) -> u64 {
        match opcode {
            0x00 => 0,                    // STOP
            0x01..=0x0B => 3,            // Arithmetic (VERYLOW)
            0x10..=0x1A => 3,            // Comparison (VERYLOW)
            0x50 => 2,                   // POP (BASE)
            0x51 => 3,                   // MLOAD (VERYLOW + memory)
            0x52 | 0x53 => 3,            // MSTORE/MSTORE8 (VERYLOW + memory)
            0x54 => 2100,                // SLOAD (cold access)
            0x55 => 20000,               // SSTORE (worst case)
            0x56 => 8,                   // JUMP (MID)
            0x57 => 10,                  // JUMPI (HIGH)
            0x60..=0x7F => 3,            // PUSH1-PUSH32 (VERYLOW)
            0x80..=0x8F => 3,            // DUP1-DUP16 (VERYLOW)
            0x90..=0x9F => 3,            // SWAP1-SWAP16 (VERYLOW)
            _ => 3,                      // Default to VERYLOW
        }
    }
    
    fn update_stack_depth(&mut self, opcode: u8) {
        let (inputs, outputs) = self.get_stack_io(opcode);
        self.current_stack_depth -= inputs as isize;
        self.current_stack_depth += outputs as isize;
        
        if self.current_stack_depth > 0 {
            self.max_stack_depth = self.max_stack_depth.max(self.current_stack_depth as usize);
        }
    }
    
    fn get_stack_io(&self, opcode: u8) -> (usize, usize) {
        match opcode {
            0x00 => (0, 0),              // STOP
            0x01..=0x05 => (2, 1),       // ADD, MUL, SUB, DIV, SDIV
            0x06..=0x0B => (2, 1),       // MOD, SMOD, ADDMOD, MULMOD, EXP, SIGNEXTEND
            0x10..=0x1A => (2, 1),       // LT, GT, SLT, SGT, EQ, ISZERO, AND, OR, XOR, NOT, BYTE
            0x50 => (1, 0),              // POP
            0x51 => (1, 1),              // MLOAD
            0x52 => (2, 0),              // MSTORE
            0x53 => (2, 0),              // MSTORE8
            0x54 => (1, 1),              // SLOAD
            0x55 => (2, 0),              // SSTORE
            0x56 => (1, 0),              // JUMP
            0x57 => (2, 0),              // JUMPI
            0x5B => (0, 0),              // JUMPDEST
            0x60..=0x7F => (0, 1),       // PUSH1-PUSH32
            0x80..=0x8F => {             // DUP1-DUP16
                let n = (opcode - 0x80 + 1) as usize;
                (n, n + 1)
            },
            0x90..=0x9F => {             // SWAP1-SWAP16
                let n = (opcode - 0x90 + 1) as usize;
                (n + 1, n + 1)
            },
            _ => (0, 0),                 // Unknown
        }
    }
}

#[derive(Debug, Hash, PartialEq, Eq)]
enum OpcodeCategory {
    Arithmetic,
    Memory,
    Storage,
    Control,
    Environment,
    Contract,
    Other,
}

#[derive(Debug)]
struct AnalysisResult {
    total_instructions: usize,
    opcode_categories: HashMap<String, usize>,
    estimated_gas_cost: u64,
    max_stack_depth: usize,
    jump_destinations: Vec<usize>,
}

// Example usage
fn test_bytecode_analyzer() {
    let mut analyzer = BytecodeAnalyzer::new();
    
    // Simple bytecode: PUSH1 0x80 PUSH1 0x40 MSTORE STOP
    let bytecode = vec![0x60, 0x80, 0x60, 0x40, 0x52, 0x00];
    
    let result = analyzer.analyze_bytecode(&bytecode);
    
    println!("Analysis Result: {:?}", result);
    println!("This bytecode stores 0x80 at memory position 0x40");
}

// Analysis: This analyzer demonstrates bytecode parsing with proper handling
// of PUSH immediate data. It categorizes opcodes and estimates gas costs,
// providing insight into contract complexity and execution patterns.
```

### Assignment 2 Answer: Gas Cost Calculator

```rust
use std::collections::HashMap;

struct GasCostCalculator {
    base_costs: HashMap<u8, u64>,
    memory_size: usize,
    storage_slots: HashMap<[u8; 32], bool>, // true = warm, false = cold
}

impl GasCostCalculator {
    fn new() -> Self {
        let mut base_costs = HashMap::new();
        
        // Initialize base gas costs for common opcodes
        base_costs.insert(0x00, 0);     // STOP
        base_costs.insert(0x01, 3);     // ADD
        base_costs.insert(0x02, 5);     // MUL
        base_costs.insert(0x03, 3);     // SUB
        base_costs.insert(0x04, 5);     // DIV
        base_costs.insert(0x06, 5);     // MOD
        base_costs.insert(0x0A, 10);    // EXP (base cost)
        base_costs.insert(0x20, 30);    // KECCAK256 (base cost)
        base_costs.insert(0x50, 2);     // POP
        base_costs.insert(0x51, 3);     // MLOAD
        base_costs.insert(0x52, 3);     // MSTORE
        base_costs.insert(0x53, 3);     // MSTORE8
        base_costs.insert(0x54, 0);     // SLOAD (dynamic)
        base_costs.insert(0x55, 0);     // SSTORE (dynamic)
        base_costs.insert(0x56, 8);     // JUMP
        base_costs.insert(0x57, 10);    // JUMPI
        base_costs.insert(0x5B, 1);     // JUMPDEST
        
        // PUSH1-PUSH32
        for i in 0x60..=0x7F {
            base_costs.insert(i, 3);
        }
        
        // DUP1-DUP16
        for i in 0x80..=0x8F {
            base_costs.insert(i, 3);
        }
        
        // SWAP1-SWAP16
        for i in 0x90..=0x9F {
            base_costs.insert(i, 3);
        }
        
        Self {
            base_costs,
            memory_size: 0,
            storage_slots: HashMap::new(),
        }
    }
    
    fn calculate_execution_cost(&mut self, opcodes: &[OpcodeExecution]) -> GasCalculation {
        let mut total_gas = 0u64;
        let mut breakdown = HashMap::new();
        
        for execution in opcodes {
            let mut opcode_cost = 0u64;
            
            // 1. Base gas cost
            let base_cost = self.base_costs.get(&execution.opcode).unwrap_or(&3);
            opcode_cost += base_cost;
            *breakdown.entry("base_costs".to_string()).or_insert(0) += base_cost;
            
            // 2. Dynamic costs for specific opcodes
            match execution.opcode {
                0x0A => { // EXP
                    if let Some(ref data) = execution.immediate_data {
                        let exponent_bytes = data.len();
                        let exp_cost = 50 * exponent_bytes as u64;
                        opcode_cost += exp_cost;
                        *breakdown.entry("exp_dynamic".to_string()).or_insert(0) += exp_cost;
                    }
                },
                0x20 => { // KECCAK256
                    if let Some(ref mem_access) = execution.memory_access {
                        let data_words = (mem_access.size + 31) / 32;
                        let keccak_cost = 6 * data_words as u64;
                        opcode_cost += keccak_cost;
                        *breakdown.entry("keccak_data".to_string()).or_insert(0) += keccak_cost;
                    }
                },
                0x54 => { // SLOAD
                    if let Some(ref storage) = execution.storage_access {
                        let cost = if self.storage_slots.get(&storage.key).unwrap_or(&false) {
                            100  // Warm access
                        } else {
                            2100 // Cold access
                        };
                        opcode_cost += cost;
                        *breakdown.entry("storage_read".to_string()).or_insert(0) += cost;
                        self.storage_slots.insert(storage.key, true); // Mark as warm
                    }
                },
                0x55 => { // SSTORE
                    if let Some(ref storage) = execution.storage_access {
                        let is_warm = self.storage_slots.get(&storage.key).unwrap_or(&false);
                        let cost = if *is_warm {
                            if storage.is_write {
                                5000 // Warm storage modification
                            } else {
                                100  // Warm storage read
                            }
                        } else {
                            20000 // Cold storage modification (worst case)
                        };
                        opcode_cost += cost;
                        *breakdown.entry("storage_write".to_string()).or_insert(0) += cost;
                        self.storage_slots.insert(storage.key, true);
                    }
                },
                _ => {}
            }
            
            // 3. Memory expansion costs
            if let Some(ref mem_access) = execution.memory_access {
                let new_size = mem_access.offset + mem_access.size;
                if new_size > self.memory_size {
                    let expansion_cost = self.calculate_memory_expansion_cost(new_size);
                    opcode_cost += expansion_cost;
                    *breakdown.entry("memory_expansion".to_string()).or_insert(0) += expansion_cost;
                    self.memory_size = new_size;
                }
            }
            
            total_gas += opcode_cost;
        }
        
        GasCalculation {
            total_gas,
            breakdown,
        }
    }
    
    fn calculate_memory_expansion_cost(&self, new_size: usize) -> u64 {
        let new_size_words = (new_size + 31) / 32;
        let old_size_words = (self.memory_size + 31) / 32;
        
        let new_cost = (new_size_words * 3) + (new_size_words * new_size_words / 512);
        let old_cost = (old_size_words * 3) + (old_size_words * old_size_words / 512);
        
        (new_cost - old_cost) as u64
    }
    
    fn estimate_transaction_cost(&mut self, tx_data: &[u8]) -> u64 {
        const TX_DATA_ZERO_GAS: u64 = 4;
        const TX_DATA_NON_ZERO_GAS: u64 = 16;
        const TX_BASE_GAS: u64 = 21000;
        
        let mut total_cost = TX_BASE_GAS;
        
        for &byte in tx_data {
            if byte == 0 {
                total_cost += TX_DATA_ZERO_GAS;
            } else {
                total_cost += TX_DATA_NON_ZERO_GAS;
            }
        }
        
        total_cost
    }
}

#[derive(Debug)]
struct OpcodeExecution {
    opcode: u8,
    immediate_data: Option<Vec<u8>>,
    memory_access: Option<MemoryAccess>,
    storage_access: Option<StorageAccess>,
}

#[derive(Debug)]
struct MemoryAccess {
    offset: usize,
    size: usize,
}

#[derive(Debug)]
struct StorageAccess {
    key: [u8; 32],
    is_write: bool,
}

#[derive(Debug)]
struct GasCalculation {
    total_gas: u64,
    breakdown: HashMap<String, u64>,
}

// Example usage and testing
fn test_gas_calculator() {
    let mut calculator = GasCostCalculator::new();
    
    // Example: PUSH1 0x80, PUSH1 0x40, MSTORE
    let executions = vec![
        OpcodeExecution {
            opcode: 0x60, // PUSH1
            immediate_data: Some(vec![0x80]),
            memory_access: None,
            storage_access: None,
        },
        OpcodeExecution {
            opcode: 0x60, // PUSH1
            immediate_data: Some(vec![0x40]),
            memory_access: None,
            storage_access: None,
        },
        OpcodeExecution {
            opcode: 0x52, // MSTORE
            immediate_data: None,
            memory_access: Some(MemoryAccess { offset: 0x40, size: 32 }),
            storage_access: None,
        },
    ];
    
    let result = calculator.calculate_execution_cost(&executions);
    println!("Gas calculation: {:?}", result);
    
    // Expected: 3 + 3 + 3 + memory expansion cost
    assert!(result.total_gas > 9); // Should include memory expansion
}

// Analysis: This calculator demonstrates the complexity of EVM gas calculation.
// It handles dynamic costs for storage operations (warm/cold access), memory
// expansion quadratic costs, and data-dependent costs for operations like KECCAK256.
```

### Assignment 3 Answer: EVM Opcode Simulator

```rust
use std::collections::HashMap;

struct SimpleEVM {
    stack: Vec<[u8; 32]>,
    memory: Vec<u8>,
    storage: HashMap<[u8; 32], [u8; 32]>,
    pc: usize,
    gas_remaining: u64,
    bytecode: Vec<u8>,
    halted: bool,
    return_data: Vec<u8>,
}

impl SimpleEVM {
    fn new(bytecode: Vec<u8>, initial_gas: u64) -> Self {
        Self {
            stack: Vec::new(),
            memory: Vec::new(),
            storage: HashMap::new(),
            pc: 0,
            gas_remaining: initial_gas,
            bytecode,
            halted: false,
            return_data: Vec::new(),
        }
    }
    
    fn execute_step(&mut self) -> Result<ExecutionResult, EvmError> {
        if self.pc >= self.bytecode.len() {
            self.halted = true;
            return Ok(ExecutionResult::Halt);
        }
        
        let opcode = self.bytecode[self.pc];
        
        // Check gas before execution
        let gas_cost = self.get_gas_cost(opcode);
        if self.gas_remaining < gas_cost {
            return Err(EvmError::OutOfGas);
        }
        self.gas_remaining -= gas_cost;
        
        match opcode {
            0x00 => {
                // STOP
                self.halted = true;
                Ok(ExecutionResult::Halt)
            },
            0x01 => {
                // ADD
                self.execute_add()?;
                self.pc += 1;
                Ok(ExecutionResult::Continue)
            },
            0x02 => {
                // MUL
                self.execute_mul()?;
                self.pc += 1;
                Ok(ExecutionResult::Continue)
            },
            0x03 => {
                // SUB
                self.execute_sub()?;
                self.pc += 1;
                Ok(ExecutionResult::Continue)
            },
            0x50 => {
                // POP
                self.stack_pop()?;
                self.pc += 1;
                Ok(ExecutionResult::Continue)
            },
            0x51 => {
                // MLOAD
                self.execute_mload()?;
                self.pc += 1;
                Ok(ExecutionResult::Continue)
            },
            0x52 => {
                // MSTORE
                self.execute_mstore()?;
                self.pc += 1;
                Ok(ExecutionResult::Continue)
            },
            0x54 => {
                // SLOAD
                self.execute_sload()?;
                self.pc += 1;
                Ok(ExecutionResult::Continue)
            },
            0x55 => {
                // SSTORE
                self.execute_sstore()?;
                self.pc += 1;
                Ok(ExecutionResult::Continue)
            },
            0x56 => {
                // JUMP
                self.execute_jump()?;
                Ok(ExecutionResult::Continue)
            },
            0x57 => {
                // JUMPI
                self.execute_jumpi()?;
                Ok(ExecutionResult::Continue)
            },
            0x5B => {
                // JUMPDEST
                self.pc += 1;
                Ok(ExecutionResult::Continue)
            },
            0x60..=0x7F => {
                // PUSH1-PUSH32
                let push_size = (opcode - 0x60 + 1) as usize;
                self.execute_push(push_size)?;
                Ok(ExecutionResult::Continue)
            },
            0x80..=0x8F => {
                // DUP1-DUP16
                let dup_index = (opcode - 0x80 + 1) as usize;
                self.execute_dup(dup_index)?;
                self.pc += 1;
                Ok(ExecutionResult::Continue)
            },
            0x90..=0x9F => {
                // SWAP1-SWAP16
                let swap_index = (opcode - 0x90 + 1) as usize;
                self.execute_swap(swap_index)?;
                self.pc += 1;
                Ok(ExecutionResult::Continue)
            },
            0xF3 => {
                // RETURN
                self.execute_return()?;
                Ok(ExecutionResult::Halt)
            },
            0xFD => {
                // REVERT
                self.execute_revert()?;
                Ok(ExecutionResult::Revert)
            },
            _ => Err(EvmError::InvalidOpcode),
        }
    }
    
    fn execute_until_halt(&mut self) -> Result<FinalResult, EvmError> {
        let initial_gas = self.gas_remaining;
        
        while !self.halted && self.gas_remaining > 0 {
            match self.execute_step()? {
                ExecutionResult::Halt => break,
                ExecutionResult::Revert => {
                    return Ok(FinalResult {
                        gas_used: initial_gas - self.gas_remaining,
                        return_data: self.return_data.clone(),
                        success: false,
                    });
                },
                ExecutionResult::Continue => {},
            }
        }
        
        Ok(FinalResult {
            gas_used: initial_gas - self.gas_remaining,
            return_data: self.return_data.clone(),
            success: true,
        })
    }
    
    fn execute_push(&mut self, size: usize) -> Result<(), EvmError> {
        if self.pc + size >= self.bytecode.len() {
            return Err(EvmError::InvalidOpcode);
        }
        
        let mut value = [0u8; 32];
        let start_idx = 32 - size;
        
        for i in 0..size {
            value[start_idx + i] = self.bytecode[self.pc + 1 + i];
        }
        
        self.stack_push(value)?;
        self.pc += size + 1;
        Ok(())
    }
    
    fn execute_add(&mut self) -> Result<(), EvmError> {
        let b = self.stack_pop()?;
        let a = self.stack_pop()?;
        
        let result = self.u256_add(a, b);
        self.stack_push(result)?;
        Ok(())
    }
    
    fn execute_mul(&mut self) -> Result<(), EvmError> {
        let b = self.stack_pop()?;
        let a = self.stack_pop()?;
        
        let result = self.u256_mul(a, b);
        self.stack_push(result)?;
        Ok(())
    }
    
    fn execute_sub(&mut self) -> Result<(), EvmError> {
        let b = self.stack_pop()?;
        let a = self.stack_pop()?;
        
        let result = self.u256_sub(a, b);
        self.stack_push(result)?;
        Ok(())
    }
    
    fn execute_mstore(&mut self) -> Result<(), EvmError> {
        let offset = self.stack_pop()?;
        let value = self.stack_pop()?;
        
        let offset_usize = self.bytes_to_usize(&offset)?;
        self.ensure_memory_size(offset_usize + 32);
        
        for i in 0..32 {
            self.memory[offset_usize + i] = value[i];
        }
        
        Ok(())
    }
    
    fn execute_mload(&mut self) -> Result<(), EvmError> {
        let offset = self.stack_pop()?;
        let offset_usize = self.bytes_to_usize(&offset)?;
        
        self.ensure_memory_size(offset_usize + 32);
        
        let mut value = [0u8; 32];
        for i in 0..32 {
            value[i] = self.memory[offset_usize + i];
        }
        
        self.stack_push(value)?;
        Ok(())
    }
    
    fn execute_sstore(&mut self) -> Result<(), EvmError> {
        let key = self.stack_pop()?;
        let value = self.stack_pop()?;
        
        self.storage.insert(key, value);
        Ok(())
    }
    
    fn execute_sload(&mut self) -> Result<(), EvmError> {
        let key = self.stack_pop()?;
        let value = self.storage.get(&key).copied().unwrap_or([0u8; 32]);
        
        self.stack_push(value)?;
        Ok(())
    }
    
    fn execute_jump(&mut self) -> Result<(), EvmError> {
        let dest = self.stack_pop()?;
        let dest_pc = self.bytes_to_usize(&dest)?;
        
        if dest_pc >= self.bytecode.len() || self.bytecode[dest_pc] != 0x5B {
            return Err(EvmError::InvalidJump);
        }
        
        self.pc = dest_pc;
        Ok(())
    }
    
    fn execute_jumpi(&mut self) -> Result<(), EvmError> {
        let dest = self.stack_pop()?;
        let condition = self.stack_pop()?;
        
        if !self.is_zero(&condition) {
            let dest_pc = self.bytes_to_usize(&dest)?;
            
            if dest_pc >= self.bytecode.len() || self.bytecode[dest_pc] != 0x5B {
                return Err(EvmError::InvalidJump);
            }
            
            self.pc = dest_pc;
        } else {
            self.pc += 1;
        }
        
        Ok(())
    }
    
    fn execute_dup(&mut self, index: usize) -> Result<(), EvmError> {
        if self.stack.len() < index {
            return Err(EvmError::StackUnderflow);
        }
        
        let value = self.stack[self.stack.len() - index];
        self.stack_push(value)?;
        Ok(())
    }
    
    fn execute_swap(&mut self, index: usize) -> Result<(), EvmError> {
        if self.stack.len() <= index {
            return Err(EvmError::StackUnderflow);
        }
        
        let len = self.stack.len();
        self.stack.swap(len - 1, len - 1 - index);
        Ok(())
    }
    
    fn execute_return(&mut self) -> Result<(), EvmError> {
        let offset = self.stack_pop()?;
        let size = self.stack_pop()?;
        
        let offset_usize = self.bytes_to_usize(&offset)?;
        let size_usize = self.bytes_to_usize(&size)?;
        
        self.ensure_memory_size(offset_usize + size_usize);
        
        self.return_data = self.memory[offset_usize..offset_usize + size_usize].to_vec();
        self.halted = true;
        Ok(())
    }
    
    fn execute_revert(&mut self) -> Result<(), EvmError> {
        let offset = self.stack_pop()?;
        let size = self.stack_pop()?;
        
        let offset_usize = self.bytes_to_usize(&offset)?;
        let size_usize = self.bytes_to_usize(&size)?;
        
        self.ensure_memory_size(offset_usize + size_usize);
        
        self.return_data = self.memory[offset_usize..offset_usize + size_usize].to_vec();
        self.halted = true;
        Ok(())
    }
    
    // Utility methods
    fn stack_push(&mut self, value: [u8; 32]) -> Result<(), EvmError> {
        if self.stack.len() >= 1024 {
            return Err(EvmError::StackOverflow);
        }
        self.stack.push(value);
        Ok(())
    }
    
    fn stack_pop(&mut self) -> Result<[u8; 32], EvmError> {
        self.stack.pop().ok_or(EvmError::StackUnderflow)
    }
    
    fn ensure_memory_size(&mut self, required_size: usize) {
        if self.memory.len() < required_size {
            self.memory.resize(required_size, 0);
        }
    }
    
    fn bytes_to_usize(&self, bytes: &[u8; 32]) -> Result<usize, EvmError> {
        // Simple conversion - only use last 8 bytes for usize
        let mut result = 0usize;
        for &byte in &bytes[24..] {
            result = result.wrapping_shl(8).wrapping_add(byte as usize);
        }
        Ok(result)
    }
    
    fn is_zero(&self, value: &[u8; 32]) -> bool {
        value.iter().all(|&b| b == 0)
    }
    
    fn u256_add(&self, a: [u8; 32], b: [u8; 32]) -> [u8; 32] {
        let mut result = [0u8; 32];
        let mut carry = 0u16;
        
        for i in (0..32).rev() {
            let sum = a[i] as u16 + b[i] as u16 + carry;
            result[i] = sum as u8;
            carry = sum >> 8;
        }
        
        result
    }
    
    fn u256_mul(&self, a: [u8; 32], b: [u8; 32]) -> [u8; 32] {
        // Simplified multiplication - only handle small values correctly
        let a_low = u64::from_be_bytes([
            a[24], a[25], a[26], a[27], a[28], a[29], a[30], a[31]
        ]);
        let b_low = u64::from_be_bytes([
            b[24], b[25], b[26], b[27], b[28], b[29], b[30], b[31]
        ]);
        
        let result = a_low.wrapping_mul(b_low);
        let mut result_bytes = [0u8; 32];
        result_bytes[24..].copy_from_slice(&result.to_be_bytes());
        result_bytes
    }
    
    fn u256_sub(&self, a: [u8; 32], b: [u8; 32]) -> [u8; 32] {
        let mut result = [0u8; 32];
        let mut borrow = 0i16;
        
        for i in (0..32).rev() {
            let diff = a[i] as i16 - b[i] as i16 - borrow;
            if diff < 0 {
                result[i] = (diff + 256) as u8;
                borrow = 1;
            } else {
                result[i] = diff as u8;
                borrow = 0;
            }
        }
        
        result
    }
    
    fn get_gas_cost(&self, opcode: u8) -> u64 {
        match opcode {
            0x00 => 0,      // STOP
            0x01..=0x05 => 3, // ADD, MUL, SUB, DIV, SDIV
            0x50 => 2,      // POP
            0x51..=0x53 => 3, // MLOAD, MSTORE, MSTORE8
            0x54 => 200,    // SLOAD (simplified)
            0x55 => 5000,   // SSTORE (simplified)
            0x56 => 8,      // JUMP
            0x57 => 10,     // JUMPI
            0x5B => 1,      // JUMPDEST
            0x60..=0x7F => 3, // PUSH1-PUSH32
            0x80..=0x8F => 3, // DUP1-DUP16
            0x90..=0x9F => 3, // SWAP1-SWAP16
            0xF3 => 0,      // RETURN
            0xFD => 0,      // REVERT
            _ => 3,         // Default
        }
    }
}

#[derive(Debug)]
enum ExecutionResult {
    Continue,
    Halt,
    Revert,
}

#[derive(Debug)]
struct FinalResult {
    gas_used: u64,
    return_data: Vec<u8>,
    success: bool,
}

#[derive(Debug)]
enum EvmError {
    StackUnderflow,
    StackOverflow,
    OutOfGas,
    InvalidOpcode,
    InvalidJump,
}

// Example usage
fn test_simple_evm() {
    // Bytecode: PUSH1 5 PUSH1 3 ADD STOP
    let bytecode = vec![0x60, 0x05, 0x60, 0x03, 0x01, 0x00];
    let mut evm = SimpleEVM::new(bytecode, 1000);
    
    match evm.execute_until_halt() {
        Ok(result) => {
            println!("Execution successful!");
            println!("Gas used: {}", result.gas_used);
            println!("Final stack: {:?}", evm.stack);
            // Should have [8] on stack (5 + 3)
        },
        Err(e) => println!("Execution failed: {:?}", e),
    }
}

// Analysis: This simplified EVM demonstrates the core mechanics of opcode
// execution including stack management, memory operations, and control flow.
// It shows how each opcode manipulates the EVM state and how gas is consumed.
// While simplified, it captures the essential patterns of EVM execution.
```

## Questions to Ponder

1. **Opcode Design Philosophy**: Why does the EVM use a stack-based architecture rather than a register-based one? What are the trade-offs in terms of code size, gas costs, and implementation complexity?

2. **Gas Cost Evolution**: How have opcode gas costs evolved over time through EIPs? Consider the impact of EIP-150 (gas cost changes) and EIP-2929 (cold/warm storage access).

3. **Security Considerations**: What opcode-level security measures prevent common attack vectors? How do opcodes like JUMPDEST and static call restrictions enhance security?

4. **Optimization Opportunities**: How could opcode execution be optimized in practice? Consider just-in-time compilation, superinstructions, and parallel execution possibilities.

5. **Future Evolution**: What new opcodes might be added to support emerging use cases? How do features like account abstraction (EIP-7702) introduce new opcode requirements?