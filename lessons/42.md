# Lesson 42: Optimistic Concurrency Control

*"It doesn't matter how beautiful your theory is, it doesn't matter how smart you are. If it doesn't agree with experiment, it's wrong." - Richard Feynman*

## Files with Inline Comments for This Lesson
- `crates/storage/provider/src/providers/database/provider.rs` - Database provider with transaction isolation
- `crates/revm/src/database.rs` - State database interface with versioning
- `crates/storage/db/src/implementation/mdbx/tx.rs` - Transaction isolation levels
- `crates/evm/execution-types/src/bundle_state.rs` - State bundle conflict detection
- `crates/storage/provider/src/bundle_state_provider.rs` - Optimistic state management

## What is Optimistic Concurrency Control?

Imagine you're editing a Wikipedia article. Instead of locking the entire article while you work (pessimistic), Wikipedia lets everyone edit simultaneously and merges changes when you save (optimistic). If two people edited the same paragraph, Wikipedia detects the conflict and asks you to resolve it.

**Why be optimistic?** In blockchain execution, most transactions don't actually conflict - they touch different accounts or contracts. Locking everything "just in case" would destroy performance. OCC says: "Let's assume things will work out, and deal with conflicts when they happen."

**The banking analogy:** Traditional databases are like old banks - you wait in line for a teller who locks your account during the entire transaction. OCC is like modern mobile banking - multiple operations happen simultaneously, with the bank only checking for conflicts when you try to finalize.

**Key insight:** The cost of optimistically executing and occasionally retrying is much lower than the cost of pessimistically locking everything.

```
OCC vs Pessimistic Locking:
┌─────────────────────────────────────────────────┐
│           Pessimistic (Traditional)             │
│  TX1: Lock A ──► Read A ──► Write A ──► Unlock │
│  TX2: Wait... ──────────────► Lock A ──► ...   │
│  Problem: TX2 waits even if no real conflict!  │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│             Optimistic (Modern)                 │
│  TX1: Read A (v1) ──► Compute ──► Validate ──► │
│  TX2: Read A (v1) ──► Compute ──► Validate ──► │
│  Both proceed! Conflict detected at validation  │
└─────────────────────────────────────────────────┘
```

## Version-Based State Management

Each state modification gets a version number for conflict detection:

```rust
/// Version-based state management for OCC
/// Located in: crates/revm/src/database.rs

use alloy_primitives::{Address, B256, U256};
use std::sync::atomic::{AtomicU64, Ordering};

/// LESSON 42: Versioned State Database
/// Each read/write is tagged with a version for conflict detection
pub trait VersionedDatabase: Database {
    /// Current global version
    fn current_version(&self) -> u64;
    
    /// Read with version tracking
    fn versioned_basic(
        &self,
        address: Address,
    ) -> Result<(Option<AccountInfo>, u64), Self::Error>;
    
    /// Read storage with version tracking
    fn versioned_storage(
        &self,
        address: Address,
        slot: B256,
    ) -> Result<(B256, u64), Self::Error>;
}

/// Optimistic transaction execution context
#[derive(Debug)]
pub struct OptimisticTransaction<DB> {
    /// Base database
    db: Arc<DB>,
    /// Transaction start version
    start_version: u64,
    /// Read set with versions
    read_set: RwLock<HashMap<StateKey, u64>>,
    /// Write set (uncommitted changes)
    write_set: RwLock<HashMap<StateKey, StateValue>>,
    /// Execution trace for replay
    execution_trace: RwLock<ExecutionTrace>,
}

#[derive(Debug, Clone, Hash, Eq, PartialEq)]
enum StateKey {
    Account(Address),
    Storage(Address, B256),
    Code(Address),
}

#[derive(Debug, Clone)]
enum StateValue {
    Account(Option<AccountInfo>),
    Storage(B256),
    Code(Option<Bytecode>),
}

impl<DB: VersionedDatabase> OptimisticTransaction<DB> {
    pub fn new(db: Arc<DB>) -> Self {
        Self {
            start_version: db.current_version(),
            db,
            read_set: RwLock::new(HashMap::new()),
            write_set: RwLock::new(HashMap::new()),
            execution_trace: RwLock::new(ExecutionTrace::default()),
        }
    }
    
    /// Read account optimistically
    /// LESSON 42: Read Tracking
    /// We track what version we read to detect conflicts later
    pub fn basic(&self, address: Address) -> Result<Option<AccountInfo>, DB::Error> {
        let key = StateKey::Account(address);
        
        // Check write set first (read-your-writes)
        if let Some(StateValue::Account(info)) = self.write_set.read().get(&key) {
            return Ok(info.clone());
        }
        
        // Read from base DB with version
        let (account, version) = self.db.versioned_basic(address)?;
        
        // Track read version
        self.read_set.write().insert(key, version);
        self.execution_trace.write().record_read(address, version);
        
        Ok(account)
    }
    
    /// Write account optimistically
    pub fn insert_account(&self, address: Address, info: AccountInfo) {
        let key = StateKey::Account(address);
        self.write_set.write().insert(
            key,
            StateValue::Account(Some(info))
        );
        self.execution_trace.write().record_write(address);
    }
    
    /// Validate transaction for conflicts
    /// LESSON 42: Conflict Validation
    /// Check if any values we read have changed since we started
    pub fn validate(&self) -> Result<ValidationResult, DB::Error> {
        let current_version = self.db.current_version();
        let read_set = self.read_set.read();
        
        for (key, read_version) in read_set.iter() {
            let current_value_version = match key {
                StateKey::Account(addr) => {
                    let (_, version) = self.db.versioned_basic(*addr)?;
                    version
                }
                StateKey::Storage(addr, slot) => {
                    let (_, version) = self.db.versioned_storage(*addr, *slot)?;
                    version
                }
                StateKey::Code(addr) => {
                    // Similar for code...
                    todo!()
                }
            };
            
            // LESSON 42: Version Check
            // If version changed, someone else modified this value
            if current_value_version > *read_version {
                return Ok(ValidationResult::Conflict(ConflictInfo {
                    key: key.clone(),
                    read_version: *read_version,
                    current_version: current_value_version,
                }));
            }
        }
        
        Ok(ValidationResult::Valid)
    }
    
    /// Commit changes if validation passed
    pub fn commit(self) -> Result<CommitResult, DB::Error> {
        match self.validate()? {
            ValidationResult::Valid => {
                // Apply write set to database
                let writes = self.write_set.into_inner();
                let new_version = self.db.current_version() + 1;
                
                // In real implementation, this would be atomic
                for (key, value) in writes {
                    match (key, value) {
                        (StateKey::Account(addr), StateValue::Account(info)) => {
                            self.db.commit_account(addr, info, new_version)?;
                        }
                        // ... other cases
                        _ => {}
                    }
                }
                
                Ok(CommitResult::Success { version: new_version })
            }
            ValidationResult::Conflict(info) => {
                Ok(CommitResult::Conflict(info))
            }
        }
    }
}

#[derive(Debug)]
enum ValidationResult {
    Valid,
    Conflict(ConflictInfo),
}

#[derive(Debug)]
struct ConflictInfo {
    key: StateKey,
    read_version: u64,
    current_version: u64,
}
```

## Multi-Version Concurrency Control (MVCC)

MVCC maintains multiple versions of data to allow concurrent reads:

```rust
/// Multi-version state storage
/// Located in: crates/storage/provider/src/bundle_state_provider.rs

/// LESSON 42: MVCC Storage
/// Keep multiple versions of state for concurrent access
pub struct MVCCStateProvider<DB> {
    /// Base database
    base: Arc<DB>,
    /// Version snapshots
    versions: RwLock<BTreeMap<u64, VersionSnapshot>>,
    /// Current version counter
    current_version: AtomicU64,
    /// Garbage collection threshold
    gc_threshold: u64,
}

#[derive(Debug, Clone)]
struct VersionSnapshot {
    /// Version number
    version: u64,
    /// Timestamp
    timestamp: Instant,
    /// State changes in this version
    changes: StateChanges,
    /// Parent version
    parent: Option<u64>,
}

#[derive(Debug, Clone, Default)]
struct StateChanges {
    /// Account changes
    accounts: HashMap<Address, Option<Account>>,
    /// Storage changes
    storage: HashMap<Address, HashMap<B256, U256>>,
    /// Code changes
    code: HashMap<Address, Option<Bytecode>>,
}

impl<DB: StateProvider> MVCCStateProvider<DB> {
    /// Read account at specific version
    /// LESSON 42: Version-Aware Reads
    /// We can read any historical version without blocking writers
    pub fn account_at_version(
        &self,
        address: Address,
        version: u64,
    ) -> Result<Option<Account>, ProviderError> {
        let versions = self.versions.read();
        
        // Walk back through versions to find account state
        let mut current_version = version;
        loop {
            if let Some(snapshot) = versions.get(&current_version) {
                if let Some(account) = snapshot.changes.accounts.get(&address) {
                    return Ok(account.clone());
                }
                
                // Check parent version
                if let Some(parent) = snapshot.parent {
                    current_version = parent;
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        
        // Not found in versions, check base
        self.base.account(address)
    }
    
    /// Create new version with changes
    /// LESSON 42: Version Creation
    /// Each write creates a new version without modifying old ones
    pub fn create_version(
        &self,
        parent: u64,
        changes: StateChanges,
    ) -> Result<u64, ProviderError> {
        let version = self.current_version.fetch_add(1, Ordering::SeqCst);
        
        let snapshot = VersionSnapshot {
            version,
            timestamp: Instant::now(),
            changes,
            parent: Some(parent),
        };
        
        self.versions.write().insert(version, snapshot);
        
        // Trigger GC if needed
        if version % self.gc_threshold == 0 {
            self.garbage_collect()?;
        }
        
        Ok(version)
    }
    
    /// Garbage collect old versions
    fn garbage_collect(&self) -> Result<(), ProviderError> {
        let mut versions = self.versions.write();
        let current = self.current_version.load(Ordering::SeqCst);
        
        // Keep only recent versions
        let cutoff = current.saturating_sub(self.gc_threshold * 2);
        versions.retain(|&version, _| version > cutoff);
        
        Ok(())
    }
}
```

## Optimistic Execution Pipeline

The complete OCC execution flow:

```rust
/// Optimistic execution pipeline
/// Located in: crates/evm/execution-types/src/bundle_state.rs

/// LESSON 42: OCC Executor
/// Coordinates optimistic execution with retry logic
pub struct OptimisticExecutor<E> {
    /// Inner executor
    executor: E,
    /// Retry policy
    retry_policy: RetryPolicy,
    /// Conflict resolver
    conflict_resolver: ConflictResolver,
    /// Performance metrics
    metrics: Arc<OCCMetrics>,
}

#[derive(Debug, Clone)]
pub struct RetryPolicy {
    /// Maximum retry attempts
    max_retries: usize,
    /// Backoff strategy
    backoff: BackoffStrategy,
    /// Conflict threshold for fallback
    conflict_threshold: f64,
}

#[derive(Debug, Clone)]
pub enum BackoffStrategy {
    /// Fixed delay
    Fixed(Duration),
    /// Exponential backoff
    Exponential { base: Duration, max: Duration },
    /// Adaptive based on conflict rate
    Adaptive,
}

impl<E: TransactionExecutor> OptimisticExecutor<E> {
    /// Execute transaction optimistically
    /// LESSON 42: Complete OCC Flow
    /// 1. Execute optimistically
    /// 2. Validate for conflicts
    /// 3. Retry if needed
    /// 4. Fall back to pessimistic if too many conflicts
    pub async fn execute_transaction(
        &self,
        tx: Transaction,
    ) -> Result<ExecutionResult, Error> {
        let start = Instant::now();
        let mut attempts = 0;
        let mut last_conflict = None;
        
        loop {
            attempts += 1;
            
            // Create optimistic context
            let ctx = self.create_optimistic_context();
            
            // Execute transaction
            let exec_result = self.executor.execute(&tx, &ctx).await?;
            
            // Validate for conflicts
            match ctx.validate() {
                Ok(ValidationResult::Valid) => {
                    // Success! Commit changes
                    match ctx.commit() {
                        Ok(CommitResult::Success { version }) => {
                            self.metrics.record_success(attempts, start.elapsed());
                            return Ok(exec_result);
                        }
                        Ok(CommitResult::Conflict(info)) => {
                            // Race condition during commit
                            last_conflict = Some(info);
                        }
                        Err(e) => return Err(e.into()),
                    }
                }
                Ok(ValidationResult::Conflict(info)) => {
                    last_conflict = Some(info);
                    self.metrics.record_conflict();
                }
                Err(e) => return Err(e.into()),
            }
            
            // Check retry policy
            if attempts >= self.retry_policy.max_retries {
                return Err(Error::MaxRetriesExceeded(last_conflict));
            }
            
            // Apply backoff
            self.apply_backoff(attempts).await;
            
            // Check if we should fall back to pessimistic
            if self.should_use_pessimistic() {
                return self.execute_pessimistic(tx).await;
            }
        }
    }
    
    fn should_use_pessimistic(&self) -> bool {
        let conflict_rate = self.metrics.recent_conflict_rate();
        conflict_rate > self.retry_policy.conflict_threshold
    }
    
    async fn apply_backoff(&self, attempt: usize) {
        let delay = match &self.retry_policy.backoff {
            BackoffStrategy::Fixed(duration) => *duration,
            BackoffStrategy::Exponential { base, max } => {
                let delay = base.mul_f64(2f64.powi(attempt as i32 - 1));
                delay.min(*max)
            }
            BackoffStrategy::Adaptive => {
                // Adjust based on recent conflict patterns
                self.calculate_adaptive_delay()
            }
        };
        
        tokio::time::sleep(delay).await;
    }
    
    fn calculate_adaptive_delay(&self) -> Duration {
        let base = Duration::from_micros(100);
        let conflict_rate = self.metrics.recent_conflict_rate();
        
        // Higher conflict rate = longer delay
        base.mul_f64(1.0 + conflict_rate * 10.0)
    }
}

/// Metrics for OCC performance
#[derive(Debug, Default)]
struct OCCMetrics {
    /// Successful commits
    successes: AtomicU64,
    /// Conflicts detected
    conflicts: AtomicU64,
    /// Retry counts
    retry_histogram: RwLock<Vec<u64>>,
    /// Recent conflict window
    recent_conflicts: RwLock<VecDeque<(Instant, bool)>>,
}

impl OCCMetrics {
    fn record_success(&self, attempts: usize, duration: Duration) {
        self.successes.fetch_add(1, Ordering::Relaxed);
        
        let mut histogram = self.retry_histogram.write();
        if attempts <= histogram.len() {
            histogram[attempts - 1] += 1;
        }
        
        self.recent_conflicts.write().push_back((Instant::now(), false));
    }
    
    fn record_conflict(&self) {
        self.conflicts.fetch_add(1, Ordering::Relaxed);
        self.recent_conflicts.write().push_back((Instant::now(), true));
    }
    
    fn recent_conflict_rate(&self) -> f64 {
        let mut recent = self.recent_conflicts.write();
        
        // Clean old entries
        let cutoff = Instant::now() - Duration::from_secs(60);
        recent.retain(|(time, _)| *time > cutoff);
        
        if recent.is_empty() {
            return 0.0;
        }
        
        let conflicts = recent.iter().filter(|(_, is_conflict)| *is_conflict).count();
        conflicts as f64 / recent.len() as f64
    }
}
```

## Conflict Resolution Strategies

Different ways to handle conflicts:

```rust
/// Conflict resolution strategies
/// Located in: crates/storage/provider/src/providers/database/provider.rs

/// LESSON 42: Conflict Resolution
/// Different strategies for handling OCC conflicts
pub struct ConflictResolver {
    strategy: ResolutionStrategy,
}

#[derive(Debug, Clone)]
pub enum ResolutionStrategy {
    /// First-wins: earlier transaction takes precedence
    FirstWins,
    /// Last-wins: later transaction overwrites
    LastWins,
    /// Priority-based: higher priority transaction wins
    PriorityBased,
    /// Merge: try to merge non-conflicting changes
    Merge(MergeStrategy),
    /// Custom resolution function
    Custom(Arc<dyn Fn(&ConflictInfo) -> Resolution + Send + Sync>),
}

#[derive(Debug, Clone)]
pub enum MergeStrategy {
    /// Merge account balance changes additively
    AdditiveBalance,
    /// Merge storage changes if non-overlapping
    NonOverlappingStorage,
    /// Complex domain-specific merge
    DomainSpecific,
}

impl ConflictResolver {
    /// Resolve conflict between two transactions
    pub fn resolve(
        &self,
        conflict: &ConflictInfo,
        tx1: &TransactionContext,
        tx2: &TransactionContext,
    ) -> Resolution {
        match &self.strategy {
            ResolutionStrategy::FirstWins => {
                if tx1.timestamp < tx2.timestamp {
                    Resolution::UseTx1
                } else {
                    Resolution::UseTx2
                }
            }
            ResolutionStrategy::LastWins => {
                if tx1.timestamp > tx2.timestamp {
                    Resolution::UseTx1
                } else {
                    Resolution::UseTx2
                }
            }
            ResolutionStrategy::PriorityBased => {
                if tx1.priority > tx2.priority {
                    Resolution::UseTx1
                } else if tx2.priority > tx1.priority {
                    Resolution::UseTx2
                } else {
                    // Same priority, use timestamp
                    self.resolve_by_timestamp(tx1, tx2)
                }
            }
            ResolutionStrategy::Merge(merge_strategy) => {
                self.attempt_merge(conflict, tx1, tx2, merge_strategy)
            }
            ResolutionStrategy::Custom(resolver) => {
                resolver(conflict)
            }
        }
    }
    
    fn attempt_merge(
        &self,
        conflict: &ConflictInfo,
        tx1: &TransactionContext,
        tx2: &TransactionContext,
        strategy: &MergeStrategy,
    ) -> Resolution {
        match strategy {
            MergeStrategy::AdditiveBalance => {
                // LESSON 42: Merge Example
                // If both transactions modify balance, we can merge additively
                if let StateKey::Account(addr) = &conflict.key {
                    if let (Some(delta1), Some(delta2)) = (
                        tx1.get_balance_delta(addr),
                        tx2.get_balance_delta(addr),
                    ) {
                        // Both are transfers, merge them
                        return Resolution::Merge(MergedState {
                            key: conflict.key.clone(),
                            value: StateValue::Account(Some(Account {
                                balance: delta1 + delta2,
                                ..Default::default()
                            })),
                        });
                    }
                }
                Resolution::Retry
            }
            MergeStrategy::NonOverlappingStorage => {
                // Check if storage modifications don't overlap
                if let StateKey::Storage(addr, _) = &conflict.key {
                    let slots1 = tx1.get_modified_slots(addr);
                    let slots2 = tx2.get_modified_slots(addr);
                    
                    if slots1.is_disjoint(&slots2) {
                        // No overlap, can merge
                        return Resolution::MergeBoth;
                    }
                }
                Resolution::Retry
            }
            MergeStrategy::DomainSpecific => {
                // Application-specific merge logic
                Resolution::Retry
            }
        }
    }
}

#[derive(Debug)]
pub enum Resolution {
    UseTx1,
    UseTx2,
    Retry,
    Merge(MergedState),
    MergeBoth,
    Abort,
}

#[derive(Debug)]
struct MergedState {
    key: StateKey,
    value: StateValue,
}
```

## Assignments

### Assignment 1: Simple OCC Implementation (Easy)
Create a basic OCC system for a key-value store.

**Your Task**: Implement a `SimpleOCCStore` that tracks versions and detects conflicts for concurrent updates.

### Assignment 2: MVCC Garbage Collector (Medium)
Build a garbage collector for MVCC that keeps memory usage bounded.

**Your Task**: Create an `MVCCGarbageCollector` that removes old versions while ensuring active transactions can still read their required versions.

### Assignment 3: Adaptive Conflict Resolution (Hard)
Design a conflict resolver that learns from patterns to optimize resolution strategy.

**Your Task**: Implement an `AdaptiveConflictResolver` that tracks conflict patterns and automatically adjusts its resolution strategy.

## Assignment Answers

### Answer 1: Simple OCC Implementation

```rust
use std::sync::{Arc, RwLock};
use std::sync::atomic::{AtomicU64, Ordering};
use std::collections::HashMap;

/// Simple OCC key-value store
pub struct SimpleOCCStore<K: Clone + Eq + std::hash::Hash, V: Clone> {
    /// Current data with versions
    data: Arc<RwLock<HashMap<K, VersionedValue<V>>>>,
    /// Global version counter
    version_counter: Arc<AtomicU64>,
}

#[derive(Clone, Debug)]
struct VersionedValue<V> {
    value: V,
    version: u64,
}

/// Transaction handle for OCC operations
pub struct OCCTransaction<K: Clone + Eq + std::hash::Hash, V: Clone> {
    /// Store reference
    store: Arc<SimpleOCCStore<K, V>>,
    /// Read set
    reads: HashMap<K, u64>,
    /// Write set
    writes: HashMap<K, V>,
    /// Transaction start version
    start_version: u64,
}

impl<K: Clone + Eq + std::hash::Hash, V: Clone> SimpleOCCStore<K, V> {
    pub fn new() -> Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
            version_counter: Arc::new(AtomicU64::new(0)),
        }
    }
    
    /// Begin a new transaction
    pub fn begin_transaction(&self) -> OCCTransaction<K, V> {
        OCCTransaction {
            store: Arc::new(self.clone()),
            reads: HashMap::new(),
            writes: HashMap::new(),
            start_version: self.version_counter.load(Ordering::SeqCst),
        }
    }
    
    /// Direct read (non-transactional)
    pub fn read(&self, key: &K) -> Option<V> {
        self.data.read().unwrap()
            .get(key)
            .map(|v| v.value.clone())
    }
}

impl<K: Clone + Eq + std::hash::Hash, V: Clone> Clone for SimpleOCCStore<K, V> {
    fn clone(&self) -> Self {
        Self {
            data: self.data.clone(),
            version_counter: self.version_counter.clone(),
        }
    }
}

impl<K: Clone + Eq + std::hash::Hash, V: Clone> OCCTransaction<K, V> {
    /// Read value in transaction
    pub fn read(&mut self, key: &K) -> Option<V> {
        // Check write set first (read-your-writes)
        if let Some(value) = self.writes.get(key) {
            return Some(value.clone());
        }
        
        // Read from store
        let data = self.store.data.read().unwrap();
        if let Some(versioned) = data.get(key) {
            // Track read version
            self.reads.insert(key.clone(), versioned.version);
            Some(versioned.value.clone())
        } else {
            // Track that we read "none"
            self.reads.insert(key.clone(), 0);
            None
        }
    }
    
    /// Write value in transaction
    pub fn write(&mut self, key: K, value: V) {
        self.writes.insert(key, value);
    }
    
    /// Validate transaction
    pub fn validate(&self) -> Result<(), ConflictError> {
        let data = self.store.data.read().unwrap();
        
        for (key, read_version) in &self.reads {
            let current_version = data
                .get(key)
                .map(|v| v.version)
                .unwrap_or(0);
            
            if current_version != *read_version {
                return Err(ConflictError {
                    key: format!("{:?}", key),
                    read_version: *read_version,
                    current_version,
                });
            }
        }
        
        Ok(())
    }
    
    /// Commit transaction
    pub fn commit(self) -> Result<(), CommitError> {
        // Validate first
        self.validate()?;
        
        // Acquire write lock and re-validate
        let mut data = self.store.data.write().unwrap();
        
        // Re-validate under lock
        for (key, read_version) in &self.reads {
            let current_version = data
                .get(key)
                .map(|v| v.version)
                .unwrap_or(0);
            
            if current_version != *read_version {
                return Err(CommitError::Conflict(ConflictError {
                    key: format!("{:?}", key),
                    read_version: *read_version,
                    current_version,
                }));
            }
        }
        
        // Apply writes
        let new_version = self.store.version_counter.fetch_add(1, Ordering::SeqCst) + 1;
        
        for (key, value) in self.writes {
            data.insert(key, VersionedValue {
                value,
                version: new_version,
            });
        }
        
        Ok(())
    }
}

#[derive(Debug, Clone)]
pub struct ConflictError {
    key: String,
    read_version: u64,
    current_version: u64,
}

#[derive(Debug)]
pub enum CommitError {
    Conflict(ConflictError),
}

impl From<ConflictError> for CommitError {
    fn from(err: ConflictError) -> Self {
        CommitError::Conflict(err)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;
    
    #[test]
    fn test_occ_no_conflict() {
        let store = SimpleOCCStore::new();
        
        // TX1: Write A=1
        let mut tx1 = store.begin_transaction();
        tx1.write("A", 1);
        assert!(tx1.commit().is_ok());
        
        // TX2: Read A, Write B=2
        let mut tx2 = store.begin_transaction();
        assert_eq!(tx2.read(&"A"), Some(1));
        tx2.write("B", 2);
        assert!(tx2.commit().is_ok());
    }
    
    #[test]
    fn test_occ_conflict() {
        let store = Arc::new(SimpleOCCStore::new());
        store.begin_transaction().write("A", 0).commit().unwrap();
        
        let store1 = store.clone();
        let store2 = store.clone();
        
        // Start two transactions
        let handle1 = thread::spawn(move || {
            let mut tx = store1.begin_transaction();
            let a = tx.read(&"A").unwrap();
            thread::sleep(std::time::Duration::from_millis(50));
            tx.write("A", a + 1);
            tx.commit()
        });
        
        let handle2 = thread::spawn(move || {
            thread::sleep(std::time::Duration::from_millis(25));
            let mut tx = store2.begin_transaction();
            let a = tx.read(&"A").unwrap();
            tx.write("A", a + 2);
            tx.commit()
        });
        
        let result1 = handle1.join().unwrap();
        let result2 = handle2.join().unwrap();
        
        // One should succeed, one should fail
        assert!(result1.is_ok() != result2.is_ok());
    }
}
```

### Answer 2: MVCC Garbage Collector

```rust
use std::sync::{Arc, RwLock, Weak};
use std::collections::{BTreeMap, HashSet};
use std::time::{Duration, Instant};

/// MVCC with garbage collection
pub struct MVCCWithGC<K: Ord + Clone, V: Clone> {
    /// Version storage
    versions: Arc<RwLock<VersionStorage<K, V>>>,
    /// Active transactions
    active_transactions: Arc<RwLock<HashSet<u64>>>,
    /// GC configuration
    gc_config: GCConfig,
}

#[derive(Debug)]
struct VersionStorage<K, V> {
    /// All versions
    versions: BTreeMap<u64, VersionData<K, V>>,
    /// Index: key -> versions
    key_versions: HashMap<K, BTreeSet<u64>>,
    /// Current version
    current_version: u64,
}

#[derive(Debug, Clone)]
struct VersionData<K, V> {
    timestamp: Instant,
    changes: HashMap<K, Option<V>>,
}

#[derive(Debug, Clone)]
struct GCConfig {
    /// Minimum versions to keep
    min_versions: usize,
    /// Maximum age of versions
    max_age: Duration,
    /// GC interval
    gc_interval: Duration,
    /// Max memory usage (bytes)
    max_memory: usize,
}

impl Default for GCConfig {
    fn default() -> Self {
        Self {
            min_versions: 10,
            max_age: Duration::from_secs(300), // 5 minutes
            gc_interval: Duration::from_secs(60), // 1 minute
            max_memory: 100 * 1024 * 1024, // 100MB
        }
    }
}

/// MVCC transaction handle
pub struct MVCCTransaction<K: Ord + Clone, V: Clone> {
    store: Weak<RwLock<VersionStorage<K, V>>>,
    version: u64,
    active_ref: Arc<RwLock<HashSet<u64>>>,
}

impl<K: Ord + Clone, V: Clone> MVCCWithGC<K, V> {
    pub fn new(gc_config: GCConfig) -> Self {
        let storage = Arc::new(RwLock::new(VersionStorage {
            versions: BTreeMap::new(),
            key_versions: HashMap::new(),
            current_version: 0,
        }));
        
        let gc = Self {
            versions: storage.clone(),
            active_transactions: Arc::new(RwLock::new(HashSet::new())),
            gc_config: gc_config.clone(),
        };
        
        // Start GC thread
        let gc_clone = gc.clone();
        std::thread::spawn(move || {
            gc_clone.gc_loop();
        });
        
        gc
    }
    
    /// Begin transaction at current version
    pub fn begin_transaction(&self) -> MVCCTransaction<K, V> {
        let version = self.versions.read().unwrap().current_version;
        self.active_transactions.write().unwrap().insert(version);
        
        MVCCTransaction {
            store: Arc::downgrade(&self.versions),
            version,
            active_ref: self.active_transactions.clone(),
        }
    }
    
    /// Garbage collection loop
    fn gc_loop(&self) {
        loop {
            std::thread::sleep(self.gc_config.gc_interval);
            if let Err(e) = self.run_gc() {
                eprintln!("GC error: {:?}", e);
            }
        }
    }
    
    /// Run garbage collection
    fn run_gc(&self) -> Result<GCStats, GCError> {
        let mut stats = GCStats::default();
        let active_txs = self.active_transactions.read().unwrap();
        let min_active_version = active_txs.iter().min().copied();
        
        let mut storage = self.versions.write().unwrap();
        let current_version = storage.current_version;
        
        // Determine versions to keep
        let mut keep_versions = HashSet::new();
        
        // Keep active transaction versions
        keep_versions.extend(active_txs.iter());
        
        // Keep minimum number of recent versions
        let recent_cutoff = current_version.saturating_sub(self.gc_config.min_versions as u64);
        for v in recent_cutoff..=current_version {
            keep_versions.insert(v);
        }
        
        // Keep versions within max age
        let age_cutoff = Instant::now() - self.gc_config.max_age;
        
        // Collect versions to remove
        let mut remove_versions = Vec::new();
        let mut total_size = 0;
        
        for (&version, data) in &storage.versions {
            let version_size = self.estimate_size(&data.changes);
            total_size += version_size;
            
            let should_keep = keep_versions.contains(&version) ||
                             data.timestamp > age_cutoff ||
                             (min_active_version.is_some() && version >= min_active_version.unwrap());
            
            if !should_keep {
                remove_versions.push(version);
                stats.versions_removed += 1;
                stats.bytes_freed += version_size;
            }
        }
        
        // Remove versions if over memory limit
        if total_size > self.gc_config.max_memory {
            // Sort by version (oldest first)
            let mut all_versions: Vec<_> = storage.versions.keys().copied().collect();
            all_versions.sort();
            
            for version in all_versions {
                if total_size <= self.gc_config.max_memory {
                    break;
                }
                
                if !keep_versions.contains(&version) && !remove_versions.contains(&version) {
                    if let Some(data) = storage.versions.get(&version) {
                        let size = self.estimate_size(&data.changes);
                        remove_versions.push(version);
                        stats.versions_removed += 1;
                        stats.bytes_freed += size;
                        total_size -= size;
                    }
                }
            }
        }
        
        // Actually remove versions
        for version in remove_versions {
            if let Some(data) = storage.versions.remove(&version) {
                // Update key index
                for key in data.changes.keys() {
                    if let Some(versions) = storage.key_versions.get_mut(key) {
                        versions.remove(&version);
                        if versions.is_empty() {
                            storage.key_versions.remove(key);
                        }
                    }
                }
            }
        }
        
        stats.versions_kept = storage.versions.len();
        Ok(stats)
    }
    
    fn estimate_size(&self, changes: &HashMap<K, Option<V>>) -> usize {
        // Rough estimate
        changes.len() * (std::mem::size_of::<K>() + std::mem::size_of::<V>() + 16)
    }
}

impl<K: Ord + Clone, V: Clone> Clone for MVCCWithGC<K, V> {
    fn clone(&self) -> Self {
        Self {
            versions: self.versions.clone(),
            active_transactions: self.active_transactions.clone(),
            gc_config: self.gc_config.clone(),
        }
    }
}

impl<K: Ord + Clone, V: Clone> Drop for MVCCTransaction<K, V> {
    fn drop(&mut self) {
        // Remove from active transactions
        self.active_ref.write().unwrap().remove(&self.version);
    }
}

#[derive(Debug, Default)]
struct GCStats {
    versions_removed: usize,
    versions_kept: usize,
    bytes_freed: usize,
}

#[derive(Debug)]
enum GCError {
    LockError,
}
```

### Answer 3: Adaptive Conflict Resolution

```rust
use std::sync::{Arc, RwLock};
use std::collections::{HashMap, VecDeque};
use std::time::{Duration, Instant};

/// Adaptive conflict resolver that learns from patterns
pub struct AdaptiveConflictResolver {
    /// Historical conflict data
    history: Arc<RwLock<ConflictHistory>>,
    /// Current strategy
    current_strategy: Arc<RwLock<ResolutionStrategy>>,
    /// Learning parameters
    learning_params: LearningParams,
    /// Strategy evaluator
    evaluator: StrategyEvaluator,
}

#[derive(Debug, Default)]
struct ConflictHistory {
    /// Recent conflicts
    recent_conflicts: VecDeque<ConflictRecord>,
    /// Pattern statistics
    patterns: HashMap<ConflictPattern, PatternStats>,
    /// Strategy performance
    strategy_performance: HashMap<ResolutionStrategy, PerformanceStats>,
}

#[derive(Debug, Clone)]
struct ConflictRecord {
    timestamp: Instant,
    pattern: ConflictPattern,
    resolution: ResolutionStrategy,
    outcome: ResolutionOutcome,
}

#[derive(Debug, Clone, Hash, Eq, PartialEq)]
enum ConflictPattern {
    /// Both transactions modify same account balance
    BalanceConflict { address: String },
    /// Storage slot conflict
    StorageConflict { address: String, slot: String },
    /// High-frequency trader pattern
    HFTPattern { addresses: Vec<String> },
    /// Cross-contract dependency
    CrossContract { contract1: String, contract2: String },
    /// Unknown pattern
    Unknown,
}

#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq)]
enum ResolutionStrategy {
    FirstWins,
    LastWins,
    HigherGasWins,
    HigherValueWins,
    MergeAdditive,
    PriorityQueue,
    RandomChoice,
}

#[derive(Debug, Clone)]
struct ResolutionOutcome {
    success: bool,
    retry_count: usize,
    resolution_time: Duration,
    value_preserved: f64, // 0.0 to 1.0
}

#[derive(Debug, Clone)]
struct PatternStats {
    occurrences: usize,
    avg_retry_count: f64,
    success_rate: f64,
    best_strategy: ResolutionStrategy,
}

#[derive(Debug, Clone)]
struct PerformanceStats {
    total_resolutions: usize,
    success_rate: f64,
    avg_resolution_time: Duration,
    value_preservation_rate: f64,
}

#[derive(Debug, Clone)]
struct LearningParams {
    /// How many conflicts to keep in history
    history_size: usize,
    /// How often to re-evaluate strategy
    evaluation_interval: Duration,
    /// Minimum conflicts before changing strategy
    min_samples: usize,
    /// Weight of recent vs historical data
    recency_weight: f64,
}

impl Default for LearningParams {
    fn default() -> Self {
        Self {
            history_size: 1000,
            evaluation_interval: Duration::from_secs(60),
            min_samples: 50,
            recency_weight: 0.7,
        }
    }
}

impl AdaptiveConflictResolver {
    pub fn new(learning_params: LearningParams) -> Self {
        let resolver = Self {
            history: Arc::new(RwLock::new(ConflictHistory::default())),
            current_strategy: Arc::new(RwLock::new(ResolutionStrategy::FirstWins)),
            learning_params: learning_params.clone(),
            evaluator: StrategyEvaluator::new(),
        };
        
        // Start learning thread
        let resolver_clone = resolver.clone();
        std::thread::spawn(move || {
            resolver_clone.learning_loop();
        });
        
        resolver
    }
    
    /// Resolve conflict adaptively
    pub fn resolve_conflict(
        &self,
        conflict: &ConflictInfo,
    ) -> Resolution {
        let start = Instant::now();
        
        // Identify pattern
        let pattern = self.identify_pattern(conflict);
        
        // Get current strategy
        let strategy = *self.current_strategy.read().unwrap();
        
        // Check if we have pattern-specific strategy
        let resolution_strategy = self.get_pattern_strategy(&pattern)
            .unwrap_or(strategy);
        
        // Apply resolution
        let resolution = self.apply_strategy(resolution_strategy, conflict);
        
        // Record outcome (would be updated with actual result)
        self.record_outcome(ConflictRecord {
            timestamp: start,
            pattern: pattern.clone(),
            resolution: resolution_strategy,
            outcome: ResolutionOutcome {
                success: true, // Would be updated with actual result
                retry_count: 0,
                resolution_time: start.elapsed(),
                value_preserved: 0.9,
            },
        });
        
        resolution
    }
    
    fn identify_pattern(&self, conflict: &ConflictInfo) -> ConflictPattern {
        match &conflict.conflict_type {
            ConflictType::AccountBalance(addr) => {
                ConflictPattern::BalanceConflict {
                    address: format!("{:?}", addr),
                }
            }
            ConflictType::StorageSlot(addr, slot) => {
                ConflictPattern::StorageConflict {
                    address: format!("{:?}", addr),
                    slot: format!("{:?}", slot),
                }
            }
            ConflictType::Multiple(conflicts) if conflicts.len() > 3 => {
                // Might be HFT pattern
                let addresses: Vec<_> = conflicts.iter()
                    .filter_map(|c| match c {
                        ConflictType::AccountBalance(a) => Some(format!("{:?}", a)),
                        _ => None,
                    })
                    .collect();
                    
                if addresses.len() > 2 {
                    ConflictPattern::HFTPattern { addresses }
                } else {
                    ConflictPattern::Unknown
                }
            }
            _ => ConflictPattern::Unknown,
        }
    }
    
    fn get_pattern_strategy(&self, pattern: &ConflictPattern) -> Option<ResolutionStrategy> {
        let history = self.history.read().unwrap();
        history.patterns.get(pattern)
            .map(|stats| stats.best_strategy)
    }
    
    fn apply_strategy(
        &self,
        strategy: ResolutionStrategy,
        conflict: &ConflictInfo,
    ) -> Resolution {
        match strategy {
            ResolutionStrategy::FirstWins => Resolution::UseFirst,
            ResolutionStrategy::LastWins => Resolution::UseSecond,
            ResolutionStrategy::HigherGasWins => {
                if conflict.tx1_gas_price > conflict.tx2_gas_price {
                    Resolution::UseFirst
                } else {
                    Resolution::UseSecond
                }
            }
            ResolutionStrategy::HigherValueWins => {
                if conflict.tx1_value > conflict.tx2_value {
                    Resolution::UseFirst
                } else {
                    Resolution::UseSecond
                }
            }
            ResolutionStrategy::MergeAdditive => {
                if self.can_merge_additive(conflict) {
                    Resolution::Merge
                } else {
                    Resolution::Retry
                }
            }
            ResolutionStrategy::PriorityQueue => {
                // Would use external priority information
                Resolution::UseFirst
            }
            ResolutionStrategy::RandomChoice => {
                if rand::random::<bool>() {
                    Resolution::UseFirst
                } else {
                    Resolution::UseSecond
                }
            }
        }
    }
    
    fn can_merge_additive(&self, conflict: &ConflictInfo) -> bool {
        matches!(conflict.conflict_type, ConflictType::AccountBalance(_))
    }
    
    fn record_outcome(&self, record: ConflictRecord) {
        let mut history = self.history.write().unwrap();
        
        // Add to recent history
        history.recent_conflicts.push_back(record.clone());
        if history.recent_conflicts.len() > self.learning_params.history_size {
            history.recent_conflicts.pop_front();
        }
        
        // Update pattern statistics
        let stats = history.patterns.entry(record.pattern.clone())
            .or_insert(PatternStats {
                occurrences: 0,
                avg_retry_count: 0.0,
                success_rate: 0.0,
                best_strategy: ResolutionStrategy::FirstWins,
            });
        
        stats.occurrences += 1;
        stats.avg_retry_count = (stats.avg_retry_count * (stats.occurrences - 1) as f64 
            + record.outcome.retry_count as f64) / stats.occurrences as f64;
        stats.success_rate = (stats.success_rate * (stats.occurrences - 1) as f64 
            + if record.outcome.success { 1.0 } else { 0.0 }) / stats.occurrences as f64;
        
        // Update strategy performance
        let perf = history.strategy_performance.entry(record.resolution)
            .or_insert(PerformanceStats {
                total_resolutions: 0,
                success_rate: 0.0,
                avg_resolution_time: Duration::ZERO,
                value_preservation_rate: 0.0,
            });
        
        perf.total_resolutions += 1;
        perf.success_rate = (perf.success_rate * (perf.total_resolutions - 1) as f64 
            + if record.outcome.success { 1.0 } else { 0.0 }) / perf.total_resolutions as f64;
        perf.value_preservation_rate = (perf.value_preservation_rate * (perf.total_resolutions - 1) as f64 
            + record.outcome.value_preserved) / perf.total_resolutions as f64;
    }
    
    fn learning_loop(&self) {
        let mut last_evaluation = Instant::now();
        
        loop {
            std::thread::sleep(Duration::from_secs(1));
            
            if last_evaluation.elapsed() >= self.learning_params.evaluation_interval {
                self.evaluate_and_adapt();
                last_evaluation = Instant::now();
            }
        }
    }
    
    fn evaluate_and_adapt(&self) {
        let history = self.history.read().unwrap();
        
        if history.recent_conflicts.len() < self.learning_params.min_samples {
            return; // Not enough data
        }
        
        // Find best performing strategy
        let best_strategy = history.strategy_performance.iter()
            .max_by(|a, b| {
                let score_a = self.evaluator.score_strategy(a.1);
                let score_b = self.evaluator.score_strategy(b.1);
                score_a.partial_cmp(&score_b).unwrap()
            })
            .map(|(strategy, _)| *strategy);
        
        if let Some(new_strategy) = best_strategy {
            let current = *self.current_strategy.read().unwrap();
            if new_strategy != current {
                println!("Adapting strategy from {:?} to {:?}", current, new_strategy);
                *self.current_strategy.write().unwrap() = new_strategy;
            }
        }
        
        // Update pattern-specific strategies
        for (pattern, stats) in &history.patterns {
            let pattern_conflicts: Vec<_> = history.recent_conflicts.iter()
                .filter(|r| &r.pattern == pattern)
                .collect();
            
            if pattern_conflicts.len() >= 10 {
                // Find best strategy for this pattern
                let best = self.find_best_strategy_for_pattern(&pattern_conflicts);
                // Update would happen here
            }
        }
    }
    
    fn find_best_strategy_for_pattern(
        &self,
        conflicts: &[&ConflictRecord],
    ) -> ResolutionStrategy {
        let mut strategy_scores: HashMap<ResolutionStrategy, f64> = HashMap::new();
        
        for record in conflicts {
            let score = self.evaluator.score_outcome(&record.outcome);
            *strategy_scores.entry(record.resolution).or_insert(0.0) += score;
        }
        
        strategy_scores.into_iter()
            .max_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
            .map(|(strategy, _)| strategy)
            .unwrap_or(ResolutionStrategy::FirstWins)
    }
}

impl Clone for AdaptiveConflictResolver {
    fn clone(&self) -> Self {
        Self {
            history: self.history.clone(),
            current_strategy: self.current_strategy.clone(),
            learning_params: self.learning_params.clone(),
            evaluator: self.evaluator.clone(),
        }
    }
}

#[derive(Debug, Clone)]
struct StrategyEvaluator;

impl StrategyEvaluator {
    fn new() -> Self {
        Self
    }
    
    fn score_strategy(&self, stats: &PerformanceStats) -> f64 {
        // Weighted score based on success rate, time, and value preservation
        stats.success_rate * 0.4 + 
        (1.0 / (1.0 + stats.avg_resolution_time.as_secs_f64())) * 0.3 +
        stats.value_preservation_rate * 0.3
    }
    
    fn score_outcome(&self, outcome: &ResolutionOutcome) -> f64 {
        let success_score = if outcome.success { 1.0 } else { 0.0 };
        let retry_penalty = 1.0 / (1.0 + outcome.retry_count as f64);
        let time_score = 1.0 / (1.0 + outcome.resolution_time.as_secs_f64());
        
        success_score * 0.5 + retry_penalty * 0.2 + time_score * 0.1 + outcome.value_preserved * 0.2
    }
}

#[derive(Debug)]
enum ConflictType {
    AccountBalance(Address),
    StorageSlot(Address, B256),
    Multiple(Vec<ConflictType>),
}

#[derive(Debug)]
struct ConflictInfo {
    conflict_type: ConflictType,
    tx1_gas_price: U256,
    tx2_gas_price: U256,
    tx1_value: U256,
    tx2_value: U256,
}

#[derive(Debug)]
enum Resolution {
    UseFirst,
    UseSecond,
    Merge,
    Retry,
}

// External dependencies would include rand crate
use rand;
use alloy_primitives::{Address, B256, U256};
```

## Questions to Ponder

1. How do we balance optimism vs pessimism based on workload characteristics?
2. What's the optimal version retention policy for MVCC?
3. How can we predict conflicts before they happen using machine learning?
4. Should conflict resolution strategies be deterministic or can they be probabilistic?
5. How do we handle cascading conflicts in complex transaction graphs?

Remember: OCC works best when conflicts are rare. If your workload has high contention, pessimistic locking might be simpler and more efficient!