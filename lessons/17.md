# Lesson 17: Merkle Patricia Tries

*"The worthwhile problems are the ones you can really solve or help solve, the ones you can really contribute something to." - Richard Feynman*

## Files with Inline Comments for This Lesson
- `crates/trie/trie/src/lib.rs` - Main trie module
- `crates/trie/common/src/hash_builder.rs` - Hash builder implementation
- `crates/trie/db/src/lib.rs` - Trie database
- `crates/trie/trie/src/node.rs` - Trie node types

## What is a Merkle Patricia Trie?

The Merkle Patricia Trie (MPT) is Ethereum's key data structure for storing state:

```
                Root Hash
                    |
              ┌─────┴─────┐
              │  Branch   │
              └─────┬─────┘
           ┌────────┼────────┐
           │        │        │
      Extension  Extension  Leaf
           │        │        │
        Branch   Branch    Value
```

It combines:
- **Patricia Trie**: Efficient key-value storage
- **Merkle Tree**: Cryptographic proofs

## Trie Node Types

### Node Structure

```rust
/// A node in the Merkle Patricia Trie
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TrieNode {
    /// Empty node (hash of empty string)
    Empty,
    /// Leaf node with key-value pair
    Leaf {
        /// Partial key from parent
        key: Nibbles,
        /// Value stored at this key
        value: Vec<u8>,
    },
    /// Extension node with shared prefix
    Extension {
        /// Shared prefix nibbles
        prefix: Nibbles,
        /// Child node (hash or embedded)
        child: NodeRef,
    },
    /// Branch node with up to 16 children
    Branch {
        /// Children for each nibble (0-15)
        children: [Option<NodeRef>; 16],
        /// Optional value at this node
        value: Option<Vec<u8>>,
    },
}

/// Reference to a child node
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NodeRef {
    /// Embedded node (small enough to include)
    Inline(Box<TrieNode>),
    /// Hash reference to node in database
    Hash(B256),
}

impl TrieNode {
    /// Calculate the hash of this node
    pub fn hash(&self) -> B256 {
        match self {
            Self::Empty => EMPTY_ROOT_HASH,
            _ => {
                let encoded = self.encode();
                if encoded.len() < 32 {
                    // Small nodes are stored inline
                    keccak256(&encoded)
                } else {
                    // Large nodes are hashed
                    keccak256(&encoded)
                }
            }
        }
    }
    
    /// Encode node for storage/hashing
    pub fn encode(&self) -> Vec<u8> {
        let mut encoder = RlpEncoder::new();
        
        match self {
            Self::Empty => {
                encoder.encode_empty();
            }
            Self::Leaf { key, value } => {
                encoder.encode_list(&[
                    compact_encode(key, true),
                    value.clone(),
                ]);
            }
            Self::Extension { prefix, child } => {
                encoder.encode_list(&[
                    compact_encode(prefix, false),
                    child.encode(),
                ]);
            }
            Self::Branch { children, value } => {
                let mut items = Vec::with_capacity(17);
                
                // Add 16 children
                for child in children {
                    match child {
                        Some(ref node) => items.push(node.encode()),
                        None => items.push(vec![]),
                    }
                }
                
                // Add value
                items.push(value.clone().unwrap_or_default());
                
                encoder.encode_list(&items);
            }
        }
        
        encoder.finish()
    }
}
```

### Nibbles and Keys

```rust
/// A sequence of nibbles (4-bit values)
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Nibbles {
    /// The nibble data
    data: Vec<u8>,
    /// Number of nibbles (may be odd)
    len: usize,
}

impl Nibbles {
    /// Create nibbles from bytes
    pub fn from_bytes(bytes: &[u8]) -> Self {
        let mut data = Vec::with_capacity(bytes.len() * 2);
        
        for byte in bytes {
            data.push(byte >> 4);    // High nibble
            data.push(byte & 0x0f);  // Low nibble
        }
        
        Self {
            len: bytes.len() * 2,
            data,
        }
    }
    
    /// Get common prefix length with another nibbles
    pub fn common_prefix_len(&self, other: &Self) -> usize {
        self.data.iter()
            .zip(other.data.iter())
            .take_while(|(a, b)| a == b)
            .count()
    }
    
    /// Split at index
    pub fn split_at(&self, index: usize) -> (Self, Self) {
        (
            Self {
                data: self.data[..index].to_vec(),
                len: index,
            },
            Self {
                data: self.data[index..].to_vec(),
                len: self.len - index,
            },
        )
    }
}

/// Compact encoding for nibbles with terminator flag
pub fn compact_encode(nibbles: &Nibbles, is_leaf: bool) -> Vec<u8> {
    let mut result = Vec::new();
    let flag = if is_leaf { 0x20 } else { 0x00 };
    
    if nibbles.len % 2 == 1 {
        // Odd length: include first nibble in flag byte
        result.push(flag | 0x10 | nibbles.data[0]);
        
        // Encode remaining pairs
        for i in (1..nibbles.len).step_by(2) {
            result.push((nibbles.data[i] << 4) | nibbles.data[i + 1]);
        }
    } else {
        // Even length: add padding nibble
        result.push(flag);
        
        // Encode pairs
        for i in (0..nibbles.len).step_by(2) {
            result.push((nibbles.data[i] << 4) | nibbles.data[i + 1]);
        }
    }
    
    result
}
```

## Trie Operations

### Insertion

```rust
pub struct Trie<DB> {
    /// Database for node storage
    db: DB,
    /// Root node
    root: TrieNode,
}

impl<DB: TrieDatabase> Trie<DB> {
    /// Insert a key-value pair
    pub fn insert(&mut self, key: &[u8], value: Vec<u8>) -> Result<(), TrieError> {
        let key_nibbles = Nibbles::from_bytes(key);
        self.root = self.insert_at(self.root.clone(), key_nibbles, value)?;
        Ok(())
    }
    
    fn insert_at(
        &mut self,
        node: TrieNode,
        key: Nibbles,
        value: Vec<u8>,
    ) -> Result<TrieNode, TrieError> {
        match node {
            TrieNode::Empty => {
                // Create new leaf
                Ok(TrieNode::Leaf { key, value })
            }
            TrieNode::Leaf { key: leaf_key, value: leaf_value } => {
                // Check if updating existing leaf
                if key == leaf_key {
                    return Ok(TrieNode::Leaf { key, value });
                }
                
                // Find common prefix
                let common_len = key.common_prefix_len(&leaf_key);
                let (common_prefix, key_suffix) = key.split_at(common_len);
                let (_, leaf_suffix) = leaf_key.split_at(common_len);
                
                // Create branch for divergence
                let mut branch = TrieNode::Branch {
                    children: Default::default(),
                    value: None,
                };
                
                // Insert both leaves
                self.insert_branch_child(&mut branch, key_suffix, value)?;
                self.insert_branch_child(&mut branch, leaf_suffix, leaf_value)?;
                
                if common_len > 0 {
                    // Need extension node
                    Ok(TrieNode::Extension {
                        prefix: common_prefix,
                        child: NodeRef::Inline(Box::new(branch)),
                    })
                } else {
                    Ok(branch)
                }
            }
            TrieNode::Extension { prefix, child } => {
                let common_len = key.common_prefix_len(&prefix);
                
                if common_len == prefix.len {
                    // Key extends this prefix
                    let (_, key_suffix) = key.split_at(common_len);
                    let child_node = self.resolve_node(child)?;
                    let new_child = self.insert_at(child_node, key_suffix, value)?;
                    
                    Ok(TrieNode::Extension {
                        prefix,
                        child: self.store_node(new_child)?,
                    })
                } else {
                    // Need to split extension
                    let (common, prefix_suffix) = prefix.split_at(common_len);
                    let (_, key_suffix) = key.split_at(common_len);
                    
                    // Create branch for split
                    let mut branch = TrieNode::Branch {
                        children: Default::default(),
                        value: None,
                    };
                    
                    // Add existing extension as child
                    if prefix_suffix.len > 0 {
                        let ext = TrieNode::Extension {
                            prefix: prefix_suffix,
                            child,
                        };
                        self.insert_branch_child_node(&mut branch, prefix_suffix, ext)?;
                    }
                    
                    // Add new value
                    self.insert_branch_child(&mut branch, key_suffix, value)?;
                    
                    if common_len > 0 {
                        Ok(TrieNode::Extension {
                            prefix: common,
                            child: NodeRef::Inline(Box::new(branch)),
                        })
                    } else {
                        Ok(branch)
                    }
                }
            }
            TrieNode::Branch { mut children, value: branch_value } => {
                if key.is_empty() {
                    // Update branch value
                    Ok(TrieNode::Branch {
                        children,
                        value: Some(value),
                    })
                } else {
                    // Insert into child
                    let nibble = key.data[0] as usize;
                    let (_, key_suffix) = key.split_at(1);
                    
                    let child = children[nibble].take()
                        .map(|c| self.resolve_node(c))
                        .transpose()?
                        .unwrap_or(TrieNode::Empty);
                        
                    let new_child = self.insert_at(child, key_suffix, value)?;
                    children[nibble] = Some(self.store_node(new_child)?);
                    
                    Ok(TrieNode::Branch {
                        children,
                        value: branch_value,
                    })
                }
            }
        }
    }
}
```

### Deletion

```rust
impl<DB: TrieDatabase> Trie<DB> {
    /// Delete a key from the trie
    pub fn delete(&mut self, key: &[u8]) -> Result<bool, TrieError> {
        let key_nibbles = Nibbles::from_bytes(key);
        let (new_root, deleted) = self.delete_at(self.root.clone(), key_nibbles)?;
        self.root = new_root;
        Ok(deleted)
    }
    
    fn delete_at(
        &mut self,
        node: TrieNode,
        key: Nibbles,
    ) -> Result<(TrieNode, bool), TrieError> {
        match node {
            TrieNode::Empty => Ok((TrieNode::Empty, false)),
            TrieNode::Leaf { key: leaf_key, .. } => {
                if key == leaf_key {
                    Ok((TrieNode::Empty, true))
                } else {
                    Ok((node, false))
                }
            }
            TrieNode::Extension { prefix, child } => {
                if key.starts_with(&prefix) {
                    let (_, key_suffix) = key.split_at(prefix.len);
                    let child_node = self.resolve_node(child)?;
                    let (new_child, deleted) = self.delete_at(child_node, key_suffix)?;
                    
                    if deleted {
                        // May need to merge nodes
                        match new_child {
                            TrieNode::Empty => Ok((TrieNode::Empty, true)),
                            TrieNode::Leaf { key: child_key, value } => {
                                // Merge extension with leaf
                                Ok((TrieNode::Leaf {
                                    key: prefix.concat(&child_key),
                                    value,
                                }, true))
                            }
                            TrieNode::Extension { prefix: child_prefix, child } => {
                                // Merge extensions
                                Ok((TrieNode::Extension {
                                    prefix: prefix.concat(&child_prefix),
                                    child,
                                }, true))
                            }
                            _ => Ok((TrieNode::Extension {
                                prefix,
                                child: self.store_node(new_child)?,
                            }, true))
                        }
                    } else {
                        Ok((node, false))
                    }
                } else {
                    Ok((node, false))
                }
            }
            TrieNode::Branch { mut children, value } => {
                if key.is_empty() {
                    if value.is_some() {
                        // Remove branch value
                        let new_branch = TrieNode::Branch {
                            children,
                            value: None,
                        };
                        Ok((self.normalize_branch(new_branch)?, true))
                    } else {
                        Ok((node, false))
                    }
                } else {
                    // Delete from child
                    let nibble = key.data[0] as usize;
                    let (_, key_suffix) = key.split_at(1);
                    
                    if let Some(child_ref) = children[nibble].take() {
                        let child_node = self.resolve_node(child_ref)?;
                        let (new_child, deleted) = self.delete_at(child_node, key_suffix)?;
                        
                        if deleted {
                            if !matches!(new_child, TrieNode::Empty) {
                                children[nibble] = Some(self.store_node(new_child)?);
                            }
                            
                            let new_branch = TrieNode::Branch { children, value };
                            Ok((self.normalize_branch(new_branch)?, true))
                        } else {
                            children[nibble] = Some(self.store_node(new_child)?);
                            Ok((TrieNode::Branch { children, value }, false))
                        }
                    } else {
                        Ok((node, false))
                    }
                }
            }
        }
    }
    
    /// Normalize branch after deletion
    fn normalize_branch(&self, branch: TrieNode) -> Result<TrieNode, TrieError> {
        if let TrieNode::Branch { children, value } = branch {
            let mut non_empty_children = Vec::new();
            
            for (i, child) in children.iter().enumerate() {
                if child.is_some() {
                    non_empty_children.push(i);
                }
            }
            
            match (non_empty_children.len(), value) {
                (0, None) => Ok(TrieNode::Empty),
                (0, Some(v)) => Ok(TrieNode::Leaf {
                    key: Nibbles::new(),
                    value: v,
                }),
                (1, None) => {
                    // Convert to extension
                    let nibble = non_empty_children[0];
                    let child = children[nibble].clone().unwrap();
                    
                    // May need to merge with child
                    let child_node = self.resolve_node(child)?;
                    match child_node {
                        TrieNode::Leaf { key, value } => {
                            Ok(TrieNode::Leaf {
                                key: Nibbles::from_nibble(nibble as u8).concat(&key),
                                value,
                            })
                        }
                        TrieNode::Extension { prefix, child } => {
                            Ok(TrieNode::Extension {
                                prefix: Nibbles::from_nibble(nibble as u8).concat(&prefix),
                                child,
                            })
                        }
                        _ => Ok(TrieNode::Extension {
                            prefix: Nibbles::from_nibble(nibble as u8),
                            child: self.store_node(child_node)?,
                        })
                    }
                }
                _ => Ok(TrieNode::Branch { children, value })
            }
        } else {
            Ok(branch)
        }
    }
}
```

## Merkle Proofs

### Generating Proofs

```rust
/// A proof that a key-value pair exists (or doesn't) in the trie
#[derive(Debug)]
pub struct MerkleProof {
    /// Nodes along the path
    pub nodes: Vec<Vec<u8>>,
    /// The key being proved
    pub key: Vec<u8>,
    /// The value (if exists)
    pub value: Option<Vec<u8>>,
}

impl<DB: TrieDatabase> Trie<DB> {
    /// Generate proof for a key
    pub fn prove(&self, key: &[u8]) -> Result<MerkleProof, TrieError> {
        let key_nibbles = Nibbles::from_bytes(key);
        let mut nodes = Vec::new();
        let value = self.prove_at(&self.root, key_nibbles, &mut nodes)?;
        
        Ok(MerkleProof {
            nodes,
            key: key.to_vec(),
            value,
        })
    }
    
    fn prove_at(
        &self,
        node: &TrieNode,
        key: Nibbles,
        proof_nodes: &mut Vec<Vec<u8>>,
    ) -> Result<Option<Vec<u8>>, TrieError> {
        // Add this node to proof
        proof_nodes.push(node.encode());
        
        match node {
            TrieNode::Empty => Ok(None),
            TrieNode::Leaf { key: leaf_key, value } => {
                if *leaf_key == key {
                    Ok(Some(value.clone()))
                } else {
                    Ok(None)
                }
            }
            TrieNode::Extension { prefix, child } => {
                if key.starts_with(prefix) {
                    let (_, key_suffix) = key.split_at(prefix.len);
                    let child_node = self.resolve_node(child.clone())?;
                    self.prove_at(&child_node, key_suffix, proof_nodes)
                } else {
                    Ok(None)
                }
            }
            TrieNode::Branch { children, value } => {
                if key.is_empty() {
                    Ok(value.clone())
                } else {
                    let nibble = key.data[0] as usize;
                    let (_, key_suffix) = key.split_at(1);
                    
                    if let Some(child_ref) = &children[nibble] {
                        let child_node = self.resolve_node(child_ref.clone())?;
                        self.prove_at(&child_node, key_suffix, proof_nodes)
                    } else {
                        Ok(None)
                    }
                }
            }
        }
    }
}
```

### Verifying Proofs

```rust
/// Verify a Merkle proof against a root hash
pub fn verify_proof(
    root_hash: B256,
    proof: &MerkleProof,
) -> Result<bool, TrieError> {
    if proof.nodes.is_empty() {
        return Ok(false);
    }
    
    // Decode and verify first node
    let root_node = TrieNode::decode(&proof.nodes[0])?;
    if root_node.hash() != root_hash {
        return Ok(false);
    }
    
    // Follow the path
    let key_nibbles = Nibbles::from_bytes(&proof.key);
    let result = verify_path(&proof.nodes, 0, key_nibbles)?;
    
    Ok(result == proof.value)
}

fn verify_path(
    nodes: &[Vec<u8>],
    node_index: usize,
    key: Nibbles,
) -> Result<Option<Vec<u8>>, TrieError> {
    if node_index >= nodes.len() {
        return Err(TrieError::InvalidProof);
    }
    
    let node = TrieNode::decode(&nodes[node_index])?;
    
    match node {
        TrieNode::Empty => Ok(None),
        TrieNode::Leaf { key: leaf_key, value } => {
            if leaf_key == key {
                Ok(Some(value))
            } else {
                Ok(None)
            }
        }
        TrieNode::Extension { prefix, child } => {
            if key.starts_with(&prefix) {
                let (_, key_suffix) = key.split_at(prefix.len);
                
                // Verify child hash matches
                if let NodeRef::Hash(expected_hash) = child {
                    let next_node = TrieNode::decode(&nodes[node_index + 1])?;
                    if next_node.hash() != expected_hash {
                        return Err(TrieError::InvalidProof);
                    }
                }
                
                verify_path(nodes, node_index + 1, key_suffix)
            } else {
                Ok(None)
            }
        }
        TrieNode::Branch { children, value } => {
            if key.is_empty() {
                Ok(value)
            } else {
                let nibble = key.data[0] as usize;
                let (_, key_suffix) = key.split_at(1);
                
                if let Some(child_ref) = &children[nibble] {
                    // Verify child hash
                    if let NodeRef::Hash(expected_hash) = child_ref {
                        let next_node = TrieNode::decode(&nodes[node_index + 1])?;
                        if next_node.hash() != expected_hash {
                            return Err(TrieError::InvalidProof);
                        }
                    }
                    
                    verify_path(nodes, node_index + 1, key_suffix)
                } else {
                    Ok(None)
                }
            }
        }
    }
}
```

## Trie Database

### Storage Interface

```rust
/// Database for trie nodes
pub trait TrieDatabase: Send + Sync {
    /// Get node by hash
    fn get(&self, hash: &B256) -> Result<Option<Vec<u8>>, DatabaseError>;
    
    /// Store node and return hash
    fn put(&mut self, node: Vec<u8>) -> Result<B256, DatabaseError>;
    
    /// Delete node by hash
    fn delete(&mut self, hash: &B256) -> Result<(), DatabaseError>;
    
    /// Start a batch operation
    fn batch(&mut self) -> Box<dyn TrieBatch>;
}

/// Batch operations for efficiency
pub trait TrieBatch {
    /// Add put operation
    fn put(&mut self, hash: B256, value: Vec<u8>);
    
    /// Add delete operation
    fn delete(&mut self, hash: B256);
    
    /// Commit all operations
    fn commit(self: Box<Self>) -> Result<(), DatabaseError>;
}

/// In-memory trie database for testing
pub struct MemoryTrieDatabase {
    nodes: HashMap<B256, Vec<u8>>,
}

impl TrieDatabase for MemoryTrieDatabase {
    fn get(&self, hash: &B256) -> Result<Option<Vec<u8>>, DatabaseError> {
        Ok(self.nodes.get(hash).cloned())
    }
    
    fn put(&mut self, node: Vec<u8>) -> Result<B256, DatabaseError> {
        let hash = keccak256(&node);
        self.nodes.insert(hash, node);
        Ok(hash)
    }
    
    fn delete(&mut self, hash: &B256) -> Result<(), DatabaseError> {
        self.nodes.remove(hash);
        Ok(())
    }
    
    fn batch(&mut self) -> Box<dyn TrieBatch> {
        Box::new(MemoryBatch {
            db: self,
            puts: Vec::new(),
            deletes: Vec::new(),
        })
    }
}
```

## Assignments with Solutions

### 1. Implement a sparse Merkle trie

```rust
use bitvec::prelude::*;

/// Sparse Merkle Trie for efficient storage of sparse data
pub struct SparseMerkleTrie {
    /// Tree depth (256 for Ethereum addresses)
    depth: usize,
    /// Root hash
    root: B256,
    /// Non-empty nodes
    nodes: HashMap<B256, SparseNode>,
    /// Default value for empty leaves
    default_value: B256,
}

#[derive(Debug, Clone)]
enum SparseNode {
    /// Internal node with left/right children
    Internal { left: B256, right: B256 },
    /// Leaf with actual value
    Leaf { value: Vec<u8> },
}

impl SparseMerkleTrie {
    pub fn new(depth: usize) -> Self {
        let default_value = B256::ZERO;
        let root = Self::empty_hash(depth, &default_value);
        
        Self {
            depth,
            root,
            nodes: HashMap::new(),
            default_value,
        }
    }
    
    /// Calculate hash for empty subtree of given height
    fn empty_hash(height: usize, default: &B256) -> B256 {
        if height == 0 {
            *default
        } else {
            let child = Self::empty_hash(height - 1, default);
            keccak256(&[child.as_bytes(), child.as_bytes()].concat())
        }
    }
    
    /// Insert value at key
    pub fn insert(&mut self, key: B256, value: Vec<u8>) -> Result<(), TrieError> {
        let path = BitVec::<u8, Msb0>::from_slice(key.as_bytes());
        let value_hash = keccak256(&value);
        
        self.nodes.insert(value_hash, SparseNode::Leaf { value });
        self.root = self.insert_at(self.root, &path, 0, value_hash)?;
        
        Ok(())
    }
    
    fn insert_at(
        &mut self,
        node_hash: B256,
        path: &BitSlice<u8, Msb0>,
        depth: usize,
        value_hash: B256,
    ) -> Result<B256, TrieError> {
        if depth == self.depth {
            // Reached leaf level
            return Ok(value_hash);
        }
        
        let empty_hash = Self::empty_hash(self.depth - depth, &self.default_value);
        
        // Get or create node
        let (left, right) = if node_hash == empty_hash {
            // Empty node - create new
            (empty_hash, empty_hash)
        } else {
            // Existing node
            match self.nodes.get(&node_hash).cloned() {
                Some(SparseNode::Internal { left, right }) => (left, right),
                _ => return Err(TrieError::InvalidNode),
            }
        };
        
        // Recurse based on path bit
        let (new_left, new_right) = if path[depth] {
            // Go right
            (left, self.insert_at(right, path, depth + 1, value_hash)?)
        } else {
            // Go left
            (self.insert_at(left, path, depth + 1, value_hash)?, right)
        };
        
        // Create new internal node
        let new_hash = keccak256(&[new_left.as_bytes(), new_right.as_bytes()].concat());
        self.nodes.insert(new_hash, SparseNode::Internal {
            left: new_left,
            right: new_right,
        });
        
        Ok(new_hash)
    }
    
    /// Generate inclusion proof
    pub fn prove(&self, key: B256) -> Result<SparseMerkleProof, TrieError> {
        let path = BitVec::<u8, Msb0>::from_slice(key.as_bytes());
        let mut siblings = Vec::with_capacity(self.depth);
        
        self.collect_siblings(self.root, &path, 0, &mut siblings)?;
        
        Ok(SparseMerkleProof {
            key,
            value: self.get(&key)?,
            siblings,
            root: self.root,
        })
    }
    
    fn collect_siblings(
        &self,
        node_hash: B256,
        path: &BitSlice<u8, Msb0>,
        depth: usize,
        siblings: &mut Vec<B256>,
    ) -> Result<(), TrieError> {
        if depth == self.depth {
            return Ok(());
        }
        
        let empty_hash = Self::empty_hash(self.depth - depth, &self.default_value);
        
        let (left, right) = if node_hash == empty_hash {
            (empty_hash, empty_hash)
        } else {
            match self.nodes.get(&node_hash) {
                Some(SparseNode::Internal { left, right }) => (*left, *right),
                _ => return Err(TrieError::InvalidNode),
            }
        };
        
        if path[depth] {
            // Going right, sibling is left
            siblings.push(left);
            self.collect_siblings(right, path, depth + 1, siblings)?;
        } else {
            // Going left, sibling is right
            siblings.push(right);
            self.collect_siblings(left, path, depth + 1, siblings)?;
        }
        
        Ok(())
    }
    
    /// Get value for key
    pub fn get(&self, key: &B256) -> Result<Option<Vec<u8>>, TrieError> {
        let path = BitVec::<u8, Msb0>::from_slice(key.as_bytes());
        let leaf_hash = self.get_leaf(self.root, &path, 0)?;
        
        if leaf_hash == self.default_value {
            Ok(None)
        } else {
            match self.nodes.get(&leaf_hash) {
                Some(SparseNode::Leaf { value }) => Ok(Some(value.clone())),
                _ => Err(TrieError::InvalidNode),
            }
        }
    }
    
    fn get_leaf(
        &self,
        node_hash: B256,
        path: &BitSlice<u8, Msb0>,
        depth: usize,
    ) -> Result<B256, TrieError> {
        if depth == self.depth {
            return Ok(node_hash);
        }
        
        let empty_hash = Self::empty_hash(self.depth - depth, &self.default_value);
        
        if node_hash == empty_hash {
            Ok(self.default_value)
        } else {
            match self.nodes.get(&node_hash) {
                Some(SparseNode::Internal { left, right }) => {
                    if path[depth] {
                        self.get_leaf(*right, path, depth + 1)
                    } else {
                        self.get_leaf(*left, path, depth + 1)
                    }
                }
                _ => Err(TrieError::InvalidNode),
            }
        }
    }
}

#[derive(Debug)]
pub struct SparseMerkleProof {
    pub key: B256,
    pub value: Option<Vec<u8>>,
    pub siblings: Vec<B256>,
    pub root: B256,
}

impl SparseMerkleProof {
    /// Verify this proof
    pub fn verify(&self) -> bool {
        let path = BitVec::<u8, Msb0>::from_slice(self.key.as_bytes());
        
        // Start with leaf hash
        let mut current = match &self.value {
            Some(v) => keccak256(v),
            None => B256::ZERO,
        };
        
        // Work up the tree
        for (i, sibling) in self.siblings.iter().enumerate().rev() {
            current = if path[self.siblings.len() - 1 - i] {
                // We were right child
                keccak256(&[sibling.as_bytes(), current.as_bytes()].concat())
            } else {
                // We were left child
                keccak256(&[current.as_bytes(), sibling.as_bytes()].concat())
            };
        }
        
        current == self.root
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_sparse_merkle_trie() {
        let mut trie = SparseMerkleTrie::new(256);
        
        // Insert some values
        let key1 = B256::from_slice(&[1u8; 32]);
        let key2 = B256::from_slice(&[2u8; 32]);
        
        trie.insert(key1, b"value1".to_vec()).unwrap();
        trie.insert(key2, b"value2".to_vec()).unwrap();
        
        // Get values
        assert_eq!(trie.get(&key1).unwrap(), Some(b"value1".to_vec()));
        assert_eq!(trie.get(&key2).unwrap(), Some(b"value2".to_vec()));
        
        // Non-existent key
        let key3 = B256::from_slice(&[3u8; 32]);
        assert_eq!(trie.get(&key3).unwrap(), None);
        
        // Generate and verify proof
        let proof = trie.prove(key1).unwrap();
        assert!(proof.verify());
    }
}
```

### 2. Create a trie diff tool

```rust
/// Represents differences between two tries
#[derive(Debug)]
pub struct TrieDiff {
    /// Keys that were added
    pub added: Vec<(Vec<u8>, Vec<u8>)>,
    /// Keys that were removed
    pub removed: Vec<(Vec<u8>, Vec<u8>)>,
    /// Keys that were modified
    pub modified: Vec<(Vec<u8>, Vec<u8>, Vec<u8>)>, // (key, old_value, new_value)
}

/// Tool for comparing two tries
pub struct TrieDiffer<DB> {
    old_db: DB,
    new_db: DB,
}

impl<DB: TrieDatabase> TrieDiffer<DB> {
    pub fn new(old_db: DB, new_db: DB) -> Self {
        Self { old_db, new_db }
    }
    
    /// Compare two tries and find differences
    pub fn diff_tries(
        &self,
        old_root: B256,
        new_root: B256,
    ) -> Result<TrieDiff, TrieError> {
        let mut diff = TrieDiff {
            added: Vec::new(),
            removed: Vec::new(),
            modified: Vec::new(),
        };
        
        if old_root == new_root {
            // Identical tries
            return Ok(diff);
        }
        
        // Load root nodes
        let old_node = self.load_node(&self.old_db, old_root)?;
        let new_node = self.load_node(&self.new_db, new_root)?;
        
        // Compare recursively
        self.diff_nodes(
            &old_node,
            &new_node,
            Nibbles::new(),
            &mut diff,
        )?;
        
        Ok(diff)
    }
    
    fn diff_nodes(
        &self,
        old: &TrieNode,
        new: &TrieNode,
        prefix: Nibbles,
        diff: &mut TrieDiff,
    ) -> Result<(), TrieError> {
        match (old, new) {
            (TrieNode::Empty, TrieNode::Empty) => Ok(()),
            
            (TrieNode::Empty, new_node) => {
                // All keys in new node are additions
                self.collect_all_keys(new_node, prefix, |k, v| {
                    diff.added.push((k, v));
                })
            }
            
            (old_node, TrieNode::Empty) => {
                // All keys in old node are removals
                self.collect_all_keys(old_node, prefix, |k, v| {
                    diff.removed.push((k, v));
                })
            }
            
            (
                TrieNode::Leaf { key: old_key, value: old_value },
                TrieNode::Leaf { key: new_key, value: new_value },
            ) => {
                let old_full_key = prefix.concat(old_key);
                let new_full_key = prefix.concat(new_key);
                
                if old_full_key == new_full_key {
                    if old_value != new_value {
                        diff.modified.push((
                            old_full_key.to_bytes(),
                            old_value.clone(),
                            new_value.clone(),
                        ));
                    }
                } else {
                    diff.removed.push((old_full_key.to_bytes(), old_value.clone()));
                    diff.added.push((new_full_key.to_bytes(), new_value.clone()));
                }
                Ok(())
            }
            
            (
                TrieNode::Extension { prefix: old_prefix, child: old_child },
                TrieNode::Extension { prefix: new_prefix, child: new_child },
            ) => {
                if old_prefix == new_prefix {
                    // Same prefix, compare children
                    let old_child_node = self.resolve_node(&self.old_db, old_child)?;
                    let new_child_node = self.resolve_node(&self.new_db, new_child)?;
                    
                    self.diff_nodes(
                        &old_child_node,
                        &new_child_node,
                        prefix.concat(old_prefix),
                        diff,
                    )
                } else {
                    // Different structure, collect all
                    self.collect_all_keys(old, prefix.clone(), |k, v| {
                        diff.removed.push((k, v));
                    })?;
                    self.collect_all_keys(new, prefix, |k, v| {
                        diff.added.push((k, v));
                    })
                }
            }
            
            (
                TrieNode::Branch { children: old_children, value: old_value },
                TrieNode::Branch { children: new_children, value: new_value },
            ) => {
                // Compare branch values
                match (old_value, new_value) {
                    (Some(old_v), Some(new_v)) if old_v != new_v => {
                        diff.modified.push((
                            prefix.to_bytes(),
                            old_v.clone(),
                            new_v.clone(),
                        ));
                    }
                    (Some(old_v), None) => {
                        diff.removed.push((prefix.to_bytes(), old_v.clone()));
                    }
                    (None, Some(new_v)) => {
                        diff.added.push((prefix.to_bytes(), new_v.clone()));
                    }
                    _ => {}
                }
                
                // Compare children
                for i in 0..16 {
                    let child_prefix = prefix.concat(&Nibbles::from_nibble(i as u8));
                    
                    match (&old_children[i], &new_children[i]) {
                        (None, None) => continue,
                        (Some(old_ref), Some(new_ref)) => {
                            let old_child = self.resolve_node(&self.old_db, old_ref)?;
                            let new_child = self.resolve_node(&self.new_db, new_ref)?;
                            
                            self.diff_nodes(&old_child, &new_child, child_prefix, diff)?;
                        }
                        (Some(old_ref), None) => {
                            let old_child = self.resolve_node(&self.old_db, old_ref)?;
                            self.collect_all_keys(&old_child, child_prefix, |k, v| {
                                diff.removed.push((k, v));
                            })?;
                        }
                        (None, Some(new_ref)) => {
                            let new_child = self.resolve_node(&self.new_db, new_ref)?;
                            self.collect_all_keys(&new_child, child_prefix, |k, v| {
                                diff.added.push((k, v));
                            })?;
                        }
                    }
                }
                Ok(())
            }
            
            // Different node types - collect all
            _ => {
                self.collect_all_keys(old, prefix.clone(), |k, v| {
                    diff.removed.push((k, v));
                })?;
                self.collect_all_keys(new, prefix, |k, v| {
                    diff.added.push((k, v));
                })
            }
        }
    }
    
    fn collect_all_keys<F>(
        &self,
        node: &TrieNode,
        prefix: Nibbles,
        mut callback: F,
    ) -> Result<(), TrieError>
    where
        F: FnMut(Vec<u8>, Vec<u8>),
    {
        match node {
            TrieNode::Empty => Ok(()),
            TrieNode::Leaf { key, value } => {
                callback(prefix.concat(key).to_bytes(), value.clone());
                Ok(())
            }
            TrieNode::Extension { prefix: ext_prefix, child } => {
                let child_node = match child {
                    NodeRef::Inline(n) => *n.clone(),
                    NodeRef::Hash(h) => self.load_node(&self.old_db, *h)?,
                };
                self.collect_all_keys(&child_node, prefix.concat(ext_prefix), callback)
            }
            TrieNode::Branch { children, value } => {
                if let Some(v) = value {
                    callback(prefix.to_bytes(), v.clone());
                }
                
                for i in 0..16 {
                    if let Some(child_ref) = &children[i] {
                        let child_node = match child_ref {
                            NodeRef::Inline(n) => *n.clone(),
                            NodeRef::Hash(h) => self.load_node(&self.old_db, *h)?,
                        };
                        
                        let child_prefix = prefix.concat(&Nibbles::from_nibble(i as u8));
                        self.collect_all_keys(&child_node, child_prefix, callback)?;
                    }
                }
                Ok(())
            }
        }
    }
    
    fn load_node(&self, db: &DB, hash: B256) -> Result<TrieNode, TrieError> {
        let encoded = db.get(&hash)?
            .ok_or(TrieError::MissingNode(hash))?;
        TrieNode::decode(&encoded)
    }
    
    fn resolve_node(&self, db: &DB, node_ref: &NodeRef) -> Result<TrieNode, TrieError> {
        match node_ref {
            NodeRef::Inline(node) => Ok(*node.clone()),
            NodeRef::Hash(hash) => self.load_node(db, *hash),
        }
    }
}

// Example usage
fn compare_state_roots(
    old_root: B256,
    new_root: B256,
    db: &impl TrieDatabase,
) -> Result<StateDiff, TrieError> {
    let differ = TrieDiffer::new(db.clone(), db.clone());
    let diff = differ.diff_tries(old_root, new_root)?;
    
    println!("State changes:");
    println!("  Added: {} accounts", diff.added.len());
    println!("  Removed: {} accounts", diff.removed.len());
    println!("  Modified: {} accounts", diff.modified.len());
    
    // Convert to more useful format
    Ok(StateDiff::from_trie_diff(diff))
}
```

### 3. Build a trie visualizer

```rust
use std::fmt::Write;

/// Visualize trie structure for debugging
pub struct TrieVisualizer;

impl TrieVisualizer {
    /// Generate DOT graph representation
    pub fn to_dot<DB: TrieDatabase>(
        db: &DB,
        root_hash: B256,
    ) -> Result<String, TrieError> {
        let mut dot = String::new();
        writeln!(&mut dot, "digraph Trie {{").unwrap();
        writeln!(&mut dot, "  rankdir=TB;").unwrap();
        writeln!(&mut dot, "  node [shape=box];").unwrap();
        
        let root = Self::load_node(db, root_hash)?;
        Self::visit_node(&mut dot, db, &root, root_hash, "")?;
        
        writeln!(&mut dot, "}}").unwrap();
        Ok(dot)
    }
    
    fn visit_node<DB: TrieDatabase>(
        dot: &mut String,
        db: &DB,
        node: &TrieNode,
        node_hash: B256,
        prefix: &str,
    ) -> Result<(), TrieError> {
        let node_id = format!("n_{}", hex::encode(&node_hash[..8]));
        
        match node {
            TrieNode::Empty => {
                writeln!(dot, "  {} [label=\"Empty\", style=dashed];", node_id).unwrap();
            }
            
            TrieNode::Leaf { key, value } => {
                let label = format!(
                    "Leaf\\nkey: {}\\nvalue: {} bytes",
                    Self::format_nibbles(key),
                    value.len()
                );
                writeln!(dot, "  {} [label=\"{}\", shape=ellipse];", node_id, label).unwrap();
            }
            
            TrieNode::Extension { prefix: ext_prefix, child } => {
                let label = format!("Extension\\nprefix: {}", Self::format_nibbles(ext_prefix));
                writeln!(dot, "  {} [label=\"{}\"];", node_id, label).unwrap();
                
                // Visit child
                let (child_node, child_hash) = match child {
                    NodeRef::Inline(n) => (*n.clone(), n.hash()),
                    NodeRef::Hash(h) => (Self::load_node(db, *h)?, *h),
                };
                
                let child_id = format!("n_{}", hex::encode(&child_hash[..8]));
                writeln!(dot, "  {} -> {};", node_id, child_id).unwrap();
                
                Self::visit_node(
                    dot,
                    db,
                    &child_node,
                    child_hash,
                    &format!("{}{}", prefix, Self::format_nibbles(ext_prefix)),
                )?;
            }
            
            TrieNode::Branch { children, value } => {
                let label = if value.is_some() {
                    format!("Branch\\n(has value: {} bytes)", value.as_ref().unwrap().len())
                } else {
                    "Branch".to_string()
                };
                writeln!(dot, "  {} [label=\"{}\", shape=diamond];", node_id, label).unwrap();
                
                // Visit children
                for i in 0..16 {
                    if let Some(child_ref) = &children[i] {
                        let (child_node, child_hash) = match child_ref {
                            NodeRef::Inline(n) => (*n.clone(), n.hash()),
                            NodeRef::Hash(h) => (Self::load_node(db, *h)?, *h),
                        };
                        
                        let child_id = format!("n_{}", hex::encode(&child_hash[..8]));
                        writeln!(
                            dot,
                            "  {} -> {} [label=\"{:x}\"];",
                            node_id, child_id, i
                        ).unwrap();
                        
                        Self::visit_node(
                            dot,
                            db,
                            &child_node,
                            child_hash,
                            &format!("{}{:x}", prefix, i),
                        )?;
                    }
                }
            }
        }
        
        Ok(())
    }
    
    fn load_node<DB: TrieDatabase>(db: &DB, hash: B256) -> Result<TrieNode, TrieError> {
        let encoded = db.get(&hash)?
            .ok_or(TrieError::MissingNode(hash))?;
        TrieNode::decode(&encoded)
    }
    
    fn format_nibbles(nibbles: &Nibbles) -> String {
        nibbles.data.iter()
            .map(|n| format!("{:x}", n))
            .collect::<String>()
    }
    
    /// Generate ASCII art visualization
    pub fn to_ascii<DB: TrieDatabase>(
        db: &DB,
        root_hash: B256,
        max_depth: usize,
    ) -> Result<String, TrieError> {
        let mut output = String::new();
        let root = Self::load_node(db, root_hash)?;
        
        writeln!(&mut output, "Root: {}", hex::encode(&root_hash[..8])).unwrap();
        Self::print_node(&mut output, db, &root, "", true, 0, max_depth)?;
        
        Ok(output)
    }
    
    fn print_node<DB: TrieDatabase>(
        output: &mut String,
        db: &DB,
        node: &TrieNode,
        prefix: &str,
        is_last: bool,
        depth: usize,
        max_depth: usize,
    ) -> Result<(), TrieError> {
        if depth > max_depth {
            writeln!(output, "{}...", prefix).unwrap();
            return Ok(());
        }
        
        let connector = if is_last { "└── " } else { "├── " };
        let extension = if is_last { "    " } else { "│   " };
        
        match node {
            TrieNode::Empty => {
                writeln!(output, "{}{}[Empty]", prefix, connector).unwrap();
            }
            
            TrieNode::Leaf { key, value } => {
                writeln!(
                    output,
                    "{}{}Leaf({}) = {} bytes",
                    prefix,
                    connector,
                    Self::format_nibbles(key),
                    value.len()
                ).unwrap();
            }
            
            TrieNode::Extension { prefix: ext_prefix, child } => {
                writeln!(
                    output,
                    "{}{}Extension({})",
                    prefix,
                    connector,
                    Self::format_nibbles(ext_prefix)
                ).unwrap();
                
                let child_node = match child {
                    NodeRef::Inline(n) => *n.clone(),
                    NodeRef::Hash(h) => Self::load_node(db, *h)?,
                };
                
                Self::print_node(
                    output,
                    db,
                    &child_node,
                    &format!("{}{}", prefix, extension),
                    true,
                    depth + 1,
                    max_depth,
                )?;
            }
            
            TrieNode::Branch { children, value } => {
                let value_info = if value.is_some() {
                    format!(" (value: {} bytes)", value.as_ref().unwrap().len())
                } else {
                    String::new()
                };
                writeln!(output, "{}{}Branch{}", prefix, connector, value_info).unwrap();
                
                let mut child_indices: Vec<_> = children.iter()
                    .enumerate()
                    .filter_map(|(i, c)| c.as_ref().map(|_| i))
                    .collect();
                
                for (idx, &i) in child_indices.iter().enumerate() {
                    let is_last_child = idx == child_indices.len() - 1;
                    let child_ref = &children[i].as_ref().unwrap();
                    
                    let child_node = match child_ref {
                        NodeRef::Inline(n) => *n.clone(),
                        NodeRef::Hash(h) => Self::load_node(db, *h)?,
                    };
                    
                    writeln!(
                        output,
                        "{}{}[{:x}]",
                        &format!("{}{}", prefix, extension),
                        if is_last_child { "└── " } else { "├── " },
                        i
                    ).unwrap();
                    
                    Self::print_node(
                        output,
                        db,
                        &child_node,
                        &format!("{}{}{}", prefix, extension, if is_last_child { "    " } else { "│   " }),
                        true,
                        depth + 1,
                        max_depth,
                    )?;
                }
            }
        }
        
        Ok(())
    }
}

// Example usage
fn visualize_account_trie(root: B256, db: &impl TrieDatabase) -> Result<(), TrieError> {
    // Generate DOT file
    let dot = TrieVisualizer::to_dot(db, root)?;
    std::fs::write("trie.dot", dot)?;
    
    // Generate ASCII visualization
    let ascii = TrieVisualizer::to_ascii(db, root, 3)?;
    println!("Trie structure:\n{}", ascii);
    
    // Convert DOT to image
    std::process::Command::new("dot")
        .args(&["-Tpng", "trie.dot", "-o", "trie.png"])
        .status()?;
    
    Ok(())
}
```

## Questions to Ponder - Detailed Answers

### 1. Why use a Patricia Trie instead of a regular trie?

**Space Efficiency**:
- **Regular Trie**: One node per character/nibble
- **Patricia Trie**: Compress paths with single children
- **Example**: Key "ethereum" would need 8 nodes in regular trie, maybe 2-3 in Patricia

**Performance Benefits**:
- Fewer nodes = fewer disk reads
- Shorter paths = faster lookups
- Better cache locality

**Trade-offs**:
- More complex insertion/deletion
- Variable node sizes
- Need to handle path splitting

### 2. How do extension nodes improve efficiency?

**Path Compression**:
```
Without extension:
root -> branch -> branch -> branch -> leaf

With extension:
root -> extension("abc") -> leaf
```

**Benefits**:
1. **Fewer Hops**: Direct jump over common prefixes
2. **Less Storage**: One node instead of many
3. **Faster Traversal**: Skip intermediate nodes

**Real-world Impact**:
- Contract storage often has common prefixes
- Sequential keys benefit most
- Can reduce tree depth significantly

### 3. What are the security implications of Merkle tries?

**Cryptographic Properties**:

1. **Tamper Evidence**:
   - Any change produces different root
   - Can't modify without detection
   - Enables light client security

2. **Proof Generation**:
   - Compact proofs of inclusion/exclusion
   - Verifiable without full state
   - Essential for stateless clients

3. **Deterministic Structure**:
   - Same data always produces same root
   - Enables consensus without sharing full state
   - Prevents ambiguity attacks

**Attack Considerations**:
- DoS via deep tries (mitigated by gas costs)
- Storage bloat (addressed by state rent proposals)
- Proof size for deep paths